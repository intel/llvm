cmake_minimum_required(VERSION 3.4.3)

if(POLICY CMP0075)
  cmake_policy(SET CMP0075 NEW)
endif()

# Add path for custom modules.
set(CMAKE_MODULE_PATH
  ${CMAKE_MODULE_PATH}
  "${CMAKE_CURRENT_SOURCE_DIR}/cmake"
  "${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules"
  )

# If we are not building as part of LLVM, build LLDB as a standalone project,
# using LLVM as an external library.
if (CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)
  project(lldb)
  include(LLDBStandalone)
endif()

include(LLDBConfig)
include(AddLLDB)

# Define the LLDB_CONFIGURATION_xxx matching the build type.
if( uppercase_CMAKE_BUILD_TYPE STREQUAL "DEBUG" )
  add_definitions( -DLLDB_CONFIGURATION_DEBUG )
else()
  add_definitions( -DLLDB_CONFIGURATION_RELEASE )
endif()

if(APPLE)
  add_definitions(-DLLDB_USE_OS_LOG)
endif()

if (WIN32)
  add_definitions(-D_ENABLE_EXTENDED_ALIGNED_STORAGE)
endif()

if (NOT LLDB_DISABLE_PYTHON)
  execute_process(
    COMMAND ${PYTHON_EXECUTABLE}
        -c "import distutils.sysconfig; print(distutils.sysconfig.get_python_lib(False, False, ''))"
    OUTPUT_VARIABLE LLDB_PYTHON_DEFAULT_RELATIVE_PATH
    OUTPUT_STRIP_TRAILING_WHITESPACE)

  file(TO_CMAKE_PATH ${LLDB_PYTHON_DEFAULT_RELATIVE_PATH} LLDB_PYTHON_DEFAULT_RELATIVE_PATH)
  set(LLDB_PYTHON_RELATIVE_PATH ${LLDB_PYTHON_DEFAULT_RELATIVE_PATH}
    CACHE STRING "Path where Python modules are installed, relative to install prefix")

  add_subdirectory(scripts)
endif ()

# We need the headers generated by instrinsics_gen before we can compile
# any source file in LLDB as the imported Clang modules might include
# some of these generated headers. This approach is copied from Clang's main
# CMakeLists.txt, so it should kept in sync the code in Clang which was added
# in llvm-svn 308844.
if(LLVM_ENABLE_MODULES AND NOT LLDB_BUILT_STANDALONE)
  list(APPEND LLVM_COMMON_DEPENDS intrinsics_gen)
endif()

if(CMAKE_CROSSCOMPILING AND LLDB_BUILT_STANDALONE)
  set(LLVM_USE_HOST_TOOLS ON)
  include(CrossCompile)
  if (NOT NATIVE_LLVM_DIR OR NOT NATIVE_Clang_DIR)
    message(FATAL_ERROR
      "Crosscompiling standalone requires the variables NATIVE_{CLANG,LLVM}_DIR
      for building the native lldb-tblgen used during the build process.")
  endif()
  llvm_create_cross_target(lldb NATIVE "" Release
    -DLLVM_DIR=${NATIVE_LLVM_DIR}
    -DClang_DIR=${NATIVE_Clang_DIR})
endif()

# TableGen
add_subdirectory(utils/TableGen)

add_subdirectory(source)
add_subdirectory(tools)
add_subdirectory(docs)

option(LLDB_INCLUDE_TESTS "Generate build targets for the LLDB unit tests." ${LLVM_INCLUDE_TESTS})
if(LLDB_INCLUDE_TESTS)
  set(LLDB_TEST_BUILD_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/lldb-test-build.noindex" CACHE PATH "The build root for building tests.")

  # Set the path to the default lldb test executable.
  set(LLDB_DEFAULT_TEST_EXECUTABLE "${LLVM_RUNTIME_OUTPUT_INTDIR}/lldb${CMAKE_EXECUTABLE_SUFFIX}")

  # Set the paths to default llvm tools.
  set(LLDB_DEFAULT_TEST_DSYMUTIL "${LLVM_BINARY_DIR}/${CMAKE_CFG_INTDIR}/bin/dsymutil${CMAKE_EXECUTABLE_SUFFIX}")
  set(LLDB_DEFAULT_TEST_FILECHECK "${LLVM_BINARY_DIR}/${CMAKE_CFG_INTDIR}/bin/FileCheck${CMAKE_EXECUTABLE_SUFFIX}")

  if (TARGET clang)
    set(LLDB_DEFAULT_TEST_C_COMPILER "${LLVM_BINARY_DIR}/${CMAKE_CFG_INTDIR}/bin/clang${CMAKE_EXECUTABLE_SUFFIX}")
    set(LLDB_DEFAULT_TEST_CXX_COMPILER "${LLVM_BINARY_DIR}/${CMAKE_CFG_INTDIR}/bin/clang++${CMAKE_EXECUTABLE_SUFFIX}")
  else()
    set(LLDB_DEFAULT_TEST_C_COMPILER "")
    set(LLDB_DEFAULT_TEST_CXX_COMPILER "")
  endif()

  set(LLDB_TEST_EXECUTABLE "${LLDB_DEFAULT_TEST_EXECUTABLE}" CACHE PATH "lldb executable used for testing")
  set(LLDB_TEST_C_COMPILER "${LLDB_DEFAULT_TEST_C_COMPILER}" CACHE PATH "C Compiler to use for building LLDB test inferiors")
  set(LLDB_TEST_CXX_COMPILER "${LLDB_DEFAULT_TEST_CXX_COMPILER}" CACHE PATH "C++ Compiler to use for building LLDB test inferiors")
  set(LLDB_TEST_DSYMUTIL "${LLDB_DEFAULT_TEST_DSYMUTIL}" CACHE PATH "dsymutil used for generating dSYM bundles")
  set(LLDB_TEST_FILECHECK "${LLDB_DEFAULT_TEST_FILECHECK}" CACHE PATH "FileCheck used for testing purposes")

  if (("${LLDB_TEST_C_COMPILER}" STREQUAL "") OR
      ("${LLDB_TEST_CXX_COMPILER}" STREQUAL ""))
    message(FATAL_ERROR "LLDB test compilers not specified. Tests will not run.")
  endif()

  add_custom_target(lldb-test-deps)
  set_target_properties(lldb-test-deps PROPERTIES FOLDER "lldb misc")
  add_lldb_test_dependency(lldb)

  # lldb-test is an hard dependency for the testsuite.
  add_lldb_test_dependency(lldb-test)

  # darwin-debug is an hard dependency for the testsuite.
  if (CMAKE_SYSTEM_NAME MATCHES "Darwin")
    add_lldb_test_dependency(darwin-debug)
  endif()

  if(TARGET lldb-server)
    add_lldb_test_dependency(lldb-server)
  endif()

  if(TARGET lldb-vscode)
    add_lldb_test_dependency(lldb-vscode)
  endif()

  if(TARGET lldb-instr)
    add_lldb_test_dependency(lldb-instr)
  endif()

  if(NOT LLDB_BUILT_STANDALONE)
    add_lldb_test_dependency(yaml2obj)
    add_lldb_test_dependency(dsymutil)
  endif()

  if(TARGET liblldb)
    add_lldb_test_dependency(liblldb)
  endif()

  if(TARGET lldb-framework)
    add_lldb_test_dependency(lldb-framework)
  endif()

  # Add dependencies if we test with the in-tree clang.
  # This works with standalone builds as they import the clang target.
  if(TARGET clang)
    add_lldb_test_dependency(clang)
    if(APPLE)
      # If we build clang, we should build libcxx.
      # FIXME: Standalone builds should import the cxx target as well.
      if(LLDB_BUILT_STANDALONE)
        # For now check that the include directory exists.
        set(cxx_dir "${LLVM_BINARY_DIR}/include/c++")
        if(NOT EXISTS ${cxx_dir})
          message(WARNING "LLDB test suite requires libc++ in llvm/projects/libcxx or an existing build symlinked to ${cxx_dir}")
        endif()
      else()
        # We require libcxx for the test suite, so if we aren't building it,
        # try to provide a helpful error about how to resolve the situation.
        if(NOT TARGET cxx)
          if(LLVM_ENABLE_PROJECTS STREQUAL "")
            # If `LLVM_ENABLE_PROJECTS` is not being used (implying that we are
            # using the old layout), suggest checking it out.
            message(FATAL_ERROR
              "LLDB test suite requires libc++, but it is currently disabled. "
              "Please checkout `libcxx` in `llvm/projects` or disable tests "
              "via `LLDB_INCLUDE_TESTS=OFF`.")
          else()
            # If `LLVM_ENABLE_PROJECTS` is being used, suggest adding it.
            message(FATAL_ERROR
              "LLDB test suite requires libc++, but it is currently disabled. "
              "Please add `libcxx` to `LLVM_ENABLE_PROJECTS` or disable tests "
              "via `LLDB_INCLUDE_TESTS=OFF`.")
          endif()
        endif()
        add_lldb_test_dependency(cxx)
      endif()
    endif()
  endif()

  add_subdirectory(test)
  add_subdirectory(unittests)
  add_subdirectory(utils/lit-cpuid)
  add_subdirectory(utils/lldb-dotest)
endif()

if (NOT LLDB_DISABLE_PYTHON)
  if(NOT LLDB_BUILD_FRAMEWORK)
    set(use_python_wrapper_from_src_dir -m)
  endif()
  if(LLDB_USE_SYSTEM_SIX)
    set(use_six_py_from_system --useSystemSix)
  endif()
  get_target_property(lldb_scripts_dir swig_wrapper BINARY_DIR)
  get_target_property(liblldb_build_dir liblldb LIBRARY_OUTPUT_DIRECTORY)

  if(LLDB_BUILD_FRAMEWORK)
    set(lldb_python_build_path "${liblldb_build_dir}/LLDB.framework/Resources/Python/lldb")
  else()
    set(lldb_python_build_path "${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/${LLDB_PYTHON_RELATIVE_PATH}/lldb")
  endif()

  # Add a Post-Build Event to copy over Python files and create the symlink
  # to liblldb.so for the Python API(hardlink on Windows).
  add_custom_target(finish_swig ALL
    COMMAND ${CMAKE_COMMAND} -E make_directory ${lldb_python_build_path}
    COMMAND
      ${PYTHON_EXECUTABLE} ${LLDB_SOURCE_DIR}/scripts/finishSwigWrapperClasses.py
        --srcRoot=${LLDB_SOURCE_DIR}
        --targetDir=${liblldb_build_dir}
        --cfgBldDir=${lldb_scripts_dir}
        --prefix=${CMAKE_BINARY_DIR}
        --cmakeBuildConfiguration=${CMAKE_CFG_INTDIR}
        --lldbLibDir=lib${LLVM_LIBDIR_SUFFIX}
        --lldbPythonPath=${lldb_python_build_path}
        ${use_python_wrapper_from_src_dir}
        ${use_six_py_from_system}
    VERBATIM
    DEPENDS ${LLDB_SOURCE_DIR}/scripts/finishSwigWrapperClasses.py
    DEPENDS ${lldb_scripts_dir}/lldb.py
    COMMENT "Python script sym-linking LLDB Python API")

  if(NOT LLDB_USE_SYSTEM_SIX)
    add_custom_command(TARGET finish_swig POST_BUILD VERBATIM
      COMMAND ${CMAKE_COMMAND} -E copy
        "${LLDB_SOURCE_DIR}/third_party/Python/module/six/six.py"
        "${lldb_python_build_path}/../six.py")
  endif()

  add_custom_command(TARGET finish_swig POST_BUILD VERBATIM
    COMMAND ${CMAKE_COMMAND} -E copy
      "${lldb_scripts_dir}/lldb.py"
      "${lldb_python_build_path}/__init__.py")

  if(APPLE)
    SET(lldb_python_heap_dir "${lldb_python_build_path}/macosx/heap")
    add_custom_command(TARGET finish_swig POST_BUILD VERBATIM
      COMMAND ${CMAKE_COMMAND} -E make_directory ${lldb_python_heap_dir}
      COMMAND ${CMAKE_COMMAND} -E copy
        "${LLDB_SOURCE_DIR}/examples/darwin/heap_find/heap/heap_find.cpp"
        "${LLDB_SOURCE_DIR}/examples/darwin/heap_find/heap/Makefile"
        ${lldb_python_heap_dir})
  endif()

  function(create_relative_symlink target dest_file output_dir output_name)
    get_filename_component(dest_file ${dest_file} ABSOLUTE)
    get_filename_component(output_dir ${output_dir} ABSOLUTE)
    file(RELATIVE_PATH rel_dest_file ${output_dir} ${dest_file})
    if(CMAKE_HOST_UNIX)
      set(LLVM_LINK_OR_COPY create_symlink)
    else()
      set(LLVM_LINK_OR_COPY copy)
    endif()
    add_custom_command(TARGET ${target} POST_BUILD VERBATIM
      COMMAND ${CMAKE_COMMAND} -E ${LLVM_LINK_OR_COPY} ${rel_dest_file} ${output_name}
      WORKING_DIRECTORY ${output_dir})
  endfunction()

  if(LLDB_BUILD_FRAMEWORK)
    set(LIBLLDB_SYMLINK_DEST "${liblldb_build_dir}/LLDB.framework/LLDB")
  else()
    set(LIBLLDB_SYMLINK_DEST "${LLVM_SHLIB_OUTPUT_INTDIR}/liblldb${CMAKE_SHARED_LIBRARY_SUFFIX}")
  endif()
  if(WIN32)
    if(CMAKE_BUILD_TYPE STREQUAL Debug)
      set(LIBLLDB_SYMLINK_OUTPUT_FILE "_lldb_d.pyd")
    else()
      set(LIBLLDB_SYMLINK_OUTPUT_FILE "_lldb.pyd")
    endif()
  else()
    set(LIBLLDB_SYMLINK_OUTPUT_FILE "_lldb.so")
  endif()
  create_relative_symlink(finish_swig ${LIBLLDB_SYMLINK_DEST}
                          ${lldb_python_build_path} ${LIBLLDB_SYMLINK_OUTPUT_FILE})

  if(NOT LLDB_BUILD_FRAMEWORK)
    set(LLDB_ARGDUMPER_FILENAME "lldb-argdumper${CMAKE_EXECUTABLE_SUFFIX}")
    create_relative_symlink(finish_swig "${LLVM_RUNTIME_OUTPUT_INTDIR}/${LLDB_ARGDUMPER_FILENAME}"
                            ${lldb_python_build_path} ${LLDB_ARGDUMPER_FILENAME})
  endif()

  add_dependencies(finish_swig swig_wrapper liblldb lldb-argdumper)
  set_target_properties(finish_swig swig_wrapper PROPERTIES FOLDER "lldb misc")

  # Ensure we do the python post-build step when building lldb.
  add_dependencies(lldb finish_swig)

  if(NOT LLDB_BUILD_FRAMEWORK)
    # Install the LLDB python module
    add_custom_target(lldb-python-scripts)
    add_dependencies(lldb-python-scripts finish_swig)
    install(DIRECTORY ${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/${LLDB_PYTHON_RELATIVE_PATH}/
            DESTINATION ${LLDB_PYTHON_RELATIVE_PATH}
            COMPONENT lldb-python-scripts)
    if (NOT LLVM_ENABLE_IDE)
      add_llvm_install_targets(install-lldb-python-scripts
                               COMPONENT lldb-python-scripts
                               DEPENDS lldb-python-scripts)
    endif()
  endif()

  # Add a Post-Build Event to copy the custom Python DLL to the lldb binaries dir so that Windows can find it when launching
  # lldb.exe or any other executables that were linked with liblldb.
  if (WIN32 AND NOT "${PYTHON_DLL}" STREQUAL "")
    # When using the Visual Studio CMake generator the lldb binaries end up in Release/bin, Debug/bin etc.
    file(TO_NATIVE_PATH "${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/bin" LLDB_BIN_DIR)
    file(TO_NATIVE_PATH "${PYTHON_DLL}" PYTHON_DLL_NATIVE_PATH)
    add_custom_command(
      TARGET finish_swig
      POST_BUILD
      COMMAND ${CMAKE_COMMAND} -E copy ${PYTHON_DLL_NATIVE_PATH} ${LLDB_BIN_DIR} VERBATIM
      COMMENT "Copying Python DLL to LLDB binaries directory.")
  endif ()
endif ()

if(LLDB_BUILT_STANDALONE AND NOT LLVM_ENABLE_IDE)
  llvm_distribution_add_targets()
endif()
