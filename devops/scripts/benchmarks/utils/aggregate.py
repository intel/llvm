import heapq
import statistics
from abc import ABC, abstractmethod


class Aggregator(ABC):
    """
    Aggregator classes used to "aggregate" a pool of elements, and produce an
    "average" (precisely, some "measure of central tendency") from the elements.
    """

    @staticmethod
    @abstractmethod
    def get_type() -> str:
        """
        Return a string indicating the type of average this aggregator
        produces.
        """
        pass

    @abstractmethod
    def add(self, n: float):
        """
        Add/aggregate an element to the pool of elements used by this aggregator
        to produce an average calculation.
        """
        pass

    @abstractmethod
    def get_avg(self) -> float:
        """
        Produce an average from the pool of elements aggregated using add().
        """
        pass


class SimpleMedian(Aggregator):
    """
    Simple median calculation: if the number of samples being generated are low,
    this is the fastest median method.
    """

    def __init__(self, starting_elements: list = []):
        self.elements = starting_elements

    @staticmethod
    def get_type() -> str:
        return "median"

    def add(self, n: float):
        self.elements.append(n)

    def get_avg(self) -> float:
        return statistics.median(self.elements)


class StreamingMedian(Aggregator):
    """
    Calculate medians incrementally using heaps: Theoretically the fastest way
    to calculate a median from a stream of elements, but realistically is only
    faster when dealing with huge numbers of samples that would be generated by
    i.e. enabling this workflow in precommit and using longer periods of time.
    """

    def __init__(self, starting_elements: list = []):
        # Gist: we keep a minheap and a maxheap, and store the median as the top
        # of the minheap. When a new element comes it gets put into the heap
        # based on if the element is bigger than the current median. Then, the
        # heaps are heapified and the median is repopulated by heapify.
        self.minheap_larger = []
        self.maxheap_smaller = []

        map(lambda n: self.add(n), starting_elements)

    @staticmethod
    def get_type() -> str:
        return "median"

    # Note: numbers on maxheap should be negative, as heapq
    # is minheap by default

    def add(self, n: float):
        if len(self.maxheap_smaller) == 0 or -self.maxheap_smaller[0] >= n:
            heapq.heappush(self.maxheap_smaller, -n)
        else:
            heapq.heappush(self.minheap_larger, n)

        # Ensure minheap has more elements than maxheap
        if len(self.maxheap_smaller) > len(self.minheap_larger) + 1:
            heapq.heappush(self.minheap_larger, -heapq.heappop(self.maxheap_smaller))
        elif len(self.maxheap_smaller) < len(self.minheap_larger):
            heapq.heappush(self.maxheap_smaller, -heapq.heappop(self.minheap_larger))

    def get_avg(self) -> float:
        if len(self.maxheap_smaller) == len(self.minheap_larger):
            # Equal number of elements smaller and larger than "median":
            # thus, there are two median values. The median would then become
            # the average of both median values.
            return (-self.maxheap_smaller[0] + self.minheap_larger[0]) / 2.0
        else:
            # Otherwise, median is always in minheap, as minheap is always
            # bigger
            return -self.maxheap_smaller[0]


