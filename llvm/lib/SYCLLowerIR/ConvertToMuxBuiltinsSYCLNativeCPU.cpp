//===-- ConvertToMuxBuiltinsSYCLNativeCPU.cpp - Convert to Mux Builtins ---===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Converts SPIRV builtins to Mux builtins used by the oneAPI Construction
// Kit for SYCL Native CPU
//
//===----------------------------------------------------------------------===//

#include "llvm/SYCLLowerIR/ConvertToMuxBuiltinsSYCLNativeCPU.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/TargetParser/Triple.h"
#include <map>

using namespace llvm;

namespace {

static void fixFunctionAttributes(Function *F) {
  // The frame-pointer=all and the "byval" attributes lead to code generation
  // that conflicts with the Kernel declaration that we emit in the Native CPU
  // helper header (in which all the kernel argument are void* or scalars).
  auto AttList = F->getAttributes();
  for (unsigned ArgNo = 0; ArgNo < F->getFunctionType()->getNumParams();
       ArgNo++) {
    if (AttList.hasParamAttr(ArgNo, Attribute::AttrKind::ByVal)) {
      AttList = AttList.removeParamAttribute(F->getContext(), ArgNo,
                                             Attribute::AttrKind::ByVal);
    }
  }
  F->setAttributes(AttList);
  F->addFnAttr("frame-pointer", "none");
}

// Builtin signature type
enum class BT_Sig {
  I64_I32,     // i64(i32)
  I32_void,    // i32()
  B1_I32_B1,   // B1(I32, B1)
  I32_I32_I32, // I32(I32, I32)
  F64_F64_I32, // F64(F64, I32)
  F64_F64_F64_I32, // F64(F64, F64, I32)
};

// Helper macros for constructing builtin MS names
#define GENMS_I64_I32(builtin_str) "?" builtin_str "@@YA_KXZ"
#define GENMS_I32_VOID(builtin_str) "?" builtin_str "@@YAIXZ"

#define LENCHECK(b_str, len) []() { static_assert(sizeof(b_str) == len + 1); }

#define GEN_IT_proc(b_str, len) (LENCHECK(b_str, len), "_Z" #len b_str "v")
#define GEN_p(b_str, len, ncpu_bstr, num)                                      \
  {                                                                            \
    {GEN_IT_proc(b_str, len), GENMS_I64_I32(b_str)}, {                         \
      ncpu_bstr, {                                                             \
        BT_Sig::I64_I32, { num }                                               \
      }                                                                        \
    }                                                                          \
  }
#define GEN_xyz(b_name, len, ncpu_name)                                        \
  GEN_p(#b_name "_x", len, #ncpu_name, 0),                                     \
      GEN_p(#b_name "_y", len, #ncpu_name, 1),                                 \
      GEN_p(#b_name "_z", len, #ncpu_name, 2)

#define GEN_u32(b_name, len, ncpu_name)                                        \
  {                                                                            \
    { GEN_IT_proc(#b_name, len), GENMS_I32_VOID(#b_name) }                     \
    , {                                                                        \
      #ncpu_name, {                                                            \
        BT_Sig::I32_void, {}                                                   \
      }                                                                        \
    }                                                                          \
  }

struct bt_info {
  BT_Sig type;
  unsigned args[1];
};

// Todo: replace this map with BC file generated by clang
static const std::pair<std::pair<StringRef, StringRef>,
                       std::pair<StringRef, bt_info>>
    BuiltinNamesMap[] = {
        GEN_xyz(__spirv_GlobalInvocationId, 28, __mux_get_global_id),
        GEN_xyz(__spirv_GlobalSize, 20, __mux_get_global_size),
        GEN_xyz(__spirv_GlobalOffset, 22, __mux_get_global_offset),
        GEN_xyz(__spirv_LocalInvocationId, 27, __mux_get_local_id),
        GEN_xyz(__spirv_NumWorkgroups, 23, __mux_get_num_groups),
        GEN_xyz(__spirv_WorkgroupSize, 23, __mux_get_local_size),
        GEN_xyz(__spirv_WorkgroupId, 21, __mux_get_group_id),
        // subgroup
        GEN_u32(__spirv_SubgroupLocalInvocationId, 33,
                __mux_get_sub_group_local_id), // check
        GEN_u32(__spirv_SubgroupMaxSize, 23, __mux_get_max_sub_group_size),
        GEN_u32(__spirv_SubgroupId, 18, __mux_get_sub_group_id),
        GEN_u32(__spirv_NumSubgroups, 20, __mux_get_num_sub_groups),
        GEN_u32(__spirv_SubgroupSize, 20, __mux_get_sub_group_size),
};

static inline bool isForVisualStudio(StringRef TripleStr) {
  llvm::Triple Triple(TripleStr);
  return Triple.isKnownWindowsMSVCEnvironment();
}

static constexpr char SPIRVBarrier[] = "_Z22__spirv_ControlBarrierjjj";
static constexpr char SPIRVBarrierWin[] = "?__spirv_ControlBarrier@@YAXIII@Z";
static constexpr char MuxBarrier[] = "__mux_work_group_barrier";

static FunctionType *getFuncType(BT_Sig FType, LLVMContext &Ctx) {
  switch (FType) {
  case BT_Sig::I64_I32:
    return FunctionType::get(Type::getInt64Ty(Ctx), {Type::getInt32Ty(Ctx)},
                             false);
  case BT_Sig::I32_void:
    return FunctionType::get(Type::getInt32Ty(Ctx), {}, false);
  case BT_Sig::B1_I32_B1:
    return FunctionType::get(Type::getInt1Ty(Ctx),
                             {Type::getInt32Ty(Ctx), Type::getInt1Ty(Ctx)},
                             false);
  case BT_Sig::I32_I32_I32:
    return FunctionType::get(Type::getInt32Ty(Ctx),
                             {Type::getInt32Ty(Ctx), Type::getInt32Ty(Ctx)},
                             false);
  case BT_Sig::F64_F64_I32: // F64(F64, I32)
    return FunctionType::get(Type::getDoubleTy(Ctx),
      { Type::getDoubleTy(Ctx), Type::getInt32Ty(Ctx) },
      false);
  case BT_Sig::F64_F64_F64_I32: // F64(F64, F64, I32)
    return FunctionType::get(Type::getDoubleTy(Ctx),
      { Type::getDoubleTy(Ctx), Type::getDoubleTy(Ctx), Type::getInt32Ty(Ctx) },
      false);
  }
  report_fatal_error("Unsupported Value in SYCL Native CPU\n");
  return nullptr;
}

Function *getReplaceFunc(Module &M, StringRef Name, BT_Sig FType) {
  LLVMContext &Ctx = M.getContext();
  auto *MuxFTy = getFuncType(FType, Ctx);
  auto F = M.getOrInsertFunction(Name, MuxFTy);
  return cast<Function>(F.getCallee());
}

Function *getMuxBarrierFunc(Module &M) {
  // void __mux_work_group_barrier(i32 %id, i32 %scope, i32 %semantics)
  LLVMContext &Ctx = M.getContext();
  auto *Int32Ty = Type::getInt32Ty(Ctx);
  static auto *MuxFTy = FunctionType::get(Type::getVoidTy(Ctx),
                                          {Int32Ty, Int32Ty, Int32Ty}, false);
  auto F = M.getOrInsertFunction(MuxBarrier, MuxFTy);
  return cast<Function>(F.getCallee());
}

static constexpr const char *MuxKernelAttrName = "mux-kernel";

void setIsKernelEntryPt(Function &F) {
  F.addFnAttr(MuxKernelAttrName, "entry-point");
}

struct InstReplacer {
  typedef std::pair<Instruction *, Instruction *> T;
  SmallVector<T> ToRemove;
  void push_back(T a) { ToRemove.push_back(a); }
  void apply() { // todo
    for (auto &El : ToRemove) {
      auto OldI = El.first;
      auto NewI = El.second;
      OldI->replaceAllUsesWith(NewI);
      OldI->eraseFromParent();
    }
  }
};

static bool replaceBarriers(Module &M, bool VSMangling) {
  // DPC++ emits
  //__spirv_ControlBarrier(__spv::Scope Execution, __spv::Scope Memory,
  //                       uint32_t Semantics) noexcept;
  // OCK expects  void __mux_work_group_barrier(i32 %id, i32 %scope, i32
  // %semantics)
  // __spv::Scope is
  // enum Flag : uint32_t {
  //   CrossDevice = 0,
  //   Device = 1,
  //   Workgroup = 2,
  //   Subgroup = 3,
  //   Invocation = 4,
  // };
  auto *SPIRVBarrierFunc =
      M.getFunction(VSMangling ? SPIRVBarrierWin : SPIRVBarrier);
  if (!SPIRVBarrierFunc) {
    // No barriers are found, just return
    return false;
  }
  static auto *MuxBarrierFunc = getMuxBarrierFunc(M);
  InstReplacer ToRemove;
  auto *Zero = ConstantInt::get(Type::getInt32Ty(M.getContext()), 0);
  for (auto &Use : SPIRVBarrierFunc->uses()) {
    auto *I = dyn_cast<CallInst>(Use.getUser());
    if (!I)
      report_fatal_error("Unsupported Value in SYCL Native CPU\n");
    SmallVector<Value *, 3> Args{Zero, I->getArgOperand(0),
                                 I->getArgOperand(2)}; // todo: check how the
                                                       // args map to each other
    auto *NewI = CallInst::Create(MuxBarrierFunc->getFunctionType(),
                                  MuxBarrierFunc, Args, "", I);
    ToRemove.push_back(std::pair(I, NewI));
  }

  ToRemove.apply();

  SPIRVBarrierFunc->eraseFromParent();

  return true;
}

llvm::SmallVector<llvm::Value *>
MakeCallArgs(const std::pair<StringRef, bt_info> &E, Module &M,
             const CallInst &CI) {
  const auto &ArgInfo = E.second;
  switch (ArgInfo.type) {
  case BT_Sig::I64_I32: { // check bt name if required
    auto *Arg =
        ConstantInt::get(Type::getInt32Ty(M.getContext()), ArgInfo.args[0]);
    return {Arg};
  }
  case BT_Sig::I32_I32_I32: {
    return {CI.getArgOperand(0), CI.getArgOperand(1)};
  }
  case BT_Sig::F64_F64_I32:
    return { CI.getArgOperand(0), CI.getArgOperand(1) };
  case BT_Sig::F64_F64_F64_I32:
    return { CI.getArgOperand(0), CI.getArgOperand(1), CI.getArgOperand(2) };
  case BT_Sig::B1_I32_B1: // todo
  case BT_Sig::I32_void:; // todo
  }
  return {};
}

} // namespace

PreservedAnalyses
ConvertToMuxBuiltinsSYCLNativeCPUPass::run(Module &M,
                                           ModuleAnalysisManager &MAM) {
  bool ModuleChanged = false;
  for (auto &F : M) {
    if (F.getCallingConv() == llvm::CallingConv::SPIR_KERNEL) {
      fixFunctionAttributes(&F);
      setIsKernelEntryPt(F);
    }
  }
  const bool VisualStudioMangling = isForVisualStudio(M.getTargetTriple());

  // Then we iterate over all the supported builtins, find their uses and
  // replace them with calls to our Native CPU functions.
  for (auto &Entry : BuiltinNamesMap) {
    auto *Glob = M.getFunction(VisualStudioMangling ? Entry.first.second
                                                    : Entry.first.first);
    if (!Glob)
      continue;
    auto *ReplaceFunc =
        getReplaceFunc(M, Entry.second.first, Entry.second.second.type);
    InstReplacer ToRemove;
    for (auto &Use : Glob->uses()) {
      auto *I = dyn_cast<CallInst>(Use.getUser());
      if (!I)
        report_fatal_error("Unsupported Value in SYCL Native CPU\n");
      const auto Args = MakeCallArgs(Entry.second, M, *I);
      auto *NewI = CallInst::Create(ReplaceFunc->getFunctionType(), ReplaceFunc,
                                    Args, "mux_call", I);
      ModuleChanged = true;
      ToRemove.push_back(std::make_pair(I, NewI));
    }

    ToRemove.apply();

    // Finally, we erase the builtin from the module
    Glob->eraseFromParent();
  }

  ModuleChanged |= replaceBarriers(M, VisualStudioMangling);
  return ModuleChanged ? PreservedAnalyses::none() : PreservedAnalyses::all();
}
