//===---- LowerInvokeSimd.h - lower invoke_simd calls ---------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
// Finds and lowers __builtin_invoke_simd calls generated by invoke_simd library
// implementation:
// - Performs data flow analysis for the first argument to determine which
//   function link-time constant address it is guaranteed to hold, and replaces
//   the argument with found "target" function.
// - Marks target functions with VCStackCall attribute as required by the Intel
//   GPU backend.
// TODO:
// - move VCStackCall markup to Intel GPU-specific part (BE) or design a new
//   target-neutral attribute for markup.
// - allow "unknown" function pointers, where actual function's address is not
//   deducible when BE is ready

#include "llvm/SYCLLowerIR/LowerInvokeSimd.h"

#include "llvm/ADT/SmallPtrSet.h"
#include "llvm/GenXIntrinsics/GenXMetadata.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Operator.h"
#include "llvm/Pass.h"

#define DEBUG_TYPE "LowerInvokeSimd"

using namespace llvm;

namespace {
class SYCLLowerInvokeSimdLegacyPass : public ModulePass {
public:
  static char ID; // Pass identification, replacement for typeid
  SYCLLowerInvokeSimdLegacyPass() : ModulePass(ID) {
    initializeSYCLLowerInvokeSimdLegacyPassPass(
        *PassRegistry::getPassRegistry());
  }

  // run the LowerESIMD pass on the specified module
  bool runOnModule(Module &M) override {
    ModuleAnalysisManager MAM;
    auto PA = Impl.run(M, MAM);
    return !PA.areAllPreserved();
  }

private:
  SYCLLowerInvokeSimdPass Impl;
};
} // namespace

char SYCLLowerInvokeSimdLegacyPass::ID = 0;
INITIALIZE_PASS(SYCLLowerInvokeSimdLegacyPass, "SYCLLowerInvokeSimd",
                "Lower SYCL's invoke_simd calls", false, false)

// Public interface to the LowerInvokeSimdPass.
ModulePass *llvm::createSYCLLowerInvokeSimdPass() {
  return new SYCLLowerInvokeSimdLegacyPass();
}

namespace {
// TODO support lambda and functor overloads
// This is the prefixes of the names generated from
// sycl/ext/oneapi/experimental/invoke_simd.hpp::__builtin_invoke_simd
// overloads instantiations:
constexpr char INVOKE_SIMD_PREF[] = "_Z33__regcall3____builtin_invoke_simd";

bool isCast(const Value *V) {
  int Opc = Operator::getOpcode(V);
  return (Opc == Instruction::BitCast) || (Opc == Instruction::AddrSpaceCast);
}

using ValueSetImpl = SmallPtrSetImpl<Value *>;
using ValueSet = SmallPtrSet<Value *, 4>;
using ConstValueSetImpl = SmallPtrSetImpl<const Value *>;
using ConstValueSet = SmallPtrSet<const Value *, 4>;

Value *stripCasts(Value *V) {
  if (!V->getType()->isPtrOrPtrVectorTy())
    return V;
  // Even though we don't look through PHI nodes, we could be called on an
  // instruction in an unreachable block, which may be on a cycle.
  ConstValueSet Visited;
  Visited.insert(V);

  do {
    if (isCast(V)) {
      V = cast<Operator>(V)->getOperand(0);
    }
    assert(V->getType()->isPtrOrPtrVectorTy() && "Unexpected operand type!");
  } while (Visited.insert(V).second);
  return V;
}

const Value *getSingleUserSkipCasts(const Value *V) {
  while (isCast(V)) {
    if (V->getNumUses() != 1) {
      return nullptr;
    }
    V = *(V->user_begin());
  }
  return V;
}

void collectUsesSkipThroughCasts(Value *V, SmallPtrSetImpl<const Use *> &Uses) {
  for (Use &U : V->uses()) {
    Value *VV = U.getUser();

    if (isCast(VV)) {
      collectUsesSkipThroughCasts(VV, Uses);
    } else {
      Uses.insert(&U);
    }
  }
}

Value *getInvokeeIfInvokeSimdCall(const CallInst *CI) {
  Function *F = CI->getCalledFunction();

  if (F && F->getName().startswith(INVOKE_SIMD_PREF)) {
    return CI->getArgOperand(0);
  }
  return nullptr;
}

void getPossibleStoredVals(Value *Addr, ValueSetImpl &Vals) {
  ValueSet Visited;
  AllocaInst *LocalVar = dyn_cast_or_null<AllocaInst>(stripCasts(Addr));

  if (!LocalVar) {
    llvm_unreachable("unsupported data flow pattern for invoke_simd 10");
  }
  SmallPtrSet<const Use *, 4> Uses;
  collectUsesSkipThroughCasts(LocalVar, Uses);

  for (const Use *U : Uses) {
    Value *V = U->getUser();

    if (auto *StI = dyn_cast<StoreInst>(V)) {
      constexpr int StoreInstValueOperandIndex = 0;

      if (U != &StI->getOperandUse(StoreInst::getPointerOperandIndex())) {
        assert(U == &StI->getOperandUse(StoreInstValueOperandIndex));
        // this is double indirection - not supported
        llvm_unreachable("unsupported data flow pattern for invoke_simd 11");
      }
      V = stripCasts(StI->getValueOperand());

      if (auto *LI = dyn_cast<LoadInst>(V)) {
        // A value loaded from another address is stored at this address -
        // recurse into the other address
        getPossibleStoredVals(LI->getPointerOperand(), Vals);
      } else {
        Vals.insert(V);
      }
      continue;
    }
    if (const auto *CI = dyn_cast<CallInst>(V)) {
      // only __builtin_invoke_simd is allowed, otherwise the pointer escapes
      if (!getInvokeeIfInvokeSimdCall(CI)) {
        llvm_unreachable("unsupported data flow pattern for invoke_simd 12");
      }
      continue;
    }
    if (const auto *LI = dyn_cast<LoadInst>(V)) {
      // LoadInst from this addr is OK, as it does not affect what can be stored
      // through the addr
      continue;
    }
    llvm_unreachable("unsupported data flow pattern for invoke_simd 13");
  }
}

// Example1 (function is direct argument to
// _Z33__regcall3____builtin_invoke_simd):
// %call6.i = call spir_func float @_Z33__regcall3____builtin_invoke_simd...(
//   <16 x float> (float addrspace(4)*, <16 x float>, i32)* %28, <== function
//   pointer float addrspace(4)* %arg1, float %arg2, i32 %arg3)
//
// Example 2 (invoke_simd's target function pointer flows through IR):
// %fptr_t = <16 x float> (float addrspace(4)*, <16 x float>, i32)*
// ...
// %fa_as0 = alloca %fptr_t
// ...
// %fa = addrspacecast %fptr_t* %fa_as0 to %fptr_t addrspace(4)*
// ...
// store %fptr_t @__SIMD_CALLEE, %fptr_t addrspace(4)* %fa
// ...
// %f = load %fptr_t, %fptr_t addrspace(4)* %fa
// ...
// %res = call spir_func float @_Z33__regcall3____builtin_invoke_simd...(
//   %fptr_t %f, <== function pointer
//  float addrspace(4)* %arg1,
//  float %arg2,
//  i32 %arg3)
//
bool processInvokeSimdCall(CallInst *CI) {
  Value *V = getInvokeeIfInvokeSimdCall(CI);

  if (!V) {
    llvm_unreachable(("bad use of " + Twine(INVOKE_SIMD_PREF)).str().c_str());
  }
  auto *SimdF = dyn_cast<Function>(V);
  bool Modified = false;

  if (!SimdF) {
    auto *LI = dyn_cast<LoadInst>(stripCasts(V));

    if (!LI) {
      llvm_unreachable("unsupported data flow pattern for invoke_simd 0");
    }
    ValueSet Vals;
    getPossibleStoredVals(LI->getPointerOperand(), Vals);

    if (Vals.size() != 1 || !(SimdF = dyn_cast<Function>(*Vals.begin()))) {
      llvm_unreachable("unsupported data flow pattern for invoke_simd 1");
    }
    // _Z33__regcall3____builtin_invoke_simd invokee is an SSA value, replace it
    // with the link-time constant SimdF as computed by getPossibleStoredVals
    auto *CI1 = cast<CallInst>(CI->clone());
    constexpr int SimdInvokeInvokeeArgIndex = 0;
    CI1->setOperand(SimdInvokeInvokeeArgIndex, SimdF);
    CI1->insertAfter(CI);
    CI->replaceAllUsesWith(CI1);
    CI->eraseFromParent();
    Modified = true;
  }
  if (!SimdF->hasFnAttribute(llvm::genx::VCFunctionMD::VCStackCall)) {
    SimdF->addFnAttr(llvm::genx::VCFunctionMD::VCStackCall);
  }
  return Modified;
}
} // namespace

namespace llvm {
PreservedAnalyses SYCLLowerInvokeSimdPass::run(Module &M,
                                               ModuleAnalysisManager &MAM) {
  bool Modified = false;

  for (Function &F : M) {
    if (!F.isDeclaration() || !F.getName().startswith(INVOKE_SIMD_PREF)) {
      continue;
    }
    SmallVector<User *, 4> Users(F.users());
    for (User *Usr : Users) {
      // a call can be the only use of the invoke_simd built-in
      CallInst *CI = cast<CallInst>(Usr);
      Modified |= processInvokeSimdCall(CI);
    }
  }
  return Modified ? PreservedAnalyses::none() : PreservedAnalyses::all();
}
} // namespace llvm
