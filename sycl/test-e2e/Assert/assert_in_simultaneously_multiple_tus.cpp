// FIXME flaky fail on CUDA and HIP
// UNSUPPORTED: cuda || hip
//
// FIXME: Remove XFAIL one intel/llvm#11364 is resolved
// XFAIL: (opencl && gpu)
//
// https://github.com/intel/llvm/issues/12797
// UNSUPPORTED: windows
//
// RUN: %{build} -DSYCL_FALLBACK_ASSERT=1 -I %S/Inputs %S/Inputs/kernels_in_file2.cpp -o %t.out %threads_lib
//
// Since this is a multi-threaded application enable memory tracking and
// deferred release feature in the Level Zero plugin to avoid releasing memory
// too early. This is necessary because currently SYCL RT sets indirect access
// flag for all kernels and the Level Zero runtime doesn't support deferred
// release yet.
// Suppress runtime from printing out error messages, so that the test can
// match on assert message generated by the toolchains.
//
// DEFINE: %{gpu_env} = env SYCL_PI_LEVEL_ZERO_TRACK_INDIRECT_ACCESS_MEMORY=1 SYCL_PI_SUPPRESS_ERROR_MESSAGE=1

// Shouldn't fail on ACC as fallback assert isn't enqueued there
// RUN: %if gpu %{ %{gpu_env} %} %{run} %t.out &> %t.txt ; FileCheck %s --input-file %t.txt %if fpga %{ --check-prefix=CHECK-ACC %}
//
// CHECK:      {{this message from file1|this message from file2}}
// CHECK-NOT:  The test ended.
//
// CHECK-ACC-NOT: {{this message from file1|this message from file2}}
// CHECK-ACC: The test ended.

#include "Inputs/kernels_in_file2.hpp"
#include <cstdio>
#include <iostream>
#include <sycl/sycl.hpp>
#include <thread>

#ifdef DEFINE_NDEBUG_INFILE1
#define NDEBUG
#else
#undef NDEBUG
#endif

#include <cassert>

using namespace sycl;
using namespace sycl::access;

static constexpr size_t NUM_THREADS = 4;
static constexpr size_t BUFFER_SIZE = 10;

template <class kernel_name> void enqueueKernel(queue *Q) {
  sycl::range<1> numOfItems{BUFFER_SIZE};
  sycl::buffer<int, 1> Buf(numOfItems);

  Q->submit([&](handler &CGH) {
    auto Acc = Buf.template get_access<mode::read_write>(CGH);

    CGH.parallel_for<kernel_name>(numOfItems, [=](sycl::id<1> wiID) {
      Acc[wiID] = 0;
      if (wiID == 5)
        assert(false && "this message from file1");
    });
  });
}

void runTestForTid(queue *Q, size_t Tid) {
  switch (Tid % 4) {
  case 0: {
    enqueueKernel<class kernel_name1>(Q);
    Q->wait();
    break;
  }
  case 1: {
    enqueueKernel<class kernel_name2>(Q);
    Q->wait();
    break;
  }
  case 2: {
    enqueueKernel_1_fromFile2(Q);
    Q->wait();
    break;
  }
  case 3: {
    enqueueKernel_2_fromFile2(Q);
    Q->wait();
    break;
  }
  }
}

int main(int Argc, const char *Argv[]) {
#ifndef __SYCL_DEVICE_ONLY__
  // On windows stderr output becomes messed up if several thread
  // output simultaneously. Hence, setting explicit line buffering here.
  if (setvbuf(stderr, nullptr, _IOLBF, BUFSIZ)) {
    std::cerr << "Can't set line-buffering mode fo stderr\n";
    return 1;
  }
#endif

  std::vector<std::thread> threadPool;
  threadPool.reserve(NUM_THREADS);

  std::vector<std::unique_ptr<queue>> Queues;
  for (size_t i = 0; i < NUM_THREADS; ++i) {
    Queues.push_back(std::make_unique<queue>());
  }

  for (size_t tid = 0; tid < NUM_THREADS; ++tid) {
    threadPool.push_back(std::thread(runTestForTid, Queues[tid].get(), tid));
  }

  for (auto &currentThread : threadPool) {
    currentThread.join();
  }

  std::cout << "The test ended." << std::endl;
  return 0;
}
