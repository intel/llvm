// NOTE: Assertions have been autogenerated by llvm/utils/update_cc_test_checks.py script, followed by some manual cleanup.
// ./llvm/utils/update_cc_test_checks.py --clang=./build/bin/clang ./sycl/test/check_device_code/vector/vector_math_ops.cpp

// RUN: %clangxx -I %sycl_include -S -emit-llvm -fno-sycl-instrument-device-code -Xclang -disable-lifetime-markers -fsycl-device-only %s -o - | FileCheck %s

// This test checks
// (1) the storage type of sycl::vec on device for all data types, and
// (2) the device code for various math operations on sycl::vec.
#include <sycl/sycl.hpp>

using namespace sycl;

using VecINT2Type = vec<int, 2>;
using VecFLOAT2Type = vec<float, 2>;
using VecCHAR2Type = vec<char, 2>;
using VecBYTE2Type = vec<std::byte, 2>;
using VecBOOL2Type = vec<bool, 2>;
using VecHALF2Type = vec<half, 2>;
using VecBF162Type = vec<ext::oneapi::bfloat16, 2>;


/*************** Binary Arithmetic Ops ******************/

// CHECK-LABEL: define dso_local spir_func void @_Z7TestAddN4sycl3_V13vecIiLi2EEES2_(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec") align 8 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec") align 8 [[A:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec") align 8 [[B:%.*]])  {{.*}} {
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x i32>, ptr [[A]], align 8,{{.*}}
// CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i32>, ptr [[B]], align 8,{{.*}}
// CHECK-NEXT:    [[ADD_I:%.*]] = add <2 x i32> [[TMP0]], [[TMP1]]
// CHECK-NEXT:    store <2 x i32> [[ADD_I]], ptr addrspace(4) [[AGG_RESULT]], align 8,{{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestAdd(VecINT2Type a, VecINT2Type b) { return a + b; }

// CHECK-LABEL: define dso_local spir_func void @_Z7TestAddN4sycl3_V13vecIfLi2EEES2_(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.0") align 8 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.0") align 8 [[A:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.0") align 8 [[B:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x float>, ptr [[A]], align 8, {{.*}}
// CHECK-NEXT:    [[TMP1:%.*]] = load <2 x float>, ptr [[B]], align 8, {{.*}}
// CHECK-NEXT:    [[ADD_I:%.*]] = fadd <2 x float> [[TMP0]], [[TMP1]]
// CHECK-NEXT:    store <2 x float> [[ADD_I]], ptr addrspace(4) [[AGG_RESULT]], align 8, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestAdd(VecFLOAT2Type a, VecFLOAT2Type b) { return a + b; }

// CHECK-LABEL: define dso_local spir_func void @_Z7TestAddN4sycl3_V13vecIcLi2EEES2_(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.1") align 2 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.1") align 2 [[A:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.1") align 2 [[B:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x i8>, ptr [[A]], align 2, {{.*}}
// CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i8>, ptr [[B]], align 2, {{.*}}
// CHECK-NEXT:    [[ADD_I:%.*]] = add <2 x i8> [[TMP0]], [[TMP1]]
// CHECK-NEXT:    store <2 x i8> [[ADD_I]], ptr addrspace(4) [[AGG_RESULT]], align 2, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestAdd(VecCHAR2Type a, VecCHAR2Type b) { return a + b; }

// CHECK-LABEL: define dso_local spir_func void @_Z7TestAddN4sycl3_V13vecISt4byteLi2EEES3_(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.2") align 2 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.2") align 2 [[A:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.2") align 2 [[B:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x i8>, ptr [[A]], align 2, {{.*}}
// CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i8>, ptr [[B]], align 2, {{.*}}
// CHECK-NEXT:    [[ADD_I:%.*]] = add <2 x i8> [[TMP0]], [[TMP1]]
// CHECK-NEXT:    store <2 x i8> [[ADD_I]], ptr addrspace(4) [[AGG_RESULT]], align 2, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestAdd(VecBYTE2Type a, VecBYTE2Type b) { return a + b; }

// CHECK-LABEL: define dso_local spir_func void @_Z7TestAddN4sycl3_V13vecIbLi2EEES2_(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.3") align 2 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.3") align 2 [[A:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.3") align 2 [[B:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x i8>, ptr [[A]], align 2, {{.*}}
// CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i8>, ptr [[B]], align 2, {{.*}}
// CHECK-NEXT:    [[ADD_I:%.*]] = add <2 x i8> [[TMP0]], [[TMP1]]
// CHECK-NEXT:    br label [[FOR_COND_I_I:%.*]]
// CHECK:       for.cond.i.i:
// CHECK-NEXT:    [[VECINS_I_I6_I_I:%.*]] = phi <2 x i8> [ [[ADD_I]], [[ENTRY:%.*]] ], [ [[VECINS_I_I_I_I:%.*]], [[FOR_BODY_I_I:%.*]] ]
// CHECK-NEXT:    [[I_0_I_I:%.*]] = phi i64 [ 0, [[ENTRY]] ], [ [[INC_I_I:%.*]], [[FOR_BODY_I_I]] ]
// CHECK-NEXT:    [[CMP_I_I:%.*]] = icmp ult i64 [[I_0_I_I]], 2
// CHECK-NEXT:    br i1 [[CMP_I_I]], label [[FOR_BODY_I_I]], label [[_ZN4SYCL3_V1PLERKNS0_3VECIBLI2EEES4__EXIT:%.*]]
// CHECK:       for.body.i.i:
// CHECK-NEXT:    [[CONV_I_I:%.*]] = trunc nuw nsw i64 [[I_0_I_I]] to i32
// CHECK-NEXT:    [[VECEXT_I_I_I_I:%.*]] = extractelement <2 x i8> [[VECINS_I_I6_I_I]], i32 [[CONV_I_I]]
// CHECK-NEXT:    [[TOBOOL_I_I_I_I:%.*]] = icmp ne i8 [[VECEXT_I_I_I_I]], 0
// CHECK-NEXT:    [[FROMBOOL_I_I:%.*]] = zext i1 [[TOBOOL_I_I_I_I]] to i8
// CHECK-NEXT:    [[VECINS_I_I_I_I]] = insertelement <2 x i8> [[VECINS_I_I6_I_I]], i8 [[FROMBOOL_I_I]], i32 [[CONV_I_I]]
// CHECK-NEXT:    [[INC_I_I]] = add nuw nsw i64 [[I_0_I_I]], 1
// CHECK-NEXT:    br label [[FOR_COND_I_I]], !llvm.loop [[LOOP29:![0-9]+]]
// CHECK:       _ZN4sycl3_V1plERKNS0_3vecIbLi2EEES4_.exit:
// CHECK-NEXT:    store <2 x i8> [[VECINS_I_I6_I_I]], ptr addrspace(4) [[AGG_RESULT]], align 2, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestAdd(VecBOOL2Type a, VecBOOL2Type b) { return a + b; }

// CHECK-LABEL: define dso_local spir_func void @_Z7TestAddN4sycl3_V13vecINS0_6detail9half_impl4halfELi2EEES5_(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.4") align 4 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.4") align 4 [[A:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.4") align 4 [[B:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x half>, ptr [[A]], align 4, {{.*}}
// CHECK-NEXT:    [[TMP1:%.*]] = load <2 x half>, ptr [[B]], align 4, {{.*}}
// CHECK-NEXT:    [[ADD_I:%.*]] = fadd <2 x half> [[TMP0]], [[TMP1]]
// CHECK-NEXT:    store <2 x half> [[ADD_I]], ptr addrspace(4) [[AGG_RESULT]], align 4, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestAdd(VecHALF2Type a, VecHALF2Type b) { return a + b; }

// CHECK-LABEL: define dso_local spir_func void @_Z7TestAddN4sycl3_V13vecINS0_3ext6oneapi8bfloat16ELi2EEES5_(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable sret(%"class.sycl::_V1::vec.5") align 4 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.5") align 4 [[A:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.5") align 4 [[B:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[REF_TMP_I_I:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[REF_TMP1_I:%.*]] = alloca %"class.sycl::_V1::ext::oneapi::bfloat16", align 2
// CHECK-NEXT:    [[REF_TMP3_I:%.*]] = alloca %"class.sycl::_V1::ext::oneapi::bfloat16", align 2
// CHECK:         [[REF_TMP1_ASCAST_I:%.*]] = addrspacecast ptr [[REF_TMP1_I]] to ptr addrspace(4)
// CHECK-NEXT:    [[REF_TMP3_ASCAST_I:%.*]] = addrspacecast ptr [[REF_TMP3_I]] to ptr addrspace(4)
// CHECK-NEXT:    [[REF_TMP_ASCAST_I_I:%.*]] = addrspacecast ptr [[REF_TMP_I_I]] to ptr addrspace(4)
// CHECK-NEXT:    [[AGG_RESULT_PROMOTED_I:%.*]] = load <2 x i16>, ptr addrspace(4) [[AGG_RESULT]], align 4, {{.*}}
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i16>, ptr [[A]], align 4, {{.*}}
// CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i16>, ptr [[B]], align 4, {{.*}}
// CHECK-NEXT:    br label [[FOR_COND_I:%.*]]
// CHECK:       for.cond.i:
// CHECK-NEXT:    [[VECINS_I_I10_I:%.*]] = phi <2 x i16> [ [[AGG_RESULT_PROMOTED_I]], [[ENTRY:%.*]] ], [ [[VECINS_I_I_I:%.*]], [[FOR_BODY_I:%.*]] ]
// CHECK-NEXT:    [[I_0_I:%.*]] = phi i64 [ 0, [[ENTRY]] ], [ [[INC_I:%.*]], [[FOR_BODY_I]] ]
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp ult i64 [[I_0_I]], 2
// CHECK-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[_ZN4SYCL3_V1PLERKNS0_3VECINS0_3EXT6ONEAPI8BFLOAT16ELI2EEES7__EXIT:%.*]]
// CHECK:       for.body.i:
// CHECK-NEXT:    [[CONV_I:%.*]] = trunc nuw nsw i64 [[I_0_I]] to i32
// CHECK:         [[VECEXT_I_I_I:%.*]] = extractelement <2 x i16> [[TMP0]], i32 [[CONV_I]]
// CHECK-NEXT:    store i16 [[VECEXT_I_I_I]], ptr [[REF_TMP1_I]], align 2, {{.*}}
// CHECK:         [[VECEXT_I_I9_I:%.*]] = extractelement <2 x i16> [[TMP1]], i32 [[CONV_I]]
// CHECK-NEXT:    store i16 [[VECEXT_I_I9_I]], ptr [[REF_TMP3_I]], align 2, {{.*}}
// CHECK:         [[CALL_I_I_I_I:%.*]] = call spir_func noundef float @__devicelib_ConvertBF16ToFINTEL(ptr addrspace(4) noundef align 2 dereferenceable(2) [[REF_TMP1_ASCAST_I]]) #[[ATTR8:[0-9]+]], {{.*}}
// CHECK-NEXT:    [[CALL_I_I2_I_I:%.*]] = call spir_func noundef float @__devicelib_ConvertBF16ToFINTEL(ptr addrspace(4) noundef align 2 dereferenceable(2) [[REF_TMP3_ASCAST_I]]) #[[ATTR8]], {{.*}}
// CHECK-NEXT:    [[ADD_I_I:%.*]] = fadd float [[CALL_I_I_I_I]], [[CALL_I_I2_I_I]]
// CHECK-NEXT:    store float [[ADD_I_I]], ptr [[REF_TMP_I_I]], align 4, {{.*}}
// CHECK-NEXT:    [[CALL_I_I3_I_I:%.*]] = call spir_func noundef zeroext i16 @__devicelib_ConvertFToBF16INTEL(ptr addrspace(4) noundef align 4 dereferenceable(4) [[REF_TMP_ASCAST_I_I]]) #[[ATTR8]], {{.*}}
// CHECK:         [[VECINS_I_I_I]] = insertelement <2 x i16> [[VECINS_I_I10_I]], i16 [[CALL_I_I3_I_I]], i32 [[CONV_I]]
// CHECK-NEXT:    [[INC_I]] = add nuw nsw i64 [[I_0_I]], 1
// CHECK-NEXT:    br label [[FOR_COND_I]], !llvm.loop [[LOOP68:![0-9]+]]
// CHECK:       _ZN4sycl3_V1plERKNS0_3vecINS0_3ext6oneapi8bfloat16ELi2EEES7_.exit:
// CHECK-NEXT:    store <2 x i16> [[VECINS_I_I10_I]], ptr addrspace(4) [[AGG_RESULT]], align 4, {{.*}}
// CHECK:         ret void
//
SYCL_EXTERNAL auto TestAdd(VecBF162Type a, VecBF162Type b) { return a + b; }

/***************** Binary Logical Ops *******************/

// CHECK-LABEL: define dso_local spir_func void @_Z15TestGreaterThanN4sycl3_V13vecIiLi2EEES2_(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec") align 8 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec") align 8 [[A:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec") align 8 [[B:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x i32>, ptr [[A]], align 8, {{.*}}
// CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i32>, ptr [[B]], align 8, {{.*}}
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp sgt <2 x i32> [[TMP0]], [[TMP1]]
// CHECK-NEXT:    [[SEXT_I:%.*]] = sext <2 x i1> [[CMP_I]] to <2 x i32>
// CHECK-NEXT:    store <2 x i32> [[SEXT_I]], ptr addrspace(4) [[AGG_RESULT]], align 8, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestGreaterThan(VecINT2Type a, VecINT2Type b) { return a > b; }

// CHECK-LABEL: define dso_local spir_func void @_Z15TestGreaterThanN4sycl3_V13vecISt4byteLi2EEES3_(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.6") align 2 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.2") align 2 [[A:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.2") align 2 [[B:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x i8>, ptr [[A]], align 2, {{.*}}
// CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i8>, ptr [[B]], align 2, {{.*}}
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp sgt <2 x i8> [[TMP0]], [[TMP1]]
// CHECK-NEXT:    [[SEXT_I:%.*]] = sext <2 x i1> [[CMP_I]] to <2 x i8>
// CHECK-NEXT:    store <2 x i8> [[SEXT_I]], ptr addrspace(4) [[AGG_RESULT]], align 2, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestGreaterThan(VecBYTE2Type a, VecBYTE2Type b) { return a > b; }

// CHECK-LABEL: define dso_local spir_func void @_Z15TestGreaterThanN4sycl3_V13vecIbLi2EEES2_(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.6") align 2 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.3") align 2 [[A:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.3") align 2 [[B:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x i8>, ptr [[A]], align 2, {{.*}}
// CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i8>, ptr [[B]], align 2, {{.*}}
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp sgt <2 x i8> [[TMP0]], [[TMP1]]
// CHECK-NEXT:    [[SEXT_I:%.*]] = sext <2 x i1> [[CMP_I]] to <2 x i8>
// CHECK-NEXT:    store <2 x i8> [[SEXT_I]], ptr addrspace(4) [[AGG_RESULT]], align 2, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestGreaterThan(VecBOOL2Type a, VecBOOL2Type b) { return a > b; }

// CHECK-LABEL: define dso_local spir_func void @_Z15TestGreaterThanN4sycl3_V13vecINS0_6detail9half_impl4halfELi2EEES5_(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.7") align 4 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.4") align 4 [[A:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.4") align 4 [[B:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x half>, ptr [[A]], align 4, {{.*}}
// CHECK-NEXT:    [[TMP1:%.*]] = load <2 x half>, ptr [[B]], align 4, {{.*}}
// CHECK-NEXT:    [[CMP_I:%.*]] = fcmp ogt <2 x half> [[TMP0]], [[TMP1]]
// CHECK-NEXT:    [[SEXT_I:%.*]] = sext <2 x i1> [[CMP_I]] to <2 x i16>
// CHECK-NEXT:    store <2 x i16> [[SEXT_I]], ptr addrspace(4) [[AGG_RESULT]], align 4, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestGreaterThan(VecHALF2Type a, VecHALF2Type b) { return a > b; }

// FIXME: We incorrectly interpret BF16 as INT16 to peform logical operation.
// For example, vec<BF16, 2>{-0.5, 3.333} < vec<BF16, 2>{6.0, 6.666} results into
// {-1, -1} on host but {0, -1} on device.

// CHECK-LABEL: define dso_local spir_func void @_Z15TestGreaterThanN4sycl3_V13vecINS0_3ext6oneapi8bfloat16ELi2EEES5_(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.7") align 4 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.5") align 4 [[A:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.5") align 4 [[B:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x i16>, ptr [[A]], align 4, {{.*}}
// CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i16>, ptr [[B]], align 4, {{.*}}
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp ugt <2 x i16> [[TMP0]], [[TMP1]]
// CHECK-NEXT:    [[SEXT_I:%.*]] = sext <2 x i1> [[CMP_I]] to <2 x i16>
// CHECK-NEXT:    store <2 x i16> [[SEXT_I]], ptr addrspace(4) [[AGG_RESULT]], align 4, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestGreaterThan(VecBF162Type a, VecBF162Type b) { return a > b; }

/********************** Unary Ops **********************/

// CHECK-LABEL: define dso_local spir_func void @_Z12TestNegationN4sycl3_V13vecIiLi2EEE(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec") align 8 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec") align 8 [[A:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[REF_TMP_I:%.*]] = alloca %"class.sycl::_V1::vec", align 8
// CHECK:         [[TMP0:%.*]] = load <2 x i32>, ptr [[A]], align 8, {{.*}}
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq <2 x i32> [[TMP0]], zeroinitializer
// CHECK-NEXT:    [[SEXT_I:%.*]] = sext <2 x i1> [[CMP_I]] to <2 x i32>
// CHECK-NEXT:    store <2 x i32> [[SEXT_I]], ptr [[REF_TMP_I]], align 8, {{.*}}
// CHECK:         br label [[FOR_COND_I_I_I:%.*]]
// CHECK:       for.cond.i.i.i:
// CHECK-NEXT:    [[I_0_I_I_I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INC_I_I_I:%.*]], [[FOR_BODY_I_I_I:%.*]] ]
// CHECK-NEXT:    [[CMP_I_I_I:%.*]] = icmp ult i64 [[I_0_I_I_I]], 8
// CHECK-NEXT:    br i1 [[CMP_I_I_I]], label [[FOR_BODY_I_I_I]], label [[_ZN4SYCL3_V1NTERKNS0_3VECIILI2EEE_EXIT:%.*]]
// CHECK:       for.body.i.i.i:
// CHECK-NEXT:    [[ARRAYIDX_I_I_I:%.*]] = getelementptr inbounds i8, ptr [[REF_TMP_I]], i64 [[I_0_I_I_I]]
// CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX_I_I_I]], align 1, {{.*}}
// CHECK-NEXT:    [[ARRAYIDX1_I_I_I:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[AGG_RESULT]], i64 [[I_0_I_I_I]]
// CHECK-NEXT:    store i8 [[TMP1]], ptr addrspace(4) [[ARRAYIDX1_I_I_I]], align 1, {{.*}}
// CHECK-NEXT:    [[INC_I_I_I]] = add nuw nsw i64 [[I_0_I_I_I]], 1
// CHECK-NEXT:    br label [[FOR_COND_I_I_I]], !llvm.loop [[LOOP97:![0-9]+]]
// CHECK:       _ZN4sycl3_V1ntERKNS0_3vecIiLi2EEE.exit:
// CHECK:         ret void
//
SYCL_EXTERNAL auto TestNegation(VecINT2Type a) { return !a; }

// CHECK-LABEL: define dso_local spir_func void @_Z9TestMinusN4sycl3_V13vecIiLi2EEE(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec") align 8 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec") align 8 [[A:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x i32>, ptr [[A]], align 8, {{.*}}
// CHECK-NEXT:    [[SUB_I:%.*]] = sub <2 x i32> zeroinitializer, [[TMP0]]
// CHECK-NEXT:    store <2 x i32> [[SUB_I]], ptr addrspace(4) [[AGG_RESULT]], align 8, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestMinus(VecINT2Type a) { return -a; }

// CHECK-LABEL: define dso_local spir_func void @_Z12TestNegationN4sycl3_V13vecISt4byteLi2EEE(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.6") align 2 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.2") align 2 [[A:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[REF_TMP_I:%.*]] = alloca %"class.sycl::_V1::vec.2", align 2
// CHECK:         [[TMP0:%.*]] = load <2 x i8>, ptr [[A]], align 2, {{.*}}
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq <2 x i8> [[TMP0]], zeroinitializer
// CHECK-NEXT:    [[SEXT_I:%.*]] = sext <2 x i1> [[CMP_I]] to <2 x i8>
// CHECK-NEXT:    store <2 x i8> [[SEXT_I]], ptr [[REF_TMP_I]], align 2, {{.*}}
// CHECK:         br label [[FOR_COND_I_I_I:%.*]]
// CHECK:       for.cond.i.i.i:
// CHECK-NEXT:    [[I_0_I_I_I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INC_I_I_I:%.*]], [[FOR_BODY_I_I_I:%.*]] ]
// CHECK-NEXT:    [[CMP_I_I_I:%.*]] = icmp ult i64 [[I_0_I_I_I]], 2
// CHECK-NEXT:    br i1 [[CMP_I_I_I]], label [[FOR_BODY_I_I_I]], label [[_ZN4SYCL3_V1NTERKNS0_3VECIST4BYTELI2EEE_EXIT:%.*]]
// CHECK:       for.body.i.i.i:
// CHECK-NEXT:    [[ARRAYIDX_I_I_I:%.*]] = getelementptr inbounds i8, ptr [[REF_TMP_I]], i64 [[I_0_I_I_I]]
// CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX_I_I_I]], align 1, {{.*}}
// CHECK-NEXT:    [[ARRAYIDX1_I_I_I:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[AGG_RESULT]], i64 [[I_0_I_I_I]]
// CHECK-NEXT:    store i8 [[TMP1]], ptr addrspace(4) [[ARRAYIDX1_I_I_I]], align 1, {{.*}}
// CHECK-NEXT:    [[INC_I_I_I]] = add nuw nsw i64 [[I_0_I_I_I]], 1
// CHECK-NEXT:    br label [[FOR_COND_I_I_I]], !llvm.loop [[LOOP97]]
// CHECK:       _ZN4sycl3_V1ntERKNS0_3vecISt4byteLi2EEE.exit:
// CHECK:         ret void
//
SYCL_EXTERNAL auto TestNegation(VecBYTE2Type a) { return !a; }

// CHECK-LABEL: define dso_local spir_func void @_Z9TestMinusN4sycl3_V13vecISt4byteLi2EEE(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.2") align 2 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.2") align 2 [[A:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x i8>, ptr [[A]], align 2, {{.*}}
// CHECK-NEXT:    [[SUB_I:%.*]] = sub <2 x i8> zeroinitializer, [[TMP0]]
// CHECK-NEXT:    store <2 x i8> [[SUB_I]], ptr addrspace(4) [[AGG_RESULT]], align 2, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestMinus(VecBYTE2Type a) { return -a; }

// CHECK-LABEL: define dso_local spir_func void @_Z12TestNegationN4sycl3_V13vecIbLi2EEE(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.6") align 2 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.3") align 2 [[A:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[REF_TMP_I:%.*]] = alloca %"class.sycl::_V1::vec.3", align 2
// CHECK:         [[TMP0:%.*]] = load <2 x i8>, ptr [[A]], align 2, {{.*}}
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq <2 x i8> [[TMP0]], zeroinitializer
// CHECK-NEXT:    [[SEXT_I:%.*]] = sext <2 x i1> [[CMP_I]] to <2 x i8>
// CHECK-NEXT:    store <2 x i8> [[SEXT_I]], ptr [[REF_TMP_I]], align 2, {{.*}}
// CHECK:         br label [[FOR_COND_I_I_I:%.*]]
// CHECK:       for.cond.i.i.i:
// CHECK-NEXT:    [[I_0_I_I_I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INC_I_I_I:%.*]], [[FOR_BODY_I_I_I:%.*]] ]
// CHECK-NEXT:    [[CMP_I_I_I:%.*]] = icmp ult i64 [[I_0_I_I_I]], 2
// CHECK-NEXT:    br i1 [[CMP_I_I_I]], label [[FOR_BODY_I_I_I]], label [[_ZN4SYCL3_V1NTERKNS0_3VECIBLI2EEE_EXIT:%.*]]
// CHECK:       for.body.i.i.i:
// CHECK-NEXT:    [[ARRAYIDX_I_I_I:%.*]] = getelementptr inbounds i8, ptr [[REF_TMP_I]], i64 [[I_0_I_I_I]]
// CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX_I_I_I]], align 1, {{.*}}
// CHECK-NEXT:    [[ARRAYIDX1_I_I_I:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[AGG_RESULT]], i64 [[I_0_I_I_I]]
// CHECK-NEXT:    store i8 [[TMP1]], ptr addrspace(4) [[ARRAYIDX1_I_I_I]], align 1, {{.*}}
// CHECK-NEXT:    [[INC_I_I_I]] = add nuw nsw i64 [[I_0_I_I_I]], 1
// CHECK-NEXT:    br label [[FOR_COND_I_I_I]], !llvm.loop [[LOOP97]]
// CHECK:       _ZN4sycl3_V1ntERKNS0_3vecIbLi2EEE.exit:
// CHECK:         ret void
//
SYCL_EXTERNAL auto TestNegation(VecBOOL2Type a) { return !a; }

// CHECK-LABEL: define dso_local spir_func void @_Z12TestNegationN4sycl3_V13vecINS0_6detail9half_impl4halfELi2EEE(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.7") align 4 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.4") align 4 [[A:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[REF_TMP_I:%.*]] = alloca %"class.sycl::_V1::vec.4", align 4
// CHECK:         [[TMP0:%.*]] = load <2 x half>, ptr [[A]], align 4, {{.*}}
// CHECK-NEXT:    [[CMP_I:%.*]] = fcmp oeq <2 x half> [[TMP0]], zeroinitializer
// CHECK-NEXT:    [[SEXT_I:%.*]] = sext <2 x i1> [[CMP_I]] to <2 x i16>
// CHECK-NEXT:    store <2 x i16> [[SEXT_I]], ptr [[REF_TMP_I]], align 4, {{.*}}
// CHECK:         br label [[FOR_COND_I_I_I:%.*]]
// CHECK:       for.cond.i.i.i:
// CHECK-NEXT:    [[I_0_I_I_I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INC_I_I_I:%.*]], [[FOR_BODY_I_I_I:%.*]] ]
// CHECK-NEXT:    [[CMP_I_I_I:%.*]] = icmp ult i64 [[I_0_I_I_I]], 4
// CHECK-NEXT:    br i1 [[CMP_I_I_I]], label [[FOR_BODY_I_I_I]], label [[_ZN4SYCL3_V1NTERKNS0_3VECINS0_6DETAIL9HALF_IMPL4HALFELI2EEE_EXIT:%.*]]
// CHECK:       for.body.i.i.i:
// CHECK-NEXT:    [[ARRAYIDX_I_I_I:%.*]] = getelementptr inbounds i8, ptr [[REF_TMP_I]], i64 [[I_0_I_I_I]]
// CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX_I_I_I]], align 1, {{.*}}
// CHECK-NEXT:    [[ARRAYIDX1_I_I_I:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[AGG_RESULT]], i64 [[I_0_I_I_I]]
// CHECK-NEXT:    store i8 [[TMP1]], ptr addrspace(4) [[ARRAYIDX1_I_I_I]], align 1, {{.*}}
// CHECK-NEXT:    [[INC_I_I_I]] = add nuw nsw i64 [[I_0_I_I_I]], 1
// CHECK-NEXT:    br label [[FOR_COND_I_I_I]], !llvm.loop [[LOOP97]]
// CHECK:       _ZN4sycl3_V1ntERKNS0_3vecINS0_6detail9half_impl4halfELi2EEE.exit:
// CHECK:         ret void
//
SYCL_EXTERNAL auto TestNegation(VecHALF2Type a) { return !a; }

// CHECK-LABEL: define dso_local spir_func void @_Z9TestMinusN4sycl3_V13vecINS0_6detail9half_impl4halfELi2EEE(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.4") align 4 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.4") align 4 [[A:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK:         [[TMP0:%.*]] = load <2 x half>, ptr [[A]], align 4, {{.*}}
// CHECK-NEXT:    [[FNEG_I:%.*]] = fneg <2 x half> [[TMP0]]
// CHECK-NEXT:    store <2 x half> [[FNEG_I]], ptr addrspace(4) [[AGG_RESULT]], align 4, {{.*}}
// CHECK-NEXT:    ret void
//
SYCL_EXTERNAL auto TestMinus(VecHALF2Type a) { return -a; }

// CHECK-LABEL: define dso_local spir_func void @_Z12TestNegationN4sycl3_V13vecINS0_3ext6oneapi8bfloat16ELi2EEE(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.7") align 4 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.5") align 4 [[A:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RET_I:%.*]] = alloca %"class.sycl::_V1::vec.5", align 4
// CHECK-NEXT:    [[REF_TMP1_I:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[REF_TMP2_I:%.*]] = alloca %"class.sycl::_V1::ext::oneapi::bfloat16", align 2
// CHECK:         [[REF_TMP1_ASCAST_I:%.*]] = addrspacecast ptr [[REF_TMP1_I]] to ptr addrspace(4)
// CHECK-NEXT:    [[REF_TMP2_ASCAST_I:%.*]] = addrspacecast ptr [[REF_TMP2_I]] to ptr addrspace(4)
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i16>, ptr [[A]], align 4, {{.*}}
// CHECK-NEXT:    br label [[FOR_COND_I:%.*]]
// CHECK:       for.cond.i:
// CHECK-NEXT:    [[TMP1:%.*]] = phi <2 x i16> [ zeroinitializer, [[ENTRY:%.*]] ], [ [[VECINS_I_I_I:%.*]], [[FOR_BODY_I:%.*]] ]
// CHECK-NEXT:    [[I_0_I:%.*]] = phi i64 [ 0, [[ENTRY]] ], [ [[INC_I:%.*]], [[FOR_BODY_I]] ]
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp ult i64 [[I_0_I]], 2
// CHECK-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[FOR_END_I:%.*]]
// CHECK:       for.body.i:
// CHECK-NEXT:    [[CONV_I:%.*]] = trunc nuw nsw i64 [[I_0_I]] to i32
// CHECK-NEXT:    [[VECEXT_I_I_I:%.*]] = extractelement <2 x i16> [[TMP0]], i32 [[CONV_I]]
// CHECK-NEXT:    store i16 [[VECEXT_I_I_I]], ptr [[REF_TMP2_I]], align 2, {{.*}}
// CHECK-NEXT:    [[CALL_I_I_I:%.*]] = call spir_func noundef float @__devicelib_ConvertBF16ToFINTEL(ptr addrspace(4) noundef align 2 dereferenceable(2) [[REF_TMP2_ASCAST_I]]) #[[ATTR8]], {{.*}}
// CHECK-NEXT:    [[CMP_I_I:%.*]] = fcmp oeq float [[CALL_I_I_I]], 0.000000e+00
// CHECK-NEXT:    [[CONV4_I:%.*]] = uitofp i1 [[CMP_I_I]] to float
// CHECK-NEXT:    store float [[CONV4_I]], ptr [[REF_TMP1_I]], align 4, {{.*}}
// CHECK-NEXT:    [[CALL_I_I9_I:%.*]] = call spir_func noundef zeroext i16 @__devicelib_ConvertFToBF16INTEL(ptr addrspace(4) noundef align 4 dereferenceable(4) [[REF_TMP1_ASCAST_I]]) #[[ATTR8]], {{.*}}
// CHECK-NEXT:    [[VECINS_I_I_I]] = insertelement <2 x i16> [[TMP1]], i16 [[CALL_I_I9_I]], i32 [[CONV_I]]
// CHECK-NEXT:    [[INC_I]] = add nuw nsw i64 [[I_0_I]], 1
// CHECK-NEXT:    br label [[FOR_COND_I]], !llvm.loop [[LOOP148:![0-9]+]]
// CHECK:       for.end.i:
// CHECK-NEXT:    store <2 x i16> [[TMP1]], ptr [[RET_I]], align 1, {{.*}}
// CHECK:         br label [[FOR_COND_I_I_I:%.*]]
// CHECK:       for.cond.i.i.i:
// CHECK-NEXT:    [[I_0_I_I_I:%.*]] = phi i64 [ 0, [[FOR_END_I]] ], [ [[INC_I_I_I:%.*]], [[FOR_BODY_I_I_I:%.*]] ]
// CHECK-NEXT:    [[CMP_I_I_I:%.*]] = icmp ult i64 [[I_0_I_I_I]], 4
// CHECK-NEXT:    br i1 [[CMP_I_I_I]], label [[FOR_BODY_I_I_I]], label [[_ZN4SYCL3_V1NTERKNS0_3VECINS0_3EXT6ONEAPI8BFLOAT16ELI2EEE_EXIT:%.*]]
// CHECK:       for.body.i.i.i:
// CHECK-NEXT:    [[ARRAYIDX_I_I_I:%.*]] = getelementptr inbounds i8, ptr [[RET_I]], i64 [[I_0_I_I_I]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr [[ARRAYIDX_I_I_I]], align 1, {{.*}}
// CHECK-NEXT:    [[ARRAYIDX1_I_I_I:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[AGG_RESULT]], i64 [[I_0_I_I_I]]
// CHECK-NEXT:    store i8 [[TMP2]], ptr addrspace(4) [[ARRAYIDX1_I_I_I]], align 1, {{.*}}
// CHECK-NEXT:    [[INC_I_I_I]] = add nuw nsw i64 [[I_0_I_I_I]], 1
// CHECK-NEXT:    br label [[FOR_COND_I_I_I]], !llvm.loop [[LOOP97]]
// CHECK:       _ZN4sycl3_V1ntERKNS0_3vecINS0_3ext6oneapi8bfloat16ELi2EEE.exit:
// CHECK:         ret void
//
SYCL_EXTERNAL auto TestNegation(VecBF162Type a) { return !a; }

// CHECK-LABEL: define dso_local spir_func void @_Z9TestMinusN4sycl3_V13vecINS0_3ext6oneapi8bfloat16ELi2EEE(
// CHECK-SAME: ptr addrspace(4) dead_on_unwind noalias nocapture writable writeonly sret(%"class.sycl::_V1::vec.5") align 4 [[AGG_RESULT:%.*]], ptr nocapture noundef readonly byval(%"class.sycl::_V1::vec.5") align 4 [[A:%.*]]) {{.*}}{
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[REF_TMP_I_I:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[V_I:%.*]] = alloca %"class.sycl::_V1::ext::oneapi::bfloat16", align 2
// CHECK:         [[V_ASCAST_I:%.*]] = addrspacecast ptr [[V_I]] to ptr addrspace(4)
// CHECK-NEXT:    store i32 0, ptr addrspace(4) [[AGG_RESULT]], align 4, {{.*}}
// CHECK-NEXT:    [[REF_TMP_ASCAST_I_I:%.*]] = addrspacecast ptr [[REF_TMP_I_I]] to ptr addrspace(4)
// CHECK-NEXT:    br label [[FOR_COND_I:%.*]]
// CHECK:       for.cond.i:
// CHECK-NEXT:    [[I_0_I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_COND_I]] ]
// CHECK-NEXT:    [[CMP_I:%.*]] = icmp ult i64 [[I_0_I]], 2
// CHECK-NEXT:    call void @llvm.assume(i1 [[CMP_I]])
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds <2 x i16>, ptr [[A]], i64 0, i64 [[I_0_I]]
// CHECK-NEXT:    [[VECEXT_I:%.*]] = load i16, ptr [[TMP0]], align 2, {{.*}}
// CHECK-NEXT:    store i16 [[VECEXT_I]], ptr [[V_I]], align 2, {{.*}}
// CHECK:         [[CALL_I_I:%.*]] = call spir_func float @__devicelib_ConvertBF16ToFINTEL(ptr addrspace(4) noundef align 2 dereferenceable(2) [[V_ASCAST_I]]) #[[ATTR8]], {{.*}}
// CHECK-NEXT:    [[FNEG_I_I:%.*]] = fneg float [[CALL_I_I]]
// CHECK-NEXT:    store float [[FNEG_I_I]], ptr [[REF_TMP_I_I]], align 4, {{.*}}
// CHECK-NEXT:    [[CALL_I_I_I_I:%.*]] = call spir_func noundef zeroext i16 @__devicelib_ConvertFToBF16INTEL(ptr addrspace(4) noundef align 4 dereferenceable(4) [[REF_TMP_ASCAST_I_I]]) #[[ATTR8]], {{.*}}
// CHECK:         [[TMP1:%.*]] = getelementptr inbounds <2 x i16>, ptr addrspace(4) [[AGG_RESULT]], i64 0, i64 [[I_0_I]]
// CHECK-NEXT:    store i16 [[CALL_I_I_I_I]], ptr addrspace(4) [[TMP1]], align 2, {{.*}}
// CHECK-NEXT:    [[INC_I]] = add nuw nsw i64 [[I_0_I]], 1
// CHECK-NEXT:    br label [[FOR_COND_I]], !llvm.loop [[LOOP165:![0-9]+]]
//
SYCL_EXTERNAL auto TestMinus(VecBF162Type a) { return -a; }
