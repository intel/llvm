//==----------------------- kernel_desc.hpp --------------------------------==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===////

#pragma once

#include <CL/sycl/access/access.hpp>
#include <CL/sycl/detail/os_util.hpp> // for DLL_LOCAL used in int. header

namespace cl {
namespace sycl {
namespace detail {

namespace half_impl {

class half;
// Half type is defined as _Float16 on device and as manually implemented half
// type on host. Integration header is generated by device compiler so it sees
// half type as _Float16 and it will add _Float16 to integration header if it
// is used in kernel name template parameters. To avoid errors in host
// compilation we remove _Float16 from integration header using following macro.
// Same thing goes about bool type which is defined as _Bool.
#ifndef __SYCL_DEVICE_ONLY__
#define _Float16 cl::sycl::detail::half_impl::half
#define _Bool bool
#endif

} // namespace half_impl

// kernel parameter kinds
enum class kernel_param_kind_t {
  kind_accessor,
  kind_std_layout, // standard layout object parameters
  kind_sampler,
  kind_pointer
};

// describes a kernel parameter
struct kernel_param_desc_t {
  // parameter kind
  kernel_param_kind_t kind;
  // kind == kind_std_layout
  //   parameter size in bytes (includes padding for structs)
  // kind == kind_accessor
  //   access target; possible access targets are defined in access/access.hpp
  int info;
  // offset of the captured value of the parameter in the lambda or function
  // object
  int offset;
};

#ifndef __SYCL_UNNAMED_LAMBDA__
template <class KernelNameType> struct KernelInfo {
  static constexpr unsigned getNumParams() { return 0; }
  static const kernel_param_desc_t &getParamDesc(int Idx) {
    static kernel_param_desc_t Dummy;
    return Dummy;
  }
  static constexpr const char *getName() { return ""; }
};
#else
template <char...> struct KernelInfoData; // Should this have dummy impl?

// C++14 like index_sequence and make_index_sequence
// not needed C++14 members (value_type, size) not implemented
template <class T, T...> struct integer_sequence {};
template <size_t... I> using index_sequence = integer_sequence<size_t, I...>;
template <size_t N>
using make_index_sequence = __make_integer_seq<integer_sequence, size_t, N>;

template <typename T> struct KernelInfoImpl {
private:
  static constexpr auto n = __unique_stable_name(T);
  template <size_t... I>
  static KernelInfoData<n[I]...> impl(index_sequence<I...>) {
    return {};
  }

public:
  using type = decltype(impl(make_index_sequence<__builtin_strlen(n)>{}));
};
template <typename T> using KernelInfo = typename KernelInfoImpl<T>::type;
#endif //__SYCL_UNNAMED_LAMBDA__

} // namespace detail
} // namespace sycl
} // namespace cl
