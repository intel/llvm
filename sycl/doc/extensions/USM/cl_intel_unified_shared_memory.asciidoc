= cl_intel_unified_shared_memory

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C,
// for syntax highlighting purposes.
:language: c

// This is what is needed for C++, since docbook uses c++
// and everything else uses cpp.  This doesn't work when
// source blocks are in table cells, though, so don't use
// C++ unless it is required.
//:language: {basebackend@docbook:c++:cpp}

[float]
== XXX - Not complete yet!!!

== Name Strings

`cl_intel_unified_shared_memory`

== Contact

Ben Ashbaugh, Intel (ben 'dot' ashbaugh 'at' intel 'dot' com)

== Contributors

// spell-checker: disable
Ben Ashbaugh, Intel +
James Brodman, Intel +
Michael Kinsner, Intel +
Michal Mrozek, Intel +
Lukasz Towarek, Intel +
TODO: many more...
// spell-checker: enable

== Notice

Copyright (c) 2019 Intel Corporation.  All rights reserved.

== Status

Working Draft

This is a preview extension specification, intended to provide early access to a feature for review and community feedback.
When the feature matures, this specification may be released as a formal extension.

Because the interfaces defined by this specification are not final and are subject to change they are not intended to be used by shipping software products.
If you are interested in using this feature in your software product, please let us know!

== Version

Built On: {docdate} +
Revision: E

== Dependencies

This extension is written against the OpenCL API Specification Version 2.2, Revision v2.2-8.

== Overview

This extension adds "Unified Shared Memory" (USM) to OpenCL.
Unified Shared Memory provides:

* Easier integration into existing code bases by representing OpenCL allocations as pointers rather than handles (`cl_mems`), with full support for pointer arithmetic into allocations.
* Fine-grain control over ownership and accessibility of OpenCL allocations, to optimally choose between performance and programmer convenience.
* A simpler programming model, by automatically migrating some allocations between OpenCL devices and the host.

== New API Functions

[source]
----
void*   clHostMemAllocINTEL(
            cl_context context,
            const cl_mem_properties_intel* properties,
            size_t size,
            cl_uint alignment,
            cl_int* errcode_ret);

void*   clDeviceMemAllocINTEL(
            cl_context context,
            cl_device_id device,
            const cl_mem_properties_intel* properties,
            size_t size,
            cl_uint alignment,
            cl_int* errcode_ret);

void*   clSharedMemAllocINTEL(
            cl_context context,
            cl_device_id device,
            const cl_mem_properties_intel* properties,
            size_t size,
            cl_uint alignment,
            cl_int* errcode_ret);

cl_int  clMemFreeINTEL(
            cl_context context,
            const void* ptr);

cl_int  clGetMemAllocInfoINTEL(
            cl_context context,
            const void* ptr,
            cl_mem_info_intel param_name,
            size_t param_value_size,
            void* param_value,
            size_t* param_value_size_ret);

cl_int  clSetKernelArgMemPointerINTEL(
            cl_kernel kernel,
            cl_uint arg_index,
            const void* arg_value);

// TBD: Memset API vs. "fill" API.  Is this sufficient?
cl_int  clEnqueueMemsetINTEL(
            cl_command_queue command_queue,
            void* dst_ptr,
            cl_int value,
            size_t size,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);

cl_int  clEnqueueMemcpyINTEL(
            cl_command_queue command_queue,
            cl_bool blocking,
            void* dst_ptr,
            const void* src_ptr,
            size_t size,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);

cl_int  clEnqueueMigrateMemINTEL(
            cl_command_queue command_queue,
            const void* ptr,
            size_t size,
            cl_mem_migration_flags flags,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);

cl_int  clEnqueueMemAdviseINTEL(
            cl_command_queue command_queue,
            const void* ptr,
            size_t size,
            cl_mem_advice_intel advice,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);
----

== New API Enums

Accepted value for the _param_name_ parameter to *clGetDeviceInfo* to query the Unified Shared Memory capabilities of an OpenCL device:

[source]
----
#define CL_DEVICE_HOST_MEM_CAPABILITIES_INTEL                   0x4190
#define CL_DEVICE_DEVICE_MEM_CAPABILITIES_INTEL                 0x4191
#define CL_DEVICE_SINGLE_DEVICE_SHARED_MEM_CAPABILITIES_INTEL   0x4192
#define CL_DEVICE_CROSS_DEVICE_SHARED_MEM_CAPABILITIES_INTEL    0x4193
#define CL_DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES_INTEL          0x4194
----

Bitfield type and bits describing the Unified Shared Memory capabilities of an OpenCL device:

[source]
----
typedef cl_bitfield cl_unified_shared_memory_capabilities_intel;

#define CL_UNIFIED_SHARED_MEMORY_ACCESS_INTEL                   (1 << 0)
#define CL_UNIFIED_SHARED_MEMORY_ATOMIC_ACCESS_INTEL            (1 << 1)
#define CL_UNIFIED_SHARED_MEMORY_CONCURRENT_ACCESS_INTEL        (1 << 2)
#define CL_UNIFIED_SHARED_MEMORY_CONCURRENT_ATOMIC_ACCESS_INTEL (1 << 3)
----

Type to describe optional Unified Shared Memory allocation properties:

[source]
----
typedef cl_bitfield cl_mem_properties_intel;
----

Enumerant value requesting optional allocation properties for a Unified Shared Memory allocation:

[source]
----
#define CL_MEM_ALLOC_FLAGS_INTEL        0x4195
----

Bitfield type and bits describing optional allocation properties for a Unified Shared Memory allocation:

[source]
----
typedef cl_bitfield cl_mem_alloc_flags_intel;

#define CL_MEM_ALLOC_DEFAULT_INTEL                      0
#define CL_MEM_ALLOC_WRITE_COMBINED_INTEL               (1 << 0)
----

Enumeration type and values for the _param_name_ parameter to *clGetMemAllocInfoINTEL* to query information about a Unified Shared Memory allocation.
Optional allocation properties may also be queried using *clGetMemAllocInfoINTEL*:

[source]
----
typedef cl_uint cl_mem_info_intel;

#define CL_MEM_ALLOC_TYPE_INTEL         0x419A
#define CL_MEM_ALLOC_BASE_PTR_INTEL     0x419B
#define CL_MEM_ALLOC_SIZE_INTEL         0x419C
#define CL_MEM_ALLOC_INFO_TBD0_INTEL    0x419D  /* reserved for future */
#define CL_MEM_ALLOC_INFO_TBD1_INTEL    0x419E  /* reserved for future */
#define CL_MEM_ALLOC_INFO_TBD2_INTEL    0x419F  /* reserved for future */
----

Enumeration type and values describing the type of Unified Shared Memory allocation.  Returned by *clGetMemAllocInfoINTEL* when _param_name_ is `CL_MEM_ALLOC_TYPE_INTEL`:

[source]
----
typedef cl_uint cl_unified_shared_memory_type_intel;

#define CL_MEM_TYPE_UNKNOWN_INTEL       0x4196
#define CL_MEM_TYPE_HOST_INTEL          0x4197
#define CL_MEM_TYPE_DEVICE_INTEL        0x4198
#define CL_MEM_TYPE_SHARED_INTEL        0x4199
----

Enumeration type and values for the _advice_ parameter to *clEnqueueMemAdviseINTEL* to provide memory advice for a Unified Shared Memory allocation:

[source]
----
typedef cl_uint cl_mem_advice_intel;

#define CL_MEM_ADVICE_TBD0_INTEL        0x4208  /* reserved for future */
#define CL_MEM_ADVICE_TBD1_INTEL        0x4209  /* reserved for future */
#define CL_MEM_ADVICE_TBD2_INTEL        0x420A  /* reserved for future */
#define CL_MEM_ADVICE_TBD3_INTEL        0x420B  /* reserved for future */
#define CL_MEM_ADVICE_TBD4_INTEL        0x420C  /* reserved for future */
#define CL_MEM_ADVICE_TBD5_INTEL        0x420D  /* reserved for future */
#define CL_MEM_ADVICE_TBD6_INTEL        0x420E  /* reserved for future */
#define CL_MEM_ADVICE_TBD7_INTEL        0x420F  /* reserved for future */
----

Accepted value for the _param_name_ parameter to *clSetKernelExecInfo* to specify that the kernel may indirectly access Unified Shared Memory allocations of the specified type:

[source]
----
#define CL_KERNEL_EXEC_INFO_INDIRECT_HOST_ACCESS_INTEL      0x4200
#define CL_KERNEL_EXEC_INFO_INDIRECT_DEVICE_ACCESS_INTEL    0x4201
#define CL_KERNEL_EXEC_INFO_INDIRECT_SHARED_ACCESS_INTEL    0x4202
----

Accepted value for the _param_name_ paramter to *clSetKernelExecInfo* to specify a set of Unified Shared Memory allocations that the kernel may indirectly access:

[source]
----
#define CL_KERNEL_EXEC_INFO_USM_PTRS_INTEL                  0x4203
----

New return values from *clGetEventInfo* when _param_name_ is `CL_EVENT_COMMAND_TYPE`:

[source]
----
#define CL_COMMAND_MEMSET_INTEL         0x4204
#define CL_COMMAND_MEMCPY_INTEL         0x4205
#define CL_COMMAND_MIGRATEMEM_INTEL     0x4206
#define CL_COMMAND_MEMADVISE_INTEL      0x4207
----

== Modifications to the OpenCL API Specification

=== Section 3.2 - Querying Devices:

Add to Table 5 - OpenCL Device Queries:

[caption="Table 5. "]
.OpenCL Device Queries
[width="100%",cols="<30%,<20%,<50%",options="header"]
|====
| *cl_device_info* | Return Type | Description
| `CL_DEVICE_HOST_{zwsp}MEM_CAPABILITIES_INTEL` +
  {blank}
  `CL_DEVICE_DEVICE_{zwsp}MEM_CAPABILITIES_INTEL` +
  {blank}
  `CL_DEVICE_SINGLE_DEVICE_SHARED_{zwsp}MEM_CAPABILITIES_INTEL` +
  {blank}
  `CL_DEVICE_CROSS_DEVICE_SHARED_{zwsp}MEM_CAPABILITIES_INTEL` +
  {blank}
  `CL_DEVICE_SHARED_SYSTEM_{zwsp}MEM_CAPABILITIES_INTEL`
  | `cl_unified_shared_memory_capabilities_intel`
      | Describes the ability for a device to access Unified Shared Memory allocations of the specified type.
      
        The host memory access capabilities apply to any host allocation.
        
        The device memory access capabilities apply to any device allocation associated with this device.
        
        The single device shared memory access capabilities apply to any shared allocation associated with this device.
        
        The cross-device shared memory access capabilities apply to any shared allocation associated with this device, or to any shared memory allocation on another device that also supports the same cross-device shared memory access capability.

        The shared system memory access capabilities apply to any allocations made by a system allocator, such as `malloc` or `new`.
        
        The access capabilities are encoded as bits in a bitfield.
        Supported capabilities are:
        
        `CL_UNIFIED_SHARED_MEMORY_ACCESS_INTEL`:
        The device may access (read or write) Unified Shared Memory allocations of this type.
        
        `CL_UNIFIED_SHARED_MEMORY_ATOMIC_ACCESS_INTEL`:
        The device may perform atomic operations on Unified Shared Memory allocations of this type.
        
        `CL_UNIFIED_SHARED_MEMORY_CONCURRENT_ACCESS_INTEL`:
        The device supports concurrent access to Unified Shared Memory allocations of this type.
        Concurrent access may be from the host, or from other OpenCL devices, where applicable.
        
        `CL_UNIFIED_SHARED_MEMORY_CONCURRENT_ATOMIC_ACCESS_INTEL`:
        The device supports concurrent atomic access to Unified Shared Memory allocations of this type.
|====

=== New Section 4.X - Unified Shared Memory

This section describes _Unified Shared Memory_, abbreviated _USM_.
Unified Shared Memory allocations are represented as pointers in the host application, rather than as handles (specifically, `cl_mems`).
Unified Shared Memory additionally provides fine-grain control over placement and accessibility of an allocation, allowing many tradeoffs between programmer convenience and performance.

Three types of Unified Shared Memory allocations are supported.
The type describes the _ownership_ of the allocation:

. **Host** allocations are owned by the host and are intended to be allocated out of system memory.
Host allocations are accessible by the host and one or more devices.
The same pointer to a host allocation may be used on the host and all supported devices; they have _address equivalence_.
Host allocations are not expected to migrate between system memory and device local memory.
Host allocations trade off wide accessibility and transfer benefits for potentially higher per-access costs, such as over PCI express.

. **Device** allocations are owned by a specific device and are intended to be allocated out of device local memory, if present.
Device allocations generally trade off access limitations for higher performance.
With very few exceptions, device allocations may only be accessed by the specific device they are allocated on, or copied to a host or another device allocation.
The same pointer to a device allocation may be used on any supported device.

. **Shared** allocations share ownership and are intended to migrate between the host and one or more devices.
Shared allocations are accessible by at least the host and an associated device.
Shared allocations may be accessed by other devices in some cases.
Shared allocations trade off transfer costs for per-access benefits.
The same pointer to a shared allocation may be used on the host and all supported devices.

A **Shared System** allocation is a sub-class of a **Shared** allocation, where the memory is allocated by a _system allocator_ - such as `malloc` or `new` - rather than by a USM allocation API.
Shared system allocations have no associated device - they are inherently cross-device.
Like other shared allocations, shared system allocations are intended to migrate between the host and supported devices, and the same pointer to a shared system allocation may be used on the host and all supported devices.

.Summary of Unified Shared Memory Capabilities
[width="100%",options="header"]
|====
| Name | Initial Location 2+| Accessible By 2+| Migratable To

.2+| **Host** .2+| Host
| Host | Yes | Host | N/A
| Any Device | Yes (perhaps over PCIe) | Device | No

.3+| **Device** .3+| Specific Device
| Host | No | Host | No
| Specific Device | Yes | Device | N/A
| Another Device | Optional | Another Device | No

.3+| **Shared** .3+| Host, or Specific Device, Or Unspecified
| Host | Yes | Host | Yes
| Specific Device | Yes | Device | Yes
| Another Device | Optional | Another Device | Optional

.2+| **Shared System** .2+| Host
| Host | Yes | Host | Yes
| Device | Yes | Device | Yes

|====

OpenCL devices may support different capabilities for each type of Unified Shared Memory allocation.
Supported capabilities are:

* `CL_UNIFIED_SHARED_MEMORY_ACCESS_INTEL`:
The device may access (read or write) Unified Shared Memory allocations of this type.

* `CL_UNIFIED_SHARED_MEMORY_ATOMIC_ACCESS_INTEL`:
The device may perform atomic operations on Unified Shared Memory allocations of this type.

* `CL_UNIFIED_SHARED_MEMORY_CONCURRENT_ACCESS_INTEL`:
The device supports concurrent access to Unified Shared Memory allocations of this type.
Concurrent access may be from the host, or from other OpenCL devices, where applicable.

* `CL_UNIFIED_SHARED_MEMORY_CONCURRENT_ATOMIC_ACCESS_INTEL`:
The device supports concurrent atomic access to Unified Shared Memory allocations of this type.

Some devices may _oversubscribe_ some shared allocations.
When and how such oversubscription occurs, including which allocations are evicted when the working set changes, are considered implementation details.

The minimum set of capabilities are:

.Minimum Unified Shared Memory Capabilities
[width="100%",cols="^h,^,^,^,^",options="header"]
|====
| Allocation Type | Access | Atomic Access | Concurrent Access | Concurrent Atomic Access
| Host | Optional | Optional | Optional | Optional
| Device | Required | Optional | Optional | Optional
| Shared | Optional | Optional | Optional | Optional
| Shared (Cross-Device) | Optional | Optional | Optional | Optional
| Shared System (Cross-Device) | Optional | Optional | Optional | Optional
|====

==== Allocating and Freeing Unified Shared Memory

===== Host Allocations

The function

[source]
----
void*   clHostMemAllocINTEL(
            cl_context context,
            const cl_mem_properties_intel* properties,
            size_t size,
            cl_uint alignment,
            cl_int* errcode_ret);
----

allocates host Unified Shared Memory.

_context_ is a valid OpenCL context used to allocate the host memory.

_properties_ is an optional list of allocation properties and their corresponding values.
The list is terminated with the special property `0`.
If no allocation properties are required, _properties_ may be `NULL`.
Please refer to the <<cl_mem_properties_intel,table below>> for valid property values and their description.

_size_ is the size in bytes of the requested host allocation.

_alignment_ is the minimum alignment in bytes for the requested host allocation.
It must be a power of two up to the largest data type supported by any OpenCL device in _context_.
If _alignment_ is `0`, a default alignment will be used that is equal to the size of largest data type supported by any OpenCL device in _context_.

_errcode_ret_ may return an appropriate error code.
If _errcode_ret_ is `NULL` then no error code will be returned.

*clHostMemAllocINTEL* will return a valid non-`NULL` address and `CL_SUCCESS` will be returned in _errcode_ret_ if the host Unified Shared Memory is allocated successfully.
Otherwise, `NULL` will be returned, and _errcode_ret_ will be set to one of the following error values:

* TODO

===== Device Allocations

The function

[source]
----
void*   clDeviceMemAllocINTEL(
            cl_context context,
            cl_device_id device,
            const cl_mem_properties_intel* properties,
            size_t size,
            cl_uint alignment,
            cl_int* errcode_ret);
----

allocates Unified Shared Memory specific to an OpenCL device.

_context_ is a valid OpenCL context used to allocate the device memory.

_device_ is a valid OpenCL device ID to associate with the allocation.

_properties_ is an optional list of allocation properties and their corresponding values.
The list is terminated with the special property `0`.
If no allocation properties are required, _properties_ may be `NULL`.
Please refer to the <<cl_mem_properties_intel,table below>> for valid property values and their description.

_size_ is the size in bytes of the requested device allocation.

_alignment_ is the minimum alignment in bytes for the requested device allocation.
It must be a power of two up to the largest data type supported by _device_.
If _alignment_ is `0`, a default alignment will be used that is equal to the size of largest data type supported by _device_.

_errcode_ret_ may return an appropriate error code.
If _errcode_ret_ is `NULL` then no error code will be returned.

*clDeviceMemAllocINTEL* will return a valid non-`NULL` address and `CL_SUCCESS` will be returned in _errcode_ret_ if the device Unified Shared Memory is allocated successfully.
Otherwise, `NULL` will be returned, and _errcode_ret_ will be set to one of the following error values:

* TODO

===== Shared Allocations

The function

[source]
----
void*   clSharedMemAllocINTEL(
            cl_context context,
            cl_device_id device,
            const cl_mem_properties_intel* properties,
            size_t size,
            cl_uint alignment,
            cl_int* errcode_ret);
----

allocates Unified Shared Memory with shared ownership between the host and the specified OpenCL device.
If the specified OpenCL device supports cross-device access capabilities, the allocation is also accessible to other OpenCL devices in the context that have the same cross-device access capabilities.

_context_ is a valid OpenCL context used to allocate the Unified Shared Memory.

_device_ is a valid OpenCL device ID to associate with the allocation.

_properties_ is an optional list of allocation properties and their corresponding values.
The list is terminated with the special property `0`.
If no allocation properties are required, _properties_ may be `NULL`.
Please refer to the <<cl_mem_properties_intel,table below>> for valid property values and their description.

_size_ is the size in bytes of the requested shared allocation.

_alignment_ is the minimum alignment in bytes for the requested shared allocation.
It must be a power of two up to the largest data type supported by _device_.
If _alignment_ is `0`, a default alignment will be used that is equal to the size of largest data type supported by _device_.

_errcode_ret_ may return an appropriate error code.
If _errcode_ret_ is `NULL` then no error code will be returned.

*clSharedMemAllocINTEL* will return a valid non-`NULL` address and `CL_SUCCESS` will be returned in _errcode_ret_ if the shared Unified Shared Memory is allocated successfully.
Otherwise, `NULL` will be returned, and _errcode_ret_ will be set to one of the following error values:

* TODO

===== Freeing Allocations

The function

[source]
----
cl_int  clMemFreeINTEL(
            cl_context context,
            const void* ptr); // TBD: const?
----

frees a Unified Shared Memory allocation.

_context_ is a valid OpenCL context used to free the Unified Shared Memory allocation.

_ptr_ is the Unified Shared Memory allocation to free.
It must be a value returned by *clHostMemAllocINTEL*, *clDeviceMemAllocINTEL*, or *clSharedMemAllocINTEL*, or a `NULL` pointer.
If _ptr_ is `NULL` then no action occurs.

Note that *clMemFreeINTEL* does not wait for previously enqueued commands that may be using _ptr_ to finish before freeing _ptr_.
It is the responsibility of the application to make sure enqueued commands that use _ptr_ are complete before freeing _ptr_.

*clMemFreeINTEL* will return `CL_SUCCESS` if the function executes successfully.
Otherwise, it will return one of the following error values:

* TODO

===== Controlling Allocations

The table below describes allocation properties that may be passed to control allocation behavior.

[[cl_mem_properties_intel]]
.List of Supported `cl_mem_properties_intel` Properties
[width="100%",cols="1,1,2",options="header"]
|====
| Property
| Property Type
| Description

| `CL_MEM_ALLOC_FLAGS_INTEL`
  | cl_mem_alloc_flags_intel
    | Flags specifying allocation and usage information.
      This is a bitfield type that may be set to any combination of the following values:
      
      `CL_MEM_ALLOC_DEFAULT_INTEL`:
      Use the default allocation behavior.

      `CL_MEM_ALLOC_WRITE_COMBINED_INTEL`:
      Request write combined (WC) memory.
      Write combined memory may improve performance in some cases, however write combined memory must be used with care since it may hurt performance in other cases or use different coherency protocols than non-write combined memory.

|====

==== Unified Shared Memory Queries

The function

[source]
----
cl_int  clGetMemAllocInfoINTEL(
            cl_context context,
            const void* ptr,
            cl_mem_info_intel param_name,
            size_t param_value_size,
            void* param_value,
            size_t* param_value_size_ret);
----

queries information about a Unified Shared Memory allocation.

_context_ is a valid OpenCL context to query for information about the Unified Shared Memory allocation.

_ptr_ is a pointer into a Unified Shared Memory allocation to query.
_ptr_ need not be a value returned by *clHostMemAllocINTEL*, *clDeviceMemAllocINTEL*, or *clSharedMemAllocINTEL*, but the query may be faster if it is.
TBD: What if _ptr_ is `NULL` or is not a pointer into a Unified Shared Memory allocation?

_param_name_ specifies the information to query.
The list of supported _param_name_ values and the information returned in _param_value_ is described in the <<cl_mem_info_intel,Unified Memory Allocation Queries>> table.

_param_value_ is a pointer to memory where the appropriate result being queried is returned.
If _param_value_ is `NULL`, it is ignored.

_param_value_size_ is used to specify the size in bytes of memory pointed to by _param_value_.
This size must be greater than or equal to the size of return type as described in the <<cl_mem_info_intel,Unified Memory Allocation Queries>> table.
If _param_value_ is `NULL`, it is ignored.

_param_value_size_ret_ returns the actual size in bytes of data being queried by _param_name_.
If _param_value_size_ret_ is `NULL`, it is ignored.

*clGetMemAllocInfoINTEL* returns `CL_SUCCESS` if the function is executed successfully.
Otherwise, it will return one of the following error values:

* TODO

[[cl_mem_info_intel]]
.List of supported param_names by clGetMemAllocInfoINTEL
[width="100%",cols="<34%,<33%,<33%",options="header"]
|====
| *cl_mem_info_intel* | Return type | Info. returned in _param_value_
| `CL_MEM_ALLOC_TYPE_INTEL`
  | cl_unified_shared_memory_type_intel
      | Returns the type of the Unified Shared Memory allocation.
        
        Returns `CL_MEM_TYPE_HOST_INTEL` for allocations made by *clHostMemAllocINTEL* .
        Returns `CL_MEM_TYPE_DEVICE_INTEL` for allocations made by *clDeviceMemAllocINTEL*.
        Returns `CL_MEM_TYPE_SHARED_INTEL` for allocations made by *clSharedMemAllocINTEL*.
        Returns `CL_MEM_TYPE_UNKNOWN_INTEL` if the type of the Unified Shared Memory allocation cannot be determined, or if _ptr_ does not point into a Unified Shared Memory Allocation.
| `CL_MEM_ALLOC_FLAGS_INTEL`
  | cl_mem_alloc_flags_intel
      | Returns allocation flags for the Unified Shared Memory allocation.
| `CL_MEM_ALLOC_BASE_PTR_INTEL`
  | void*
      | Returns the base address of the Unified Shared Memory allocation.
| `CL_MEM_ALLOC_SIZE_INTEL`
  | size_t
      | Returns the size in bytes of the Unified Shared Memory allocation.

|====

==== Using Unified Shared Memory with Kernels

The function

[source]
----
cl_int  clSetKernelArgMemPointerINTEL(
            cl_kernel kernel,
            cl_uint arg_index,
            const void* arg_value);
----

is used to set a pointer into a Unified Shared Memory allocation as an argument to a kernel.

_kernel_ is a valid kernel object.

_arg_index_ is the argument index to set.
Arguments to the kernel are referred to by indices that go from 0 for the leftmost argument to _n_ - 1, where _n_ is the total number of arguments declared by a kernel.

_arg_value_ is the pointer value that should be used as the argument specified by _arg_index_.
The pointer value will be used as the argument by all API calls that enqueue a kernel until the argument value is set to a different pointer value by a subsequent call.
A pointer into Unified Shared Memory allocation may only be set as an argument value for an argument declared to be a pointer to `global` or `constant` memory.
The pointer need not be a value returned by *clHostMemAllocINTEL*, *clDeviceMemAllocINTEL*, or *clSharedMemAllocINTEL*.

*clSetKernelArgMemPointerINTEL* returns `CL_SUCCESS` if the function is executed successfully.
Otherwise, it will return one of the following errors:

* TODO

In addition to direct use of a Unified Shared Memory allocation as a kernel argument, Unified Shared Memory allocations may be accessed by kernels indirectly.
The new _param_name_ values described below may be used with the existing *clSetKernelExecInfo* function to describes how Unified Shared Memory allocations are accessed indirectly by a kernel:

[caption="Table 28. "]
.List of supported param_names by clSetKernelExecInfo
[width="100%",cols="<34%,<33%,<33%",options="header"]
|====
| *cl_kernel_exec_info* | Type | Description
| `CL_KERNEL_EXEC_INFO_{zwsp}USM_PTRS_INTEL`
  | void*[]
      | Specifies an explicit set of Unified Shared Memory allocations accessed indirectly by the kernel.
        The new set replaces any previously specified set of Unified Shared Memory allocations.

        Initially, the set of Unified Shared Memory allocations accessed indirectly by the kernel is the empty set.
| `CL_KERNEL_EXEC_INFO_{zwsp}INDIRECT_HOST_ACCESS_INTEL`
  | cl_bool
      | Specifies that the kernel may access any host Unified Shared Memory allocation indirectly.

        By default, the value for this flag is `CL_FALSE`, indicating that the kernel will only access explicitly specified host Unified Shared Memory allocations.
| `CL_KERNEL_EXEC_INFO_{zwsp}INDIRECT_DEVICE_ACCESS_INTEL`
  | cl_bool
      | Specifies that the kernel may access any device Unified Shared Memory allocation indirectly.

        By default, the value for this flag is `CL_FALSE`, indicating that the kernel will only access explicitly specified device Unified Shared Memory allocations.
| `CL_KERNEL_EXEC_INFO_{zwsp}SHARED_DEVICE_ACCESS_INTEL`
  | cl_bool
      | Specifies that the kernel may access any shared Unified Shared Memory allocation indirectly.

        By default, the value for this flag is `CL_FALSE`, indicating that the kernel will only access explicitly specified clSharedMemAllocINTEL Unified Shared Memory allocations.

|====

==== Setting and Copying Unified Shared Memory

The function

[source]
----
// TBD: Memset API vs. "fill" API.  Is this sufficient?
cl_int  clEnqueueMemsetINTEL(
            cl_command_queue command_queue,
            void* dst_ptr,
            cl_int value,
            size_t size,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);
----

sets a region of a memory to the specified value.

_command_queue_ is a valid host command queue.
The memory set command will be queued for execution on the device associated with _command_queue_.

_dst_ptr_ is a pointer to the start of the memory region to set.
The Unified Shared Memory allocation pointed to by _dst_ptr_ must be valid for the context associated with _command_queue_, and must be accessible by the device associated with _command_queue_.

_value_ is the value to set in the Unified Shared Memory region.
It is interpreted as an 8-bit value and the upper 24-bits are ignored.

_size_ describes the size of the memory region to set, in bytes.

_event_wait_list_ and _num_events_in_wait_list_ specify events that need to complete before this command can be executed.
If _event_wait_list_ is `NULL`, then this command does not wait on any event to complete.
If _event_wait_list_ is `NULL`, _num_events_in_wait_list_ must be 0.
If _event_wait_list_ is not `NULL`, the list of events pointed to by _event_wait_list_ must be valid and _num_events_in_wait_list_ must be greater than 0.
The events specified in _event_wait_list_ act as synchronization points.
The context associated with events in _event_wait_list_ and _command_queue_ must be the same.
The memory associated with _event_wait_list_ can be reused or freed after the function returns.

_event_ returns a unique event object that identifies this command.
If _event_ is `NULL`, no event will be created and therefore it will not be possible to query or wait for this command.
If the _event_wait_list_ and the _event_ arguments are not `NULL`, the _event_ argument must not refer to an element of the _event_wait_list_ array.

*clEnqueueMemsetINTEL* returns CL_SUCCESS if the command is queued successfully.
Otherwise, it will return one of the following errors:

* TODO

The function

[source]
----
cl_int  clEnqueueMemcpyINTEL(
            cl_command_queue command_queue,
            cl_bool blocking,
            void* dst_ptr,
            const void* src_ptr,
            size_t size,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);
----

copies a region of memory from one location to another.

_command_queue_ is a valid host command queue.
The memory copy command will be queued for execution on the device associated with _command_queue_.

_blocking_ indicates if the copy operation is blocking or non-blocking.
If _blocking_ is `CL_TRUE`, the copy command is blocking, and the function will not return until the copy command is complete.
Otherwise, if _blocking_ is `CL_FALSE`, the copy command is non-blocking, and the contents of the _dst_ptr_ cannot be used nor can the contents of the _src_ptr_ be overwritten until the copy command is complete.

_dst_ptr_ is a pointer to the start of the memory region to copy to.
If _dst_ptr_ is a pointer into a Unified Shared Memory allocation it must be valid for the context associated with _command_queue_.

_src_ptr_ is a pointer to the start of the memory region to copy from.
If _src_ptr_ is a pointer into a Unified Shared Memory allocation it must be valid for the context associated with _command_queue_.

_size_ describes the size of the memory region to copy, in bytes.

_event_wait_list_ and _num_events_in_wait_list_ specify events that need to complete before this command can be executed.
If _event_wait_list_ is `NULL`, then this command does not wait on any event to complete.
If _event_wait_list_ is `NULL`, _num_events_in_wait_list_ must be 0.
If _event_wait_list_ is not `NULL`, the list of events pointed to by _event_wait_list_ must be valid and _num_events_in_wait_list_ must be greater than 0.
The events specified in _event_wait_list_ act as synchronization points.
The context associated with events in _event_wait_list_ and _command_queue_ must be the same.
The memory associated with _event_wait_list_ can be reused or freed after the function returns.

_event_ returns a unique event object that identifies this command.
If _event_ is `NULL`, no event will be created and therefore it will not be possible to query or wait for this command.
If the _event_wait_list_ and the _event_ arguments are not `NULL`, the _event_ argument must not refer to an element of the _event_wait_list_ array.

*clEnqueueMemcpyINTEL* returns CL_SUCCESS if the command is queued successfully.
Otherwise, it will return one of the following errors:

* TODO

==== Unified Shared Memory Hints

The function

[source]
----
cl_int  clEnqueueMigrateMemINTEL(
            cl_command_queue command_queue,
            const void* ptr,
            size_t size,
            cl_mem_migration_flags flags,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);
----

explicitly migrates a region of a shared Unified Shared Memory allocation to the device associated with _command_queue_.
This is a hint that may improve performance and is not required for correctness.
Memory migration may not be supported for all allocation types for all devices.
If memory migration is not supported for the specified memory range then the migration hint may be ignored.
Memory migration may only be supported at a device-specific granularity, such as a page boundary.
In this case, the memory range may be expanded such that the start and end of the range satisfy the granularity requirements.

_command_queue_ is a valid host command queue.
The memory migration command will be queued for execution on the device associated with _command_queue_.

_ptr_ is a pointer to the start of the shared Unified Shared Memory allocation to migrate.

_size_ describes the size of the memory region to migrate.

_flags_ is a bit-field that is used to specify memory migration options.

_event_wait_list_ and _num_events_in_wait_list_ specify events that need to complete before this command can be executed.
If _event_wait_list_ is `NULL`, then this command does not wait on any event to complete.
If _event_wait_list_ is `NULL`, _num_events_in_wait_list_ must be 0.
If _event_wait_list_ is not `NULL`, the list of events pointed to by _event_wait_list_ must be valid and _num_events_in_wait_list_ must be greater than 0.
The events specified in _event_wait_list_ act as synchronization points.
The context associated with events in _event_wait_list_ and _command_queue_ must be the same.
The memory associated with _event_wait_list_ can be reused or freed after the function returns.

_event_ returns a unique event object that identifies this command.
If _event_ is `NULL`, no event will be created and therefore it will not be possible to query or wait for this command.
If the _event_wait_list_ and the _event_ arguments are not `NULL`, the _event_ argument must not refer to an element of the _event_wait_list_ array.

*clEnqueueMigrateMemINTEL* returns CL_SUCCESS if the command is queued successfully.
Otherwise, it will return one of the following errors:

* TODO

The function

[source]
----
cl_int  clEnqueueMemAdviseINTEL(
            cl_command_queue command_queue,
            const void* ptr,
            size_t size,
            cl_mem_advice_intel advice,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);
----

provides advice about a region of a shared Unified Shared Memory allocation.
Memory advice is a performance hint only and is not required for correctness.
Providing memory advice hints may override driver heuristics that control shared memory behavior.
Not all memory advice hints may be supported for all allocation types for all devices.
If a memory advice hint is not supported by the device it will be ignored.
Memory advice hints may only be supported at a device-specific granularity, such as at a page boundary.
In this case, the memory range may be expanded such that the start and end of the range satisfy the granularity requirements.

_command_queue_ is a valid host command queue.
The memory advice hints will be queued for the device associated with _command_queue_.

_ptr_ is a pointer to the start of the shared Unified Shared Memory allocation.

_size_ describes the size of the memory region.

_advice_ is a bit-field describing the memory advice hints for the region.

_event_wait_list_ and _num_events_in_wait_list_ specify events that need to complete before this command can be executed.
If _event_wait_list_ is `NULL`, then this command does not wait on any event to complete.
If _event_wait_list_ is `NULL`, _num_events_in_wait_list_ must be 0.
If _event_wait_list_ is not `NULL`, the list of events pointed to by _event_wait_list_ must be valid and _num_events_in_wait_list_ must be greater than 0.
The events specified in _event_wait_list_ act as synchronization points.
The context associated with events in _event_wait_list_ and _command_queue_ must be the same.
The memory associated with _event_wait_list_ can be reused or freed after the function returns.

_event_ returns a unique event object that identifies this command.
If _event_ is `NULL`, no event will be created and therefore it will not be possible to query or wait for this command.
If the _event_wait_list_ and the _event_ arguments are not `NULL`, the _event_ argument must not refer to an element of the _event_wait_list_ array.

*clEnqueueMemAdviseINTEL* returns CL_SUCCESS if the command is queued successfully.
Otherwise, it will return one of the following errors:

* TODO

== Issues

. Is there a minimum supported granularity for concurrent access?  For example, might it be possible to concurrently access different pages of an allocation, but not different bytes within the same page?
+
--
*UNRESOLVED*:
--

. What other Unified Shared Memory allocation properties should we support?
+
--
*UNRESOLVED*:
The proposed Unified Shared Memory allocation APIs accept `cl_mem_alloc_flags_intel`.
We could also accept (some? all?) `cl_mem_flags`, for example.
--

. Do we need separate "concurrent access" capabilities for host access vs. device access?
+
--
*UNRESOLVED*:
We don't differentiate right now, but we could differentiate between concurrent host access vs. concurrent access from another device.
--

. What would we need to add to support system allocations?
+
--
`RESOLVED`:
Added `CL_DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES_INTEL`.
--

. Do we need the ability to "register" or "use" an existing host allocations?
+
--
*UNRESOLVED*:
Currently, only the ability to "allocate" host memory is supported.
If we did support this then there may be alignment and size granularity requirements for "registering" a host allocation.
--

. Do we want to support both a _flags_ argument and a _properties_ argument to the USM allocation APIs?
+
--
`RESOLVED`:
The _flags_ argument was folded into the _properties_ in revision C.
--

. What should behavior be for `clGetMemAllocInfoINTEL` if the passed-in _ptr_ is `NULL` or doesn't point into a USM allocation?
+
--
*UNRESOLVED*:
This could be an error, either `CL_INVALID_MEM_OBJECT` or some new error code.
This could be valid when querying for `CL_MEM_ALLOC_TYPE_INTEL` (returning `CL_MEM_TYPE_UNKNOWN_INTEL`), but an error for other queries.
We could spec behavior for all queries, meaning this is not an error. 
--

. Do we want separate "memset" APIs to set to different sized "value", such as 8-bits, 16-bits?, 32-bits, or others?  Do we want to go back to a "fill" API?
+
--
*UNRESOLVED*:
The CPU "memset" only sets to an 8-bit value.
Switching back to a "fill" API is very flexible, but perhaps overkill, since it supports any supported integer or floating-point scalar or vector type.
--

. What are the restrictions for the _dst_ptr_ values that can be passed to the "memset" API?
+
--
*UNRESOLVED*:
Need to close on:

* Can a device "memset" another device's allocation?  (Recommendation: No.)
* Can a device "memset" arbitrary host memory?  (Recommendation: Maybe?)
* Can a device "memset" a USM allocation from another context?  (Recommendation: No?)
--

. What are the restrictions for the _src_ptr_ and _dst_ptr_ values that can be passed to the "memcpy" API?
+
--
*UNRESOLVED*:
Need to close on:

* Can a device "memcpy" from another device's allocation?
* Can a device "memcpy" to another device's allocation?
* Can a device "memcpy" to or from a USM allocation in another context?  (Recommendation: No?)
* Can a device "memcpy" to arbitrary host memory?  (Recommendation: Yes.)
* Can a device "memcpy" from arbitrary host memory?  (Recommendation: Yes.)
* Can a device "memcpy" from arbitrary host memory to arbitrary host memory?  (Recommendation: Yes.)
* Can the memory region to copy to overlap the memory region to copy from?  (Recommendation: No?)
--

. Do we want to support migrating to devices other than the device associated with _command_queue_?
+
--
*UNRESOLVED*:
We could add an explicit _dst_device_ argument if desired, which could be `NULL` when migrating to the device associated with the _command_queue_.
We could also add a mechanism to allow migrating to the host.
--

. Should *clEnqueueMigrateMemINTEL* support migrating an array of pointers with one API call, similar to *clEnqueueSVMMigrateMem*?
+
--
*UNRESOLVED*:
This depends how frequently the migrate APIs are called.
--

. Could the _device_ argument to *clSharedMemAllocINTEL* be `NULL` if there is no need to associate the shared allocation to a specific device?
+
--
*UNRESOLVED*:
--

. Should we allow querying the associated device for a USM allocation using *clGetMemAllocInfoINTEL*?
+
--
*UNRESOLVED*:
If we added this we'd need to specify what happens for host allocations or shared allocations with no associated device.
--

== TODO

//. Title
//+
//--
//`RESOLVED`: Description
//--

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|A|2019-01-18|Ben Ashbaugh|*Initial revision*
|B|2019-03-25|Ben Ashbaugh|Minor name changes.
|C|2019-06-18|Ben Ashbaugh|Moved flags argument into properties.
|D|2019-07-19|Ben Ashbaugh|Editorial fixes.
|E|2019-07-22|Ben Ashbaugh|Allocation properties should be const.
|========================================

//************************************************************************
//Other formatting suggestions:
//
//* Use *bold* text for host APIs, or [source] syntax highlighting.
//* Use `mono` text for device APIs, or [source] syntax highlighting.
//* Use `mono` text for extension names, types, or enum values.
//* Use _italics_ for parameters.
//************************************************************************
