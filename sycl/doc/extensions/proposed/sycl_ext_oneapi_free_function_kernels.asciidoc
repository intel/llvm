= sycl_ext_oneapi_free_function_kernels

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]
:endnote: &#8212;{nbsp}end{nbsp}note

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2023-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.
OpenCL(TM) is a trademark of Apple Inc. used by permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 8 specification.
All references below to the "core SYCL specification" or to section numbers in
the SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:../proposed/sycl_ext_oneapi_free_function_queries.asciidoc[
  sycl_ext_oneapi_free_function_queries]


== Status

This is a proposed extension specification, intended to gather community
feedback.
Interfaces defined in this specification may not be implemented yet or may be
in a preliminary state.
The specification itself may also change in incompatible ways before it is
finalized.
*Shipping software products should not rely on APIs defined in this
specification.*


== Overview

This extension introduces a new way to define a kernel as a simple C++
function, where the kernel arguments are parameters to the function.
This is different from standard SYCL kernels, where the kernel arguments are
either captures of a lambda expression or member variables of a callable
object.

The primary motivation for this extension is the
link:../proposed/sycl_ext_oneapi_kernel_compiler.asciidoc[
sycl_ext_oneapi_kernel_compiler], which allows online compilation of a kernel
from source code.
These kernels must have a clean separation between host and device code, and
they must have a defined order to their arguments because the application sets
the argument values by their "index" via `handler::set_arg(index, value)`.
Because variables captured by lambda expressions have no defined order, we need
some other way to define kernel arguments for use with the
sycl_ext_oneapi_kernel_compiler extension, and the
sycl_ext_oneapi_free_function_kernels extension provides that mechanism.
The "free function kernel" feature is a separate extension, though, because it
can also be used independently from sycl_ext_oneapi_kernel_compiler.
For example, some users may find it more familiar to define kernels as plain
functions or they might have other reasons to prefer a clean separation between
host and device code.


== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.
An implementation supporting this extension must predefine the macro
`SYCL_EXT_ONEAPI_FREE_FUNCTION_KERNELS`
to one of the values defined in the table below.
Applications can test for the existence of this macro to determine if the
implementation supports this feature, or applications can test the macro's
value to determine which of the extension's features the implementation
supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===

=== Defining a free function kernel

A free function kernel is a normal C++ function definition, where the function
declaration is decorated with one of the following macros:
`SYCL_EXT_ONEAPI_RANGE_KERNEL`, `SYCL_EXT_ONEAPI_ND_RANGE_KERNEL`, or
`SYCL_EXT_ONEAPI_SINGLE_TASK_KERNEL`.

When a function declaration is decorated with one of these macros, the
following rules must be observed:

* The function must be declared at either namespace scope or at class scope as
  a static member function.

* The position of the macro decoration must be the same as the position allowed
  for C++ attribute decorations on the function declaration.
  For example:
+
```
SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
void iota(float start, float *ptr);
```

* The macro decoration must appear on the first declaration of the function
  in the translation unit.
  Redeclarations of the function may optionally be decorated with the same
  macro if the macro arguments are the same.
  The effect is the same regardless of whether redeclaration are so decorated.

* The same function may be decorated with at most one of these macros.
  However, the same function may be decorated multiple times with the same
  macro (with the same arguments).
  Programs that decorate the same function with more than one of these macros
  or with multiple instances of the same macro with different arguments are ill
  formed.

* If a function is decorated with one of these macros in one translation unit,
  that function must also be decorated with the same macro (with the same
  arguments) in all other translation units.

The following table provides additional details about these macros:

|====
a|
[frame=all,grid=none]
!====
a!
[source]
----
#define SYCL_EXT_ONEAPI_RANGE_KERNEL(Dims) /*unspecified*/
----
!====

Indicates that the function is a free function kernel that is invoked with a
simple `range` iteration space of `Dims` dimensions.
The `Dims` parameter must be an integral constant expression that specifies a
valid number of dimensions for the `range` class.

a|
[frame=all,grid=none]
!====
a!
[source]
----
#define SYCL_EXT_ONEAPI_ND_RANGE_KERNEL(Dims) /*unspecified*/
----
!====

Indicates that the function is a free function kernel that is invoked with an
`nd_range` iteration space of `Dims` dimensions.
The `Dims` parameter must be an integral constant expression that specifies a
valid number of dimensions for the `nd_range` class.

a|
[frame=all,grid=none]
!====
a!
[source]
----
#define SYCL_EXT_ONEAPI_SINGLE_TASK_KERNEL /*unspecified */
----
!====

Indicates that the function is a free function kernel that is invoked via
`single_task` (i.e. without any iteration space).
|====

When a function is defined as a free function kernel, each parameter to the
function is a kernel argument, which must abide by the rules for allowable
kernel parameter types specified in section 4.12.4 "Rules for parameter passing
to kernels" of the core SYCL specification.
The function's return type must be `void`.

The following example demonstrates how a free function kernel using a
3-dimensional nd-range iteration space can be defined:

```
SYCL_EXT_ONEAPI_ND_RANGE_KERNEL(3)
void iota(float start, float *ptr) {
   // ...
}
```

A function decorated with one of these macros can still be called from host
code.
The macro has no effect in such cases.

=== New kernel bundle member functions

This extension adds the following new functions which add kernel bundle support
for free function kernels:

|====
a|
[frame=all,grid=none]
!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

template <auto *Func>
kernel_id get_kernel_id();

} // namespace sycl::ext::oneapi::experimental
----
!====

_Preconditions_: The address `Func` must be the address of some free function
kernel that is defined in the calling application.

[_Note:_ The function `Func` need not be defined in the same translation unit
as the call to `get_kernel_id`.
_{endnote}_]

_Returns:_ The kernel identifier that is associated with that kernel.

!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

template <auto *Func, bundle_state State>                                // (1)
kernel_bundle<State> get_kernel_bundle(const context& ctxt);

template <auto *Func, bundle_state State>                                // (2)
kernel_bundle<State> get_kernel_bundle(const context& ctxt,
                                       const std::vector<device>& devs);

} // namespace sycl::ext::oneapi::experimental
----
!====

_Preconditions_: The address `Func` must be the address of some free function
kernel that is defined in the calling application.

_Returns: (1)_ The same value as
`get_kernel_bundle<State>(ctxt, ctxt.get_devices(), {get_kernel_id<Func>()})`.

_Returns: (2)_ The same value as
`get_kernel_bundle<State>(ctxt, devs, {get_kernel_id<Func>()})`.

!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

template <auto *Func, bundle_state State>                                     // (1)
bool has_kernel_bundle(const context& ctxt);

template <auto *Func, bundle_state State>                                     // (2)
bool has_kernel_bundle(const context& ctxt, const std::vector<device>& devs);

} // namespace sycl::ext::oneapi::experimental
----
!====

_Preconditions_: The address `Func` must be the address of some free function
kernel that is defined in the calling application.

_Returns: (1)_ The same value as
`has_kernel_bundle<State>(ctxt, {get_kernel_id<Func>()})`.

_Returns: (2)_ The same value as
`has_kernel_bundle<State>(ctxt, devs, {get_kernel_id<Func>()})`.

!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

template <auto *Func> bool is_compatible(const device& dev);

} // namespace sycl::ext::oneapi::experimental
----
!====

_Preconditions_: The address `Func` must be the address of some free function
kernel that is defined in the calling application.

_Returns:_ The same value as
`is_compatible<State>({get_kernel_id<Func>()}, dev)`.

|====

This extension also adds the following new member functions to the
`kernel_bundle` class:

```
namespace sycl {

template <bundle_state State>
class kernel_bundle {
  // ...

  template<auto *Func>
  bool ext_oneapi_has_kernel();

  template<auto *Func>
  bool ext_oneapi_has_kernel(const device &dev);

  template<auto *Func>
  kernel ext_oneapi_get_kernel();
};

} // namespace sycl
```

|====
a|
[frame=all,grid=none]
!====
a!
[source]
----
template<auto *Func>                           // (1)
bool ext_oneapi_has_kernel()

template<auto *Func>                           // (2)
bool ext_oneapi_has_kernel(const device &dev)
----
!====

_Preconditions_: The address `Func` must be the address of some free function
kernel that is defined in the calling application.

_Returns: (1)_: The value `true` only if the kernel bundle contains the free
function kernel whose address is `Func`.

_Returns: (2)_: The value `true` only if the kernel bundle contains the free
function kernel whose address is `Func` and if that kernel is compatible with
the device `dev`.

!====
a!
[source]
----
template<auto *Func>
kernel ext_oneapi_get_kernel()
----
!====

_Constraints:_ This function is available only when `State` is
`bundle_state::executable`.

_Preconditions_: The address `Func` must be the address of some free function
kernel that is defined in the calling application.

_Returns:_ If the kernel whose address is `Func` resides in this kernel bundle,
returns the `kernel` object representing that kernel.

_Throws_: An `exception` with the error code `errc::invalid` if the kernel with
address `Func` does not reside in this kernel bundle.
|====

=== Behavior with kernel bundle functions in the core SYCL specification

Free function kernels that are defined by the application have a corresponding
kernel identifier (`kernel_id`) and are contained by the device images in the
SYCL application.
This section defines the ramifications this has on the kernel bundle functions
defined by the core SYCL specification.

* The function `get_kernel_ids()` returns the kernel identifiers for any free
  function kernels defined by the application, in addition to identifiers for
  any kernels defined as lambda expressions or named kernel objects.

* The kernel bundle returned by
  `get_kernel_bundle(const context&, const std::vector<device>& devs)` contains
  all of the free function kernels defined by the application that are
  compatible with at least one of the devices in `devs`, in addition to all of
  the kernels defined as lambda expressions or named kernel objects that are
  compatible with one of these devices.

* The function `has_kernel_bundle(const context&, const std::vector<device>&)`
  considers free function kernels defined by the application when computing its
  return value.

The information descriptor `info::kernel::num_args` may be used to query a
`kernel` object that represents a free function kernel.
The return value tells the number of formal parameters in the function's
definition.

=== Enqueuing a free function kernel and setting parameter values

Once the application obtains a `kernel` object for a free function kernel, it
can enqueue the kernel to a device using any of the SYCL functions that allow
a kernel to be enqueued via a `kernel` object.
The application must enqueue the free function kernel according to its type.
For example, a free function kernel defined via `SYCL_EXT_ONEAPI_RANGE_KERNEL`
can be enqueued by calling the `handler::parallel_for` overload taking a
`range`.
A free function kernel defined via `SYCL_EXT_ONEAPI_ND_RANGE_KERNEL` can be
enqueued by calling the `handler::parallel_for` overload taking an `nd_range`.
A free function kernel defined via `SYCL_EXT_ONEAPI_SINGLE_TASK_KERNEL` can be
enqueued by calling `handler::single_task`.

Attempting to enqueue a free function kernel using a mechanism that does not
match its type results in undefined behavior.
Attempting to enqueue a free function kernel with a `range` or `nd_range` whose
dimensionality does not match the free function kernel definition results in
undefined behavior.

The application is also responsible for setting the values of any kernel
arguments when the kernel is enqueued.
For example, when enqueuing a kernel with `handler::parallel_for` or
`handler::single_task`, the kernel argument values must be set via
`handler::set_arg` or `handler::set_args`.
Failing to set the value of a kernel argument results in undefined behavior.
The type of the value passed to `handler::set_arg` or `handler::set_args` must
be the same as the type of the corresponding formal parameter in the free
function kernel.
Passing a value with a mismatched type results in undefined behavior.

=== Obtaining the iteration id for a kernel

In a standard SYCL kernel, the iteration ID is passed as a parameter to the
kernel's callable object.
However, this is not the case for a free function kernel because the function
parameters are used to pass the kernel arguments instead.
Therefore, a free function kernel must obtain the iteration ID in some other
way.
Typically, a free function kernel uses the functions specified in
link:../proposed/sycl_ext_oneapi_free_function_queries.asciidoc[
sycl_ext_oneapi_free_function_queries] for this purpose.

=== Address space of kernel arguments

The arguments to a free function kernel are in the private address space.
As a result, a kernel can modify its arguments, but the modification is visible
only within the work-item.

[_Note:_ This applies only to the arguments themselves, not to memory that the
arguments point to.
For example, with a USM pointer argument, the pointer argument itself is in the
private address space, but the memory it points to is in the global address
space.
_{endnote}_]

=== Interaction with kernel properties

If the implementation supports
link:../experimental/sycl_ext_oneapi_kernel_properties.asciidoc[
sycl_ext_oneapi_kernel_properties], a free function kernel may be decorated
with these properties by applying the properties to the function declaration as
illustrated below.

```
SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::work_group_size<32>)
void iota(float start, float *ptr) {
   // ...
}
```

The `SYCL_EXT_ONEAPI_FUNCTION_PROPERTY` decorations may appear either before or
after the macro decorations that identify the function as a free function
kernel.

As with standard SYCL kernels, these properties can be queried via
`kernel::get_info` using either the `info::kernel::attributes` information
descriptor or the `info::kernel_device_specific` information descriptors.

=== Restrictions for integration header implementations

[_Note:_ The {dpcpp} implementation of this extension currently has the
restrictions listed in this section.
In the future, restrictions tied to the integration header approach might be
formalized in the core SYCL specification and tied to a macro, similar to the
feature set macros that exist already.
_{endnote}_]

Implementations of SYCL that use the integration header technique have
additional restrictions for functions that are declared as free function
kernels.
These implementations automatically insert forward declarations of the free
function kernels at the top of the translation unit.
This has ramifications on how the application may declare the free function
kernels, on the types that may be used in those declarations, and on the way
the application may reference these kernel identifiers.
The following example illustrates the forward declarations that the
implementation inserts:

```
// Forward declarations of types used by the kernel functions.
struct mystruct;
enum myenum : int;

// Each kernel is forward declared in the same namespace in which the
// application declares it.
SYCL_EXT_ONEAPI_RANGE_KERNEL(1) void kernel1(int *);
SYCL_EXT_ONEAPI_RANGE_KERNEL(1) void kernel2(mystruct, myenum);

template<typename T>
SYCL_EXT_ONEAPI_RANGE_KERNEL(1) void kernel3(T *);

namespace ns {
SYCL_EXT_ONEAPI_RANGE_KERNEL(1) void kernel4(int *);
}
```

As a result, these implementations impose additional restrictions for functions
that are declared as free function kernels:

* The function must be declared at namespace scope.

* Any type used in the declaration of a parameter must be one of the allowed
  types listed below.

* If the function is instantiated from a template, any type used to instantiate
  the template must be one of the allowed types listed below.

* Uses of function identifiers in the application must assume that the free
  function kernels are forward declared at the top of the translation unit.
  Note that this can also affect references to functions that are not declared
  as free functions kernels as illustrated below.
+
```
void foo(int) {/*...*/}

void caller() {
  auto *pf = foo;  // This is ambiguous because foo(float) is forward declared
                   // in the integration header
}

SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
void foo(float) {/*...*/}
```

The allowed types are:

* A {cpp} fundamental type.
* A class or struct that is defined at namespace scope.
* A scoped enumeration that is defined at namespace scope.
* An unscoped enumeration that has an explicit underlying type, where the
  enumeration is defined at namespace scope.
* A type alias to one of the above types.


== Example

=== Basic invocation

The following example demonstrates how to define a free function kernel and then
enqueue it on a device.

```
namespace syclex = sycl::ext::oneapi::experimental;

static constexpr size_t NUM = 1024;

SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
void iota(float start, float *ptr) {
  // Get the ID of this kernel iteration.
  size_t id = syclex::this_kernel::get_id();

  ptr[id] = start + static_cast<float>(id);
}

void main() {
  sycl::queue q;
  sycl::context ctxt = q.get_context();

  // Get a kernel bundle that contains the free function kernel "iota".
  auto exe_bndl =
    syclex::get_kernel_bundle<iota, sycl::bundle_state::executable>(ctxt);

  // Get a kernel object for the "iota" function from that bundle.
  sycl::kernel k_iota = exe_bndl.ext_oneapi_get_kernel<iota>();

  float *ptr = sycl::malloc_shared<float>(NUM, q);
  q.submit([&](sycl::handler &cgh) {
    // Set the values of the kernel arguments.
    cgh.set_args(3.14f, ptr);

    cgh.parallel_for({NUM}, k_iota);
  }).wait();
}
```

=== Free function kernels which are templates or overloaded

A free function kernel may be defined as a function template.
It is also legal to define several overloads for a free function kernel.
The following example demonstrates how to get a kernel identifier in such
cases.

```
namespace syclex = sycl::ext::oneapi::experimental;

template<typename T>
SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
void iota(T start, T *ptr) {
  // ...
}

SYCL_EXT_ONEAPI_SINGLE_TASK_KERNEL
void ping(float *x) {
  // ...
}

SYCL_EXT_ONEAPI_SINGLE_TASK_KERNEL
void ping(int *x) {
  // ...
}

int main() {
  // When the free function kernel is templated, pass the address of a
  // specific instantiation.
  sycl::kernel_id iota_float = syclex::get_kernel_id<iota<float>>();
  sycl::kernel_id iota_int = syclex::get_kernel_id<iota<int>>();

  // When there are multiple overloads of a free function kernel, use a cast
  // to disambiguate.
  sycl::kernel_id ping_float = syclex::get_kernel_id<(void(*)(float))ping>();
  sycl::kernel_id ping_int = syclex::get_kernel_id<(void(*)(int))ping>();
}
```


== Issues

* We're pretty sure that we want to define some syntax that allows a free
  function kernel to be enqueued using the APIs defined in
  link:../proposed/sycl_ext_oneapi_enqueue_functions.asciidoc[
  sycl_ext_oneapi_enqueue_functions], but we haven't settled on the exact API
  yet.
  One option is like this:
+
```
SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
void iota(float start, float *ptr) { /*...*/  }

int main() {
  sycl::queue q;
  float *ptr = sycl::malloc_shared<float>(N, q);
  sycl::parallel_for<iota>(q, {N}, 1.f, ptr);
}
```
+
Another option is like this:
+
```
SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
void iota(float start, float *ptr) { /*...*/  }

int main() {
  sycl::queue q;
  float *ptr = sycl::malloc_shared<float>(N, q);
  sycl::parallel_for(q, {N}, kfp<iota>, 1.f, ptr);
}
```
+
Where `kfp` would have some nicer name.

* Can the front-end define a trait like this, which returns true only if the
  address is a free function kernel:
+
```
template <auto *Func>
bool is_kernel_function_v;
```
+
If the front-end can provide this, we can provide a nice diagnostic when the
user passes an invalid address to the kernel bundle functions like
`template<auto *Func> kernel_id get_kernel_id()`.

* We need to investigate whether there will be problems passing kernel
  arguments that are "decomposed" by the front-end.
  For example, if a kernel argument is a struct that contains an accessor as a
  member variable, the front-end decomposes the struct, passing each member
  variable as a separate kernel argument.
  We could still support arguments like this if `handler::set_arg` is smart
  enough to also do the decomposition, passing multiple arguments when the
  argument type requires decomposition.
  If this is too difficult to implement, we could restrict the arguments to
  only those types that do not require decomposition, however this would be a
  big limitation because `accessor` and `local_accessor` would both be
  prohibited.
  If we add this restriction, the front-end should diagnose an error if a
  free function kernel is defined to take such an argument.

* There is a similar problem with kernel arguments that have been optimized.
  Consider a kernel that uses an `accessor`.
  Each member variable is passed as a separate kernel argument, but any members
  that are unused in the kernel are optimized away, thus they have no
  corresponding kernel argument.
  Again, we can handle this by making `handler::set_arg` smart enough to know
  which member variables have been optimized away.
  Alternatively, we can disable these optimizations for free function kernels.
  We also have to consider the behavior when a free function kernel has a
  formal parameter that is unused (or optimized away) inside the kernel.
  Can the compiler optimize away such an argument?
  If so, `handler::set_arg` would need to be smart enough to treat an attempt
  to set the value of such an argument as a no-op.
  The `handler::set_arg` function would also need to account for this when
  interpreting the argument index of arguments that follow an optimized-away
  argument.

* What happens if the user defines the kernel function with a default parameter
  value?
  Ideally, the caller could omit the call to `handler::set_arg` in this case,
  but that seems hard to implement and would cost extra cycles whenever setting
  a kernel argument.
  Another option is to have the front-end diagnose an error in this case, but
  that requires some special logic in the front-end.
  FWIW, nvcc seems to allow default parameter values for kernels, and the
  call site can omit the corresponding argument value when using the triple
  chevron syntax.
  However, the argument value cannot be omitted when invoking the kernel via
  `cuLaunchKernel`.

* We currently say it is UB if there is a mismatch between a free function
  kernel's type or dimensionality and the call to `parallel_for` or
  `single_task`.
  Should we go a step further and require an exception to be thrown in these
  cases?
  I'm pretty sure we can implement this in {dpcpp}, but I'm not sure about a
  library-only implementation.
  However, I'm not sure _any_ of this can be implemented without compiler
  support.

* We currently say it is UB if a free function kernel is enqueued without
  setting a value for each of its arguments.
  Should we go a step further and require an exception in this case?
  This seems easier to implement, even for library-only.
