= sycl_ext_oneapi_free_function_kernels

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]
:endnote: &#8212;{nbsp}end{nbsp}note

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2023-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.
OpenCL(TM) is a trademark of Apple Inc. used by permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 8 specification.
All references below to the "core SYCL specification" or to section numbers in
the SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:../experimental/sycl_ext_oneapi_properties.asciidoc[
  sycl_ext_oneapi_properties]
* link:../proposed/sycl_ext_oneapi_free_function_queries.asciidoc[
  sycl_ext_oneapi_free_function_queries]


== Status

This is a proposed extension specification, intended to gather community
feedback.
Interfaces defined in this specification may not be implemented yet or may be
in a preliminary state.
The specification itself may also change in incompatible ways before it is
finalized.
*Shipping software products should not rely on APIs defined in this
specification.*


== Overview

This extension introduces a new way to define a kernel as a simple C++
function, where the kernel arguments are parameters to the function.
This is different from standard SYCL kernels, where the kernel arguments are
either captures of a lambda expression or member variables of a callable
object.

The primary motivation for this extension is the
link:../proposed/sycl_ext_oneapi_kernel_compiler.asciidoc[
sycl_ext_oneapi_kernel_compiler], which allows online compilation of a kernel
from source code.
These kernels must have a clean separation between host and device code, and
they must have a defined order to their arguments because the application sets
the argument values by their "index" via `handler::set_arg(index, value)`.
Because variables captured by lambda expressions have no defined order, we need
some other way to define kernel arguments for use with the
sycl_ext_oneapi_kernel_compiler extension, and the
sycl_ext_oneapi_free_function_kernels extension provides that mechanism.
The "free function kernel" feature is a separate extension, though, because it
can also be used independently from sycl_ext_oneapi_kernel_compiler.
For example, some users may find it more familiar to define kernels as plain
functions or they might have other reasons to prefer a clean separation between
host and device code.


== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.
An implementation supporting this extension must predefine the macro
`SYCL_EXT_ONEAPI_FREE_FUNCTION_KERNELS`
to one of the values defined in the table below.
Applications can test for the existence of this macro to determine if the
implementation supports this feature, or applications can test the macro's
value to determine which of the extension's features the implementation
supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===

=== Defining a free function kernel

A free function kernel is a normal C++ function definition, where the function
declaration is decorated with one of the following compile-time properties:
`range_kernel`, `nd_range_kernel`, or `single_task_kernel`.

The following table provides additional details about these compile-time
properties.

|====
a|
*`range_kernel` property*

[frame=all,grid=none]
!====
a!
[source]
----
struct range_kernel_key {
  template <int Dims>
  using value_t = property_value<range_kernel_key, Dims>;
};

template<int Dims>
inline constexpr range_kernel_key::value_t<Dims> range_kernel;

template<>
struct is_property_key<range_kernel_key> : std::true_type {};
----
!====

Indicates that the function is a free function kernel that is invoked with a
simple `range` iteration space of `Dims` dimensions.

The `property_value` struct has the following member variables:

[%header,cols="1,1"]
!====
!Member
!Description

a!
[source]
----
static constexpr int dimensions = Dims
----
!
The number of dimensions of the kernel's range.
!====

a|
*`nd_range_kernel` property*

[frame=all,grid=none]
!====
a!
[source]
----
struct nd_range_kernel_key {
  template <int Dims>
  using value_t = property_value<nd_range_kernel_key, Dims>;
};

template<int Dims>
inline constexpr nd_range_kernel_key::value_t<Dims> nd_range_kernel;

template<>
struct is_property_key<nd_range_kernel_key> : std::true_type {};
----
!====

Indicates that the function is a free function kernel that is invoked with an
`nd_range` iteration space of `Dims` dimensions.

The `property_value` struct has the following member variables:

[%header,cols="1,1"]
!====
!Member
!Description

a!
[source]
----
static constexpr int dimensions = Dims
----
!
The number of dimensions of the kernel's range.
!====

a|
*`single_task_kernel` property*

[frame=all,grid=none]
!====
a!
[source]
----
struct single_task_kernel_key {
  using value_t = property_value<single_task_kernel_key>;
};

inline constexpr single_task_kernel_key::value_t single_task_kernel;

template<>
struct is_property_key<single_task_kernel_key> : std::true_type {};
----
!====

Indicates that the function is a free function kernel that is invoked via
`single_task` (i.e. without any iteration space).
|====

When a function is defined as a free function kernel, each parameter to the
function is a kernel argument, which must abide by the rules for allowable
kernel parameter types specified in section 4.12.4 "Rules for parameter passing
to kernels" of the core SYCL specification.
The function's return type must be `void`.

The following example demonstrates how a free function kernel can be defined
using the `range_kernel` property:

```
namespace syclex = sycl::ext::oneapi::experimental;

SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::range_kernel<1>)
void iota(float start, float *ptr) {
   // ...
}
```

=== New kernel bundle member functions

This extension adds the following new functions which add kernel bundle support
for free function kernels:

|====
a|
[frame=all,grid=none]
!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

template <auto *Func>
kernel_id get_kernel_id();

} // namespace sycl::ext::oneapi::experimental
----
!====

_Preconditions_: The address `Func` must be the address of some free function
kernel that is defined in the calling application.

[_Note:_ The function `Func` need not be defined in the same translation unit
as the call to `get_kernel_id`.
_{endnote}_]

_Returns:_ The kernel identifier that is associated with that kernel.

!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

template <auto *Func, bundle_state State>                                // (1)
kernel_bundle<State> get_kernel_bundle(const context& ctxt);

template <auto *Func, bundle_state State>                                // (2)
kernel_bundle<State> get_kernel_bundle(const context& ctxt,
                                       const std::vector<device>& devs);

} // namespace sycl::ext::oneapi::experimental
----
!====

_Preconditions_: The address `Func` must be the address of some free function
kernel that is defined in the calling application.

_Returns: (1)_ The same value as
`get_kernel_bundle<State>(ctxt, ctxt.get_devices(), {get_kernel_id<Func>()})`.

_Returns: (2)_ The same value as
`get_kernel_bundle<State>(ctxt, devs, {get_kernel_id<Func>()})`.

!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

template <auto *Func, bundle_state State>                                     // (1)
bool has_kernel_bundle(const context& ctxt);

template <auto *Func, bundle_state State>                                     // (2)
bool has_kernel_bundle(const context& ctxt, const std::vector<device>& devs);

} // namespace sycl::ext::oneapi::experimental
----
!====

_Preconditions_: The address `Func` must be the address of some free function
kernel that is defined in the calling application.

_Returns: (1)_ The same value as
`has_kernel_bundle<State>(ctxt, {get_kernel_id<Func>()})`.

_Returns: (2)_ The same value as
`has_kernel_bundle<State>(ctxt, devs, {get_kernel_id<Func>()})`.

!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

template <auto *Func> bool is_compatible(const device& dev);

} // namespace sycl::ext::oneapi::experimental
----
!====

_Preconditions_: The address `Func` must be the address of some free function
kernel that is defined in the calling application.

_Returns:_ The same value as
`is_compatible<State>({get_kernel_id<Func>()}, dev)`.

|====

This extension also adds the following new member functions to the
`kernel_bundle` class:

```
namespace sycl {

template <bundle_state State>
class kernel_bundle {
  // ...

  template<auto *Func>
  bool ext_oneapi_has_kernel();

  template<auto *Func>
  bool ext_oneapi_has_kernel(const device &dev);

  template<auto *Func>
  kernel ext_oneapi_get_kernel();
};

} // namespace sycl
```

|====
a|
[frame=all,grid=none]
!====
a!
[source]
----
template<auto *Func>                           // (1)
bool ext_oneapi_has_kernel()

template<auto *Func>                           // (2)
bool ext_oneapi_has_kernel(const device &dev)
----
!====

_Preconditions_: The address `Func` must be the address of some free function
kernel that is defined in the calling application.

_Returns: (1)_: The value `true` only if the kernel bundle contains the free
function kernel whose address is `Func`.

_Returns: (2)_: The value `true` only if the kernel bundle contains the free
function kernel whose address is `Func` and if that kernel is compatible with
the device `dev`.

!====
a!
[source]
----
template<auto *Func>
kernel ext_oneapi_get_kernel()
----
!====

_Constraints:_ This function is available only when `State` is
`bundle_state::executable`.

_Preconditions_: The address `Func` must be the address of some free function
kernel that is defined in the calling application.

_Returns:_ If the kernel whose address is `Func` resides in this kernel bundle,
returns the `kernel` object representing that kernel.

_Throws_: An `exception` with the error code `errc::invalid` if the kernel with
address `Func` does not reside in this kernel bundle.
|====

=== Behavior with kernel bundle functions in the core SYCL specification

Free function kernels that are defined by the application have a corresponding
kernel identifier (`kernel_id`) and are contained by the device images in the
SYCL application.
This section defines the ramifications this has on the kernel bundle functions
defined by the core SYCL specification.

* The function `get_kernel_ids()` returns the kernel identifiers for any free
  function kernels defined by the application, in addition to identifiers for
  any kernels defined as lambda expressions or named kernel objects.

* The kernel bundle returned by
  `get_kernel_bundle(const context&, const std::vector<device>& devs)` contains
  all of the free function kernels defined by the application that are
  compatible with at least one of the devices in `devs`, in addition to all of
  the kernels defined as lambda expressions or named kernel objects that are
  compatible with one of these devices.

* The function `has_kernel_bundle(const context&, const std::vector<device>&)`
  considers free function kernels defined by the application when computing its
  return value.

The information descriptor `info::kernel::num_args` may be used to query a
`kernel` object that represents a free function kernel.
The return value tells the number of formal parameters in the function's
definition.

=== Enqueuing a free function kernel and setting parameter values

Once the application obtains a `kernel` object for a free function kernel, it
can enqueue the kernel to a device using any of the SYCL functions that allow
a kernel to be enqueued via a `kernel` object.
The application must enqueue the free function kernel according to its type.
For example, a free function kernel defined via `range_kernel` can be enqueued
by calling the `handler::parallel_for` overload taking a `range`.
A free function kernel defined via `nd_range_kernel` can be enqueued by calling
the `handler::parallel_for` overload taking an `nd_range`.
A free function kernel defined via `single_task_kernel` can be enqueued by
calling `handler::single_task`.

Attempting to enqueue a free function kernel using a mechanism that does not
match its type results in undefined behavior.
Attempting to enqueue a free function kernel with a `range` or `nd_range` whose
dimensionality does not match the free function kernel definition results in
undefined behavior.

The application is also responsible for setting the values of any kernel
arguments when the kernel is enqueued.
For example, when enqueuing a kernel with `handler::parallel_for` or
`handler::single_task`, the kernel argument values must be set via
`handler::set_arg` or `handler::set_args`.
Failing to set the value of a kernel argument results in undefined behavior.
The type of the value passed to `handler::set_arg` or `handler::set_args` must
be the same as the type of the corresponding formal parameter in the free
function kernel.
Passing a value with a mismatched type results in undefined behavior.

=== Obtaining the iteration id for a kernel

In a standard SYCL kernel, the iteration ID is passed as a parameter to the
kernel's callable object.
However, this is not the case for a free function kernel because the function
parameters are used to pass the kernel arguments instead.
Therefore, a free function kernel must obtain the iteration ID in some other
way.
Typically, a free function kernel uses the functions specified in
link:../proposed/sycl_ext_oneapi_free_function_queries.asciidoc[
sycl_ext_oneapi_free_function_queries] for this purpose.

=== Interaction with kernel properties

If the implementation supports
link:../experimental/sycl_ext_oneapi_kernel_properties.asciidoc[
sycl_ext_oneapi_kernel_properties], a free function kernel may be decorated
with these properties by applying the properties to the function definition as
illustrated below.

```
SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::nd_range_kernel<1>)
SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::work_group_size<32>)
void iota(float start, float *ptr) {
   // ...
}
```

As with standard SYCL kernels, these properties can be queried via
`kernel::get_info` using either the `info::kernel::attributes` information
descriptor or the `info::kernel_device_specific` information descriptors.


== Example

=== Basic invocation

The following example demonstrates how to define a free function kernel and then
enqueue it on a device.

```
namespace syclex = sycl::ext::oneapi::experimental;

static constexpr size_t NUM = 1024;

SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::range_kernel<1>)
void iota(float start, float *ptr) {
  // Get the ID of this kernel iteration.
  size_t id = syclex::this_kernel::get_id();

  ptr[id] = start + static_cast<float>(id);
}

void main() {
  sycl::queue q;
  sycl::context ctxt = q.get_context();

  // Get a kernel bundle that contains the free function kernel "iota".
  auto exe_bndl =
    syclex::get_kernel_bundle<iota, sycl::bundle_state::executable>(ctxt);

  // Get a kernel object for the "iota" function from that bundle.
  sycl::kernel k_iota = exe_bndl.ext_oneapi_get_kernel<iota>();

  float *ptr = sycl::malloc_shared<float>(NUM, q);
  q.submit([&](sycl::handler &cgh) {
    // Set the values of the kernel arguments.
    cgh.set_args(3.14f, ptr);

    cgh.parallel_for({NUM}, k_iota);
  }).wait();
}
```

=== Free function kernels which are templates or overloaded

A free function kernel may be defined as a function template.
It is also legal to define several overloads for a free function kernel.
The following example demonstrates how to get a kernel identifier in such
cases.

```
namespace syclex = sycl::ext::oneapi::experimental;

template<typename T>
SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::range_kernel<1>)
void iota(T start, T *ptr) {
  // ...
}

SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::single_task_kernel)
void ping(float *x) {
  // ...
}

SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::single_task_kernel)
void ping(int *x) {
  // ...
}

int main() {
  // When the free function kernel is templated, pass the address of a
  // specific instantiation.
  sycl::kernel_id iota_float = syclex::get_kernel_id<iota<float>>();
  sycl::kernel_id iota_int = syclex::get_kernel_id<iota<int>>();

  // When there are multiple overloads of a free function kernel, use a cast
  // to disambiguate.
  sycl::kernel_id ping_float = syclex::get_kernel_id<(void(*)(float))ping>();
  sycl::kernel_id ping_int = syclex::get_kernel_id<(void(*)(int))ping>();
}
```


== Issues

* Can the front-end define a trait like this, which returns true only if the
  address is a free function kernel:
+
```
template <auto *Func>
bool is_kernel_function_v;
```
+
If the front-end can provide this, we can provide a nice diagnostic when the
user passes an invalid address to the kernel bundle functions like
`template<auto *Func> kernel_id get_kernel_id()`.

* The front-end team has expressed concern about implementing this syntax
  because it requires the front-end to recognize the property names
  `range_kernel`, `nd_range_kernel`, and `single_task_kernel`.
  This is necessary because the front-end must know that functions decorated
  with these properties are device code, and it must somehow get the kernel
  name in order to generate the integration header.
  Currently, the front-end does not intrinsicly know any of the property names.
  Rather, the front-end simply passes the properties verbatim into the
  generated LLVM IR.
  If we want to avoid teaching the front-end about these property names, we
  could instead change the syntax for declaring a free function kernel to be
  like this:
+
```
SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
void iota(float start, float *ptr) {
  // ...
}
```
+
Here, the macro `SYCL_EXT_ONEAPI_RANGE_KERNEL` would expand to two things.
One part of the expansion would be a C++ attribute that tells the front-end
that this function is a free function "range" kernel.
Another part of the expansion would add the same IR attributes as the
`range_kernel` property (assuming there is even a need to represent this
information in the IR).
There are two drawbacks to this approach.
One is purely aesthetic: we would need to add a new macro to the language
instead of using our existing property mechanism.
The other relates to error messages.
Error messages with macros tend to be worse when the user passes incorrect
parameters.
+
This same issue exists also for the extension
link:https://github.com/intel/llvm/pull/10540[
sycl_ext_oneapi_virtual_functions] because that extension adds the property
`indirectly_callable<name>` which must be used to decorate virtual functions
that can be called from device code.
Again, the front-end would either need to recognize this property name, or we
would need to use a new macro like `SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE(name)`
instead of the property.

* We need to investigate whether there will be problems passing kernel
  arguments that are "decomposed" by the front-end.
  For example, if a kernel argument is a struct that contains an accessor as a
  member variable, the front-end decomposes the struct, passing each member
  variable as a separate kernel argument.
  We could still support arguments like this if `handler::set_arg` is smart
  enough to also do the decomposition, passing multiple arguments when the
  argument type requires decomposition.
  If this is too difficult to implement, we could restrict the arguments to
  only those types that do not require decomposition, however this would be a
  big limitation because `accessor` and `local_accessor` would both be
  prohibited.
  If we add this restriction, the front-end should diagnose an error if a
  free function kernel is defined to take such an argument.

* There is a similar problem with kernel arguments that have been optimized.
  Consider a kernel that uses an `accessor`.
  Each member variable is passed as a separate kernel argument, but any members
  that are unused in the kernel are optimized away, thus they have no
  corresponding kernel argument.
  Again, we can handle this by making `handler::set_arg` smart enough to know
  which member variables have been optimized away.
  Alternatively, we can disable these optimizations for free function kernels.
  We also have to consider the behavior when a free function kernel has a
  formal parameter that is unused (or optimized away) inside the kernel.
  Can the compiler optimize away such an argument?
  If so, `handler::set_arg` would need to be smart enough to treat an attempt
  to set the value of such an argument as a no-op.
  The `handler::set_arg` function would also need to account for this when
  interpreting the argument index of arguments that follow an optimized-away
  argument.

* We currently say it is UB if there is a mismatch between a free function
  kernel's type or dimensionality and the call to `parallel_for` or
  `single_task`.
  Should we go a step further and require an exception to be thrown in these
  cases?
  I'm pretty sure we can implement this in {dpcpp}, but I'm not sure about a
  library-only implementation.
  However, I'm not sure _any_ of this can be implemented without compiler
  support.

* We currently say it is UB if a free function kernel is enqueued without
  setting a value for each of its arguments.
  Should we go a step further and require an exception in this case?
  This seems easier to implement, even for library-only.
