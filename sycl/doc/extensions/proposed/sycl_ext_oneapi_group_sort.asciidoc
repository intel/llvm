= sycl_ext_oneapi_group_sort
:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]
:language: {basebackend@docbook:c++:cpp}

== Notice

[%hardbreaks]
Copyright (c) 2021-2024 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.

== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues

== Dependencies

This extension is written against the SYCL 2020 revision 5 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:../experimental/sycl_ext_oneapi_properties.asciidoc[sycl_ext_oneapi_properties]

== Status

This is an experimental extension specification, intended to provide early
access to features and gather community feedback.  Interfaces defined in this
specification are implemented in {dpcpp}, but they are not finalized and may
change incompatibly in future versions of {dpcpp} without prior notice.
*Shipping software products should not rely on APIs defined in this
specification.*

== Introduction

This extension introduces sorting functions to the group algorithms
library, along with associated Sorter objects and Group Helper objects.

== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.  An implementation supporting this extension must predefine the
macro `SYCL_EXT_ONEAPI_GROUP_SORT` to one of the values defined in the table
below.  Applications can test for the existence of this macro to determine if
the implementation supports this feature, or applications can test the macro's
value to determine which of the extension's features the implementation
supports.

Table 1. Values of the `SYCL_EXT_ONEAPI_GROUP_SORT` macro.
[%header,cols="1,5"]
|===
|Value |Description
|1     |Initial extension version. Base features are supported.
|2     |Interfaces with fixed-size arrays and key-value sorting are supported.
|===

== Sorting functions
The sort function from the {cpp} standard sorts elements with respect to
the binary comparison function object.

SYCL provides two similar algorithms:

`joint_sort` uses the work-items in a group to execute the corresponding
algorithm in parallel.

`sort_over_group` performs a sort over values held directly by the work-items
in a group, and results returned to work-item `i` represent values that are in
position `i` in the ordered range.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

  template <typename GroupHelper, typename Ptr>
  void joint_sort(GroupHelper gh, Ptr first, Ptr last); // (1)

  template <typename GroupHelper, typename Ptr, typename Compare>
  void joint_sort(GroupHelper gh, Ptr first, Ptr last, Compare comp); // (2)

  template <typename Group, typename Ptr, typename Sorter>
  void joint_sort(Group g, Ptr first, Ptr last, Sorter sorter); // (3)

  template <typename GroupHelper, typename T>
  T sort_over_group(GroupHelper gh, T value); // (4)

  template <typename GroupHelper, typename T, typename Compare>
  T sort_over_group(GroupHelper gh, T value, Compare comp); // (5)

  template <typename Group, typename T, typename Sorter>
  T sort_over_group(Group g, T value, Sorter sorter); // (6)

  template <typename GroupHelper, typename T, typename U>
  std::tuple<T, U>
  sort_key_value_over_group(GroupHelper gh, T key, U value); // (7)

  template <typename GroupHelper, typename T, typename U, typename Compare>
  std::tuple<T, U>
  sort_key_value_over_group(GroupHelper gh, T key, U value, Compare comp); // (8)

  template <typename Group, typename T, typename U, typename Sorter>
  std::tuple<T, U>
  sort_key_value_over_group(Group g, T key, U value, Sorter sorter); // (9)

}
----

(1) _Preconditions_: `first`, `last` must be the same for all work-items
in the group.

_Constraints_: Only available if `GroupHelper` was created with a
work-group or sub-group and some associated scratch space.

_Effects_: Sort the elements in the range `[first, last)`
using the `gh` group helper object. Elements are compared by `operator<`.

_Complexity_: Let `N` be `last - first`. `O(N*log(N)*log(N))` comparisons.

(2) _Preconditions_: `first`, `last` must be the same for all work-items
in the group.

_Constraints_: Only available if `GroupHelper` was created with
a work-group or a sub-group and some associated scratch space.

_Mandates_: `comp` must satisfy the requirements of `Compare` from
the {cpp} standard.

_Effects_: Sort the elements in the range `[first, last)` with respect to the
binary comparison function object `comp` using the `gh` group helper object.

_Complexity_: Let `N` be `last - first`. `O(N*log(N)*log(N))` comparisons.

(3) _Preconditions_: `first`, `last` must be the same
for all work-items in the group.

_Constraints_: All functions are available only if `Sorter` is
a SYCL Sorter and it provides `operator()(Group, Ptr, Ptr)` overload.

_Effects_: Equivalent to: `sorter(g, first, last)`.

(4) _Constraints_: Only available if `GroupHelper` was created with
a work-group or a sub-group and some associated scratch space.

_Returns_: The value returned on work-item `i` is the value in position `i`
of the ordered range resulting from sorting `value` from all work-items
in the group. Elements are compared by `operator<`
using the `gh` group helper object.
For multi-dimensional groups, the order of work-items in the group is
determined by their linear id.

_Complexity_: Let `N` be the work-group size. `O(N*log(N)*log(N))` comparisons.

(5) _Constraints_: Only available if `GroupHelper` was created with
a work-group or a sub-group and some associated scratch space.

_Mandates_: `comp` must satisfy the requirements of `Compare` from
the {cpp} standard.

_Returns_: The value returned on work-item `i` is the value in position `i`
of the ordered range resulting from sorting `value` from all work-items in the
group with respect to the binary comparison function object `comp`
using the `gh` group helper object.
For multi-dimensional groups, the order of work-items in the group is
determined by their linear id.

_Complexity_: Let `N` be the work-group or sub-group size.
`O(N*log(N)*log(N))` comparisons.

(6) _Constraints_: All functions are available only if `Sorter` is
a SYCL Sorter and it provides `operator()(Group, T)` overload.

_Effects_: Equivalent to: `return sorter(g, value)`.

(7) _Constraints_: Only available if `GroupHelper` was created with
a work-group or a sub-group and some associated scratch space.

_Returns_: The value returned on work-item `i` is the tuple of values
that are in position `i`
of the ordered range resulting from key-value sorting of `key` and `value`
from all work-items
in the group. Elements are compared by `operator<`
using the `gh` group helper object.
For multi-dimensional groups, the order of work-items in the group is
determined by their linear id.

_Complexity_: Let `N` be the work-group size. `O(N*log(N)*log(N))` comparisons.

(8) _Constraints_: Only available if `GroupHelper` was created with
a work-group or a sub-group and some associated scratch space.

_Mandates_: `comp` must satisfy the requirements of `Compare` from
the {cpp} standard.

_Returns_: The value returned on work-item `i` is the tuple of values
that are in position `i`
of the ordered range resulting from key-value sorting of `key` and `value`
from all work-items in the
group with respect to the binary comparison function object `comp`
using the `gh` group helper object.
For multi-dimensional groups, the order of work-items in the group is
determined by their linear id.

_Complexity_: Let `N` be the work-group or sub-group size.
`O(N*log(N)*log(N))` comparisons.

(9) _Constraints_: All functions are available only if `Sorter` is
a SYCL Sorter and it provides `operator()(Group, T, U)` overload.

_Effects_: Equivalent to: `return sorter(g, key, value)`.

NOTE: (7), (8), (9) functions are available starting in revision 2 of this extension.

=== Functions with fixed-size arrays

The functions in this section are additional overloads for functions defined above,
except one thing: each work-item provides a fixed-size array of elements rather than
a single element.

NOTE: These functions are available starting in revision 2 of this extension.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

  template <typename GroupHelper, typename T,
            std::size_t ElementsPerWorkItem,
            typename Properties = ext::oneapi::experimental::empty_properties_t>
  void sort_over_group(GroupHelper gh,
                       sycl::span<T, ElementsPerWorkItem> values,
                       Properties properties = {}); // (1)

  template <typename GroupHelper, typename T,
            std::size_t ElementsPerWorkItem, typename Compare,
            typename Properties = ext::oneapi::experimental::empty_properties_t>
  void sort_over_group(GroupHelper gh,
                       sycl::span<T, ElementsPerWorkItem> values,
                       Compare comp,
                       Properties properties = {}); // (2)

  template<typename Group, typename T, std::size_t ElementsPerWorkItem,
           typename Sorter,
           typename Properties = ext::oneapi::experimental::empty_properties_t>
  void sort_over_group(Group g,
                       sycl::span<T, ElementsPerWorkItem> values,
                       Sorter sorter,
                       Properties properties = {}); // (3)

  template <typename GroupHelper, typename T, typename U,
            std::size_t ElementsPerWorkItem,
            typename Properties = ext::oneapi::experimental::empty_properties_t>
  void sort_key_value_over_group(GroupHelper gh,
                                 sycl::span<T, ElementsPerWorkItem> keys,
                                 sycl::span<U, ElementsPerWorkItem> values,
                                 Properties properties = {}); // (4)

  template <typename GroupHelper, typename T, typename U,
            std::size_t ElementsPerWorkItem,
            typename Compare,
            typename Properties = ext::oneapi::experimental::empty_properties_t>
  void sort_key_value_over_group(GroupHelper gh,
                                 sycl::span<T, ElementsPerWorkItem> keys,
                                 sycl::span<U, ElementsPerWorkItem> values,
                                 Compare comp,
                                 Properties properties = {}); // (5)

  template<typename Group, typename T, typename U,
           std::size_t ElementsPerWorkItem,
           typename Sorter,
           typename Properties = ext::oneapi::experimental::empty_properties_t>
  void sort_key_value_over_group(Group g,
                                 sycl::span<T, ElementsPerWorkItem> keys,
                                 sycl::span<U, ElementsPerWorkItem> values,
                                 Sorter sorter,
                                 Properties properties = {}); // (6)
}
----

NOTE: (4), (5), (6) functions below perform sorting
including key-value variant.
Key value sorting is a sorting algorithm where keys are compared,
but keys and values are reordered both.

(1) _Constraints_: Only available if `GroupHelper` was created with
a work-group or a sub-group and some associated scratch space and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Effects_: Sort elements in the range containing of elements inside
`values` from all work-items from the group.
Result of sorting is placed into `values` with data placements
specified by `properties`.
Default data placements are those that are specified by the
`group_algorithm_data_placement::blocked` property.
Elements are compared by `operator<` using
the `gh` group helper object.

_Complexity_: Let `N` be the group size. `O(N*log(N)*log(N))` comparisons.

(2) _Constraints_: Only available if `GroupHelper` was created with
a work-group or a sub-group and some associated scratch space and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Mandates_: `comp` must satisfy the requirements of
`Compare` from the {cpp} standard.

_Effects_: Sort elements in the range containing of elements
inside `values` from all work-items from the group with respect to
the binary comparison function object `comp` using the `gh` group
helper object.
Result of sorting is placed into `values` with data placements
specified by `properties`.
Default data placements are those that are specified by the
`group_algorithm_data_placement::blocked` property.

_Complexity_: Let `N` be the work-group or sub-group size.
`O(N*log(N)*log(N))` comparisons.

(3) _Constraints_: All functions are available only if `Sorter` is
a SYCL Sorter and it provides `operator()(Group, sycl::span)` overload and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Effects_: Equivalent to: `return sorter(g, values, properties)`.

(4) _Constraints_: Only available if `GroupHelper` was created with
a work-group or a sub-group and some associated scratch space and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Effects_: Perform key-value sorting for elements in ranges
containing of elements inside `keys` and `values` from all work-items
from the group.
Result of sorting is placed into `keys` and `values` with
data placements specified by `properties`.
Default data placements are those that are specified by the
`group_algorithm_data_placement::blocked` property.
Elements are compared by `operator<` using the `gh` group helper object.

_Complexity_: Let `N` be the group size. `O(N*log(N)*log(N))` comparisons.

(5) _Constraints_: Only available if `GroupHelper` was created with
a work-group or a sub-group and some associated scratch space and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Mandates_: `comp` must satisfy the requirements of `Compare` from
the {cpp} standard.

_Effects_: Perform key-value sorting for elements in ranges containing
of elements inside `keys` and `values` from all work-items from
the group with respect to the binary comparison
function object `comp` using the `gh` group helper object.
Result of sorting is placed into `keys` and `values` with data placements
specified by `properties`.
Default data placements are those that are specified by the
`group_algorithm_data_placement::blocked` property.
Elements are compared by `operator<`.

_Complexity_: Let `N` be the work-group or sub-group size.
`O(N*log(N)*log(N))` comparisons.

(6) _Constraints_: All functions are available only if `Sorter` is
a SYCL Sorter and it provides `operator()(Group, sycl::span, sycl::span)
overload and `sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>`
is true.

_Effects_: Equivalent to: `return sorter(g, keys, values, properties)`.

== Sorters

Sorter is a special type that encapsulates a sorting algorithm.
Sorter may contain parameters
that help to get better performance. Data for sorting are provided
to `operator()`
that should contain an implementation of a sorting algorithm.
General semantics of `operator()` is following:

[source,c++]
----
template<typename Group, typename Ptr>
void operator()(Group g, Ptr first, Ptr last);

template<typename Group, typename T>
T operator()(Group g, T value);

template<typename Group, typename T, std::size_t ElementsPerWorkItem,
         typename Properties>
void operator()(Group g,
                sycl::span<T, ElementsPerWorkItem> values,
                Properties properties);

template<typename Group, typename T, typename U>
std::tuple<T, U> operator()(Group g, T key, U value);

template<typename Group, typename T, typename U,
         std::size_t ElementsPerWorkItem,
         typename Properties>
void operator()(Group g,
                sycl::span<T, ElementsPerWorkItem> keys,
                sycl::span<U, ElementsPerWorkItem> values,
                Properties properties);
----

NOTE: At least one `operator()` overload must be presented.
For example, if only `void operator()(Group g, Ptr first, Ptr last);`
is defined then a Sorter can be passed to `joint_sort` function only.
If it's passed to `sort_over_group`, it leads to a compilation
error. If only `T operator()(Group g, T value);` is defined then a Sorter
can be passed to `sort_over_group` function only. If it's passed to
`joint_sort`, it leads to a compilation error.

Table 2. `operator()` for Sorters.
|===
|`operator()`|Description

|`template<typename Group, typename Ptr>
void operator()(Group g, Ptr first, Ptr last);`
|Implements a sorting algorithm that calls by `joint_sort`.
Available only if `sycl::is_group_v<std::decay_t<Group>>` is true.
`first`, `last` must be the same for all work-items in the group.

|`template<typename Group, typename T>
T operator()(Group g, T value);`
|Implements a sorting algorithm that calls by `sort_over_group`.
Available only if `sycl::is_group_v<std::decay_t<Group>>` is true.

|`template<typename Group, typename T, typename U>
std::tuple<T, U> operator()(Group g, T key, U value);`
|Implements a sorting algorithm that calls by `sort_key_value_over_group`.
Available only if `sycl::is_group_v<std::decay_t<Group>>` is true.

|`template<typename Group, typename T,
           std::size_t ElementsPerWorkItem, typename Properties>
void operator()(Group g, sycl::span<T, ElementsPerWorkItem> values,
                Properties properties);`
|Implements a sorting algorithm that is called by `sort_over_group` and
that accepts
the `sycl::span` value as an input parameter.
Result of sorting is placed into `values` with data placements specified by
`properties`.
Default data placements are those that are specified by the
`group_algorithm_data_placement::blocked` property.
Available only if `sycl::is_group_v<std::decay_t<Group>>` is true and
`ElementsPerWorkItem` is not equal to `sycl::dynamic_extent`.

|`template<typename Group, typename T, typename U,
           std::size_t ElementsPerWorkItem, typename Properties>
void operator()(Group g, sycl::span<T, ElementsPerWorkItem> keys,
                sycl::span<U, ElementsPerWorkItem> values,
                Properties properties);`
|Implements a sorting algorithm that is called by
`sort_key_value_over_group` and that
accepts two `sycl::span` values as input parameters.
Result of sorting is placed into `keys` and `values` with data placements
specified by `properties`. Default data placements are those that are
specified by the `group_algorithm_data_placement::blocked` property.
Available only if `sycl::is_group_v<std::decay_t<Group>>` is true and
`ElementsPerWorkItem` is not equal to `sycl::dynamic_extent`.
|===

SYCL provides some predefined sorters mentioned below.
However, custom sorters are particularly useful when the application
knows the data has some special property. For example, an application
could implement a fast bitonic sort if it knows the data size is a power of 2.

=== Predefined Sorters

==== Sorting Order

`sorting_order` is an `enum` that defines a sorting order when
`radix_sorter` is used.
Only ascending and descending orders are applicable.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

  enum class sorting_order {
    ascending,
    descending
  };

}
----

SYCL provides the following predefined classes:

[source,c++]
----

namespace sycl::ext::oneapi::experimental {

  namespace default_sorters {

    template<typename Compare = std::less<>>
    class joint_sorter{
    public:
        template<std::size_t Extent>
        joint_sorter(sycl::span<std::byte, Extent> scratch, Compare comp = {}); // (1)

        template<typename Group, typename Ptr>
        void operator()(Group g, Ptr first, Ptr last); // (2)

        template<typename T>
        static size_t
        memory_required(sycl::device d, sycl::memory_scope scope, std::size_t range_size); // (3)
    };

    template<typename T,
             typename Compare = std::less<>,
             std::size_t ElementsPerWorkItem = 1>
    class group_sorter{
    public:
        template<std::size_t Extent>
        group_sorter(sycl::span<std::byte, Extent> scratch, Compare comp = {}); // (4)

        template<typename Group>
        T operator()(Group g, T value); // (5)

        template<typename Group, typename Properties>
        void operator()(Group g,
                        sycl::span<T, ElementsPerWorkItem> values,
                        Properties properties); // (6)

        static size_t
        memory_required(sycl::device d, sycl::memory_scope scope, std::size_t range_size); // (7)
    };

    template<typename T,
             typename U,
             typename Compare = std::less<>,
             std::size_t ElementsPerWorkItem = 1>
    class group_key_value_sorter{
    public:
        template<std::size_t Extent>
        group_key_value_sorter(sycl::span<std::byte, Extent> scratch,
                               Compare comp = {}); // (8)

        template<typename Group>
        std::tuple<T, U> operator()(Group g, T key, U value); // (9)

        template<typename Group, typename Properties>
        void operator()(Group g,
                        sycl::span<T, ElementsPerWorkItem> keys,
                        sycl::span<U, ElementsPerWorkItem> values,
                        Properties property); // (10)

        static std::size_t
        memory_required(sycl::device d, sycl::memory_scope scope, std::size_t range_size); // (11)
    };
  }

  namespace radix_sorters{

    template<typename T,
             sorting_order Order = sorting_order::ascending,
             unsigned int BitsPerPass = 4>
    class joint_sorter
    {
    public:
        template<std::size_t Extent>
        joint_sorter(sycl::span<std::byte, Extent> scratch,
                     const std::bitset<sizeof(T) * CHAR_BIT> mask =
                       std::bitset<sizeof(T) * CHAR_BIT> (std::numeric_limits<unsigned long long>::max())); // (12)

        template<typename Group, typename Ptr>
        void operator()(Group g, Ptr first, Ptr last); // (13)

        static constexpr std::size_t
        memory_required(sycl::memory_scope scope, std::size_t range_size); // (14)
    };

    template<typename T,
             std::size_t sorting_order Order = sorting_order::ascending,
             ElementsPerWorkItem = 1,
             unsigned int BitsPerPass = 4>
    class group_sorter
    {
    public:
        template<std::size_t Extent>
        group_sorter(sycl::span<std::byte, Extent> scratch,
                     const std::bitset<sizeof(T) * CHAR_BIT> mask =
                       std::bitset<sizeof(T) * CHAR_BIT> (std::numeric_limits<unsigned long long>::max())); // (15)

        template<typename Group>
        T operator()(Group g, T value); // (16)

        template<typename Group, typename Properties>
        void operator()(Group g,
                        sycl::span<T, ElementsPerWorkItem> values,
                        Properties properties); // (17)

        static constexpr std::size_t
        memory_required(sycl::memory_scope scope, std::size_t range_size); // (18)
    };

    template<typename T,
             typename U,
             std::size_t sorting_order Order = sorting_order::ascending,
             ElementsPerWorkItem = 1,
             unsigned int BitsPerPass = 4>
    class group_key_value_sorter
    {
    public:
        template<std::size_t Extent>
        group_key_value_sorter(sycl::span<std::byte, Extent> scratch,
                               const std::bitset<sizeof(T) * CHAR_BIT> mask =
                                 std::bitset<sizeof(T) * CHAR_BIT> (std::numeric_limits<unsigned long long>::max())); // (19)

        template<typename Group>
        std::tuple<T, U> operator()(Group g, T key, U value); // (20)

        template<typename Group, typename Properties>
        void operator()(Group g,
                        sycl::span<T, ElementsPerWorkItem> keys,
                        sycl::span<U, ElementsPerWorkItem> values,
                        Properties properties); // (21)

        static constexpr std::size_t
        memory_required(sycl::memory_scope scope, std::size_t range_size); // (22)
    };

  }
}
----

Table 3. Description of predefined Sorters.
|===
|Sorter|Description

|default sorters
|Use a default sorting method based on an implementation-defined heuristic
using `Compare` as the binary comparison function object.
The algorithm requires an additional memory that must be allocated on
callers side.
Size of required memory (bytes) is defined by calling `memory_required`.

|radix sorters
|Use radix sort as a sorting method. `Order` specify the sorting order.
Only arithmetic types as `T` can be passed to `radix_sorter`.
`BitsPerPass` is a number of bits that values are split by.
For example, if a sequence of `int32_t` is sorted using
`BitsPerPass == 4` then one pass of the radix sort algorithm considers
only 4 bits. The number of passes is `32/4=8`.
The algorithm requires an additional memory that must be allocated on
callers side.
Size of required memory (bytes) is defined by calling `memory_required`.
|===

(1), (4), (8) create the object using `comp`.
Additional memory for the algorithm is provided using `scratch`.
If `scratch.size()` is less than the value returned by
`memory_required`, behavior of the corresponding sorting algorithm
is undefined.

(2) Implements a default sorting algorithm to be called by
the `joint_sort` algorithm.

_Complexity_: Let `N` be `last - first`. `O(N*log(N)*log(N))` comparisons.

(3) Returns size of temporary memory (in bytes) that is required by
the default sorting algorithm defined by the sorter calling by `joint_sort`
depending on `d`.
`range_size` represents a range size for sorting,
e.g. `last-first` from `operator()` arguments.
It mustn't be called within a SYCL kernel, only on host.
Result depends on the `scope` parameter:
use `sycl::memory_scope::work_group` to get memory size required
for each work-group;
use `sycl::memory_scope::sub_group` to get memory size required
for each sub-group.
If other `scope` values are passed, behavior is unspecified.

(5) Implements a default sorting algorithm to be called by
the `sort_over_group` algorithm.

_Complexity_: Let `N` be the `Group` size. `O(N*log(N)*log(N))` comparisons.

(6) Implements a default sorting algorithm that is called by
`sort_over_group` and that accepts the `sycl::span` value as
an input parameter.

_Complexity_: Let `N` be the `Group` size multiplied by `ElementsPerWorkItem`.
`O(N*log(N)*log(N))` comparisons.

(7) Returns the size of temporary memory (in bytes) that is required by the default
sorting algorithm defined by the sorter calling by `sort_over_group`
depending on `d`.
`ElementsPerWorkItem` is the extent parameter for `sycl::span`
that is an input parameter for `sort_over_group`.
It mustn't be called within a SYCL kernel, only on host.
If `scope == sycl::memory_scope::work_group`,
`range_size` is the size of the local range for `sycl::nd_range`
that was used to run the kernel;
if `scope = sycl::memory_scope::sub_group`, `range_size` is a sub-group size.
If other `scope` values are passed, behavior is unspecified.

(9) Implements a default key-value sorting algorithm that is called
by `sort_key_value_over_group` and that doesn't accept
`sycl::span` values as input parameters.

_Complexity_: Let `N` be the `Group` size multiplied by `ElementsPerWorkItem`.
`O(N*log(N)*log(N))` comparisons.

(10) Implements a default key-value sorting algorithm that is called
by `sort_key_value_over_group` and that
accepts `sycl::span` values as input parameters.

_Complexity_: Let `N` be the `Group` size multiplied by `ElementsPerWorkItem`.
`O(N*log(N)*log(N))` comparisons.

(11) Returns size of temporary memory (in bytes) that is required by
the default key-value
sorting algorithm defined by the sorter calling by `sort_key_value_over_group`
depending on `d`.
It mustn't be called within a SYCL kernel, only on host.
If `scope == sycl::memory_scope::work_group`,
`range_size` is the size of the local range for `sycl::nd_range`
that was used to run the kernel;
if `scope = sycl::memory_scope::sub_group`, `range_size` is a sub-group size.
If other `scope` values are passed, behavior is unspecified.

(12), (15), (19) create
the class object to sort values considering only bits
that corresponds to 1 in `mask`.
Additional memory for the algorithm is provided using `scratch`.
If `scratch.size()` is less than the value returned by `memory_required`,
behavior of the corresponding sorting algorithm is undefined.

(13) Implements the radix sorting algorithm to be called by
the `joint_sort` algorithm.

(14) Returns size of temporary memory (in bytes) that is required by
the radix sort algorithm
calling by `joint_sort`.
`range_size` represents a range size for sorting,
e.g. `last-first` from `operator()` arguments.
Result depends on the `scope` parameter:
use `sycl::memory_scope::work_group` to get memory size required
for each work-group;
use `sycl::memory_scope::sub_group` to get memory size required
for each sub-group.
If other `scope` values are passed, behavior is unspecified.

(16) Implements the radix sorting algorithm to be called by
the `sort_over_group` algorithm.

(17) Implements the radix sorting algorithm that is called by
`sort_over_group` and that accepts
the `sycl::span` value as an input parameter.

(18) Returns size of temporary memory (in bytes) that is required by the radix
sorting algorithm defined by the sorter calling by `sort_over_group`.
`ElementsPerWorkItem` is a parameter for `sycl::span<T, ElementsPerWorkItem>`
that is an input parameter for `sort_over_group`, where `T` is
a first template argument for `radix_sorter`.
If `scope == sycl::memory_scope::work_group`,
`range_size` is the size of the local range for `sycl::nd_range`
that was used to run the kernel;
if `scope = sycl::memory_scope::sub_group`, `range_size` is a sub-group size.
If other `scope` values are passed, behavior is unspecified.

(20) Implements the radix sorting algorithm that is called
by `sort_key_value_over_group` and that doesn't accept
`sycl::span` values as input parameters.

(21) Implements the radix key-value sorting algorithm that is called
by `sort_key_value_over_group` and that
accepts `sycl::span` values as input parameters.

(22) Returns size of temporary memory (in bytes) that is required by the radix key-value
sorting algorithm defined by the sorter calling by `sort_key_value_over_group`
with `sycl::span<T, ElementsPerWorkItem>` and
`sycl::span<U, ElementsPerWorkItem>` as input parameters.
If `scope == sycl::memory_scope::work_group`,
`range_size` is the size of the local range for `sycl::nd_range`
that was used to run the kernel;
if `scope = sycl::memory_scope::sub_group`, `range_size` is a sub-group size.
If other `scope` values are passed, behavior is unspecified.

=== Group Helper

The overloads of `joint_sort`, `sort_over_group`, `sort_key_value_over_group`
that do not take a Sorter parameter implicitly use the default sorter.
Since the default sorter requires the application to allocate some
temporary memory, the application must use a Group Helper object to
communicate the location of this memory. A Group Helper object is an object
that has the following two public member functions:

[source,c++]
----
/* unspecified */ get_group() const;

sycl::span<std::byte, Extent> get_memory() const
----

Table 4. Member functions of group helpers.
|===
|Member function|Description

|`/* unspecified */ get_group() const`
|Returns the group that is handled by the group helper object.
Assuming `Group` is a type of method's result
`sycl::is_group_v<std::decay_t<Group>>` must be true.

|`sycl::span<std::byte, Extent> get_memory() const`
|Returns the memory object that the default sorter can use.
The return type is aligned with the first parameter of constructor
for `default_sorter`.
|===

==== Predefined Group Helpers
SYCL introduces the following predefined group helper:

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

  // Exposition only: all template arguments except Group are unspecified
  template<typename Group, std::size_t Extent>
  class group_with_scratchpad
  {
  public:
    group_with_scratchpad(Group group, sycl::span<std::byte, Extent> scratch);
    Group get_group() const;

    sycl::span<std::byte, Extent>
    get_memory() const;
  };

  // Deduction guides
  template<typename Group, std::size_t Extent>
  group_with_scratchpad(Group, sycl::span<std::byte, Extent>)
    -> group_with_scratchpad<Group, Extent>;

}
----

For most applications it is enough to pass an instance of
the `group_with_scratchpad` class instead of their own classes creation.

Table 5. Constructors of the `group_with_scratchpad` class.
|===
|Constructor|Description

|`group_with_scratchpad(Group group, sycl::span<std::byte, Extent> scratch)`
|Creates the `group_with_scratchpad` object using `group` and `scratch`.
`sycl::is_group_v<std::decay_t<Group>>` must be true.
`scratch.size()` must not be less than value returned by
the `memory_required` method of `default_sorter`. Otherwise,
behavior of sorting algorithm, which is called with the constructed
object, is undefined.
The `scratch` value must be the same for all work-items in `group`.
|===

Table 6. Member functions of the `group_with_scratchpad` class.
|===
|Member function|Description

|`Group get_group() const`
|Returns the `Group` class object that is handled by
the `group_with_scratchpad` object.

|`sycl::span<std::byte, Extent>
get_memory() const`
|Returns `sycl::span` that represents an additional memory
that is handled by the `group_with_scratchpad` object.

|===

=== SYCL Properties for Interfaces with Fixed-size Private Arrays

Group algorithms using the fixed-size array interface are performed across
`N * ElementsPerWorkItem` elements in the group, where
.`N` is the work-group size and `ElementsPerWorkItem` is the number of
elements that are processed by one work-item.

When a work-item contributes multiple values to a group algorithm,
there are multiple ways to interpret the order of that data.
Let `r` is a virtual range for sorting of `N * ElementsPerWorkItem` elements.
The extension supports two data placements:

a) Data from the
`[r + id * ElementsPerWorkItem; r + (id + 1) * ElementsPerWorkItem)`
virtual range
placed into the private memory under the span for `id`-th work-item.

b) `i * N + id` element of `r` fill the `i`-th element of the private memory
under the span for `id`-th work-item.

To specify a correct data placement for placing of resulting data
there is a enum:

[source,c++]
----
enum class group_algorithm_data_placement{
  blocked,
  striped
};
----

1.`sycl::ext::oneapi::experimental::group_algorithm_data_placement::blocked`
to specify a data placement described in a).

2.`sycl::ext::oneapi::experimental::group_algorithm_data_placement::striped`
to specify a data placement described in b).

Example:

N = 3;

|===
|Work-item id|Input private fixed-size array

|0
|{11, 10, 9, 8}
|1
|{7, 6, 5, 4}
|2
|{3, 2, 1, 0}
|===

After performing sorting by ascending there is the following virtual range:
`{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}`.

Consider 2 layouts:

1.`sycl::ext::oneapi::experimental::group_algorithm_data_placement::blocked`.

|===
|Work-item id|Output private fixed-size array

|0
|{0, 1, 2, 3}
|1
|{4, 5, 6, 7}
|2
|{8, 9, 10, 11}
|===

2.`sycl::ext::oneapi::experimental::group_algorithm_data_placement::striped`.

|===
|Work-item id|Output private fixed-size array

|0
|{0, 3, 6, 9}
|1
|{1, 4, 7, 10}
|2
|{2, 5, 8, 11}
|===

There are 2 compile-time properties that satisfy
link:../experimental/sycl_ext_oneapi_properties.asciidoc[SYCL Properties Extension]
requirements:

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

struct input_data_placement_key : /* unspecified */ {
  template <group_algorithm_data_placement Placement>
  using value_t =
      property_value<input_data_placement_key,
                     std::integral_constant<group_algorithm_data_placement, Placement>>;
};

struct output_data_placement_key : /* unspecified */ {
  template <group_algorithm_data_placement Placement>
  using value_t =
      property_value<output_data_placement_key,
                     std::integral_constant<group_algorithm_data_placement, Placement>>;
};

template <group_algorithm_data_placement Placement>
inline constexpr input_data_placement_key::value_t<Placement>
    input_data_placement; // (1)

template <group_algorithm_data_placement Placement>
inline constexpr output_data_placement_key::value_t<Placement>
    output_data_placement; // (2)

} // namespace sycl::ext::oneapi::experimental
----

1. `input_data_placement` specifies the data placement for input. This is
useful for stable sorts, which preserve the relative input order for elements
that compare equal or algorithms that can use a fact that sequences
can be partially sorted.
2. `output_data_placement` specifies the data placement for output.

Example:
`sort_over_group(g, my_span, properties<input_data_placement<blocked>,
output_data_placement<striped>>{});`

It's specified that data initially in `my_span` satisfies the
`blocked` data placement. After sorting data will be placed to
`my_span` corresponding to the `striped` data placement.

== Examples

1.Using `joint_sort` without Sorters.

[source,c++]
----
...
namespace my_sycl = sycl::ext::oneapi::experimental;
// calculate required local memory size
size_t temp_memory_size =
    my_sycl::default_sorters::joint_sorter<>::memory_required<T>(
      d, sycl::memory_scope::work_group, n);

q.submit([&](sycl::handler& h) {
  auto acc = sycl::accessor(buf, h);
  auto scratch = sycl::local_accessor<std::byte, 1>( {temp_memory_size}, h );

  h.parallel_for(
    sycl::nd_range<1>{ /*global_size = */ {256}, /*local_size = */ {256} },
    [=](sycl::nd_item<1> id) {
      auto ptr = acc.get_pointer() + id.get_group(0) * n;

      my_sycl::joint_sort(
        // create group helper using deduction guides
        my_sycl::group_with_scratchpad(
          id.get_group(),
          sycl::span{scratch.get_pointer(), temp_memory_size}
        ),
        ptr,
        ptr + n
      );
    });
  });
...
----

2.Using `sort_over_group` and `radix_sorter`

[source,c++]
----
...
namespace my_sycl = sycl::ext::oneapi::experimental;

sycl::range<1> local_range{256};
// predefine radix_sorter to calculate local memory size
using RSorter =
    my_sycl::radix_sorters::group_sorter<T, my_sycl::sorting_order::descending>;
// calculate required local memory size
size_t temp_memory_size =
    RSorter::memory_required(sycl::memory_scope::work_group, local_range.size());

q.submit([&](sycl::handler& h) {
  auto acc = sycl::accessor(buf, h);
  auto scratch = sycl::local_accessor<std::byte, 1>( {temp_memory_size}, h);

  h.parallel_for(
    sycl::nd_range<1>{ local_range, local_range },
    [=](sycl::nd_item<1> id) {

      acc[id.get_local_id()] =
        my_sycl::sort_over_group(
          id.get_group(),
          acc[id.get_local_id()],
          RSorter(sycl::span{scratch.get_pointer(), temp_memory_size})
      );
    });
  });
...

----

3.Using `joint_sort` for key-value sorting
(keys are compared, but keys and values are reordered both).

NOTE: `oneapi::dpl::zip_iterator` is used here.
See https://spec.oneapi.com/versions/latest/elements/oneDPL/source/index.html[
  oneDPL Spec]
for details.

[source,c++]
----
...
namespace my_sycl = sycl::ext::oneapi::experimental;
using TupleType =
      typename std::iterator_traits<oneapi::dpl::zip_iterator<T*, U*>>::value_type;
// calculate required local memory size
size_t temp_memory_size =
    my_sycl::default_sorters::joint_sorter<>::memory_required<TupleType>(
      d, sycl::memory_scope::work_group, n);

q.submit([&](sycl::handler& h) {
  auto keys_acc = sycl::accessor(keys_buf, h);
  auto vals_acc = sycl::accessor(vals_buf, h);
  auto scratch = sycl::local_accessor<std::byte, 1>( {temp_memory_size}, h);

  h.parallel_for(
    sycl::nd_range<1>{ /*global_size = */ {1024}, /*local_size = */ {256} },
    [=](sycl::nd_item<1> id) {
      size_t group_id = id.get_group(0);
      auto keys_ptr = keys_acc.get_pointer() + group_id * n;
      auto vals_ptr = vals_acc.get_pointer() + group_id * n;
      auto first = oneapi::dpl::make_zip_iterator(keys_ptr, vals_ptr);

      my_sycl::joint_sort(
        // create group excutor using deduction guides
        my_sycl::group_with_scratchpad(
          id.get_group(),
          sycl::span{scratch.get_pointer(), temp_memory_size}
        ),
        first,
        first + n,
        [](auto x, auto y){ return std::get<0>(x) < std::get<0>(y); }
      );
    });
  });
...
----

4.Using `sort_key_value_over_group` and `radix_sorter` with fixed-size arrays.

[source,c++]
----
...
namespace my_sycl = sycl::ext::oneapi::experimental;

sycl::range<1> local_range{256};
constexpr std::size_t ElementsPerWorkItem = 8;

// predefine radix_sorter to calculate local memory size
using RSorter =
    my_sycl::radix_sorters::group_key_value_sorter<T, T,
                                                   my_sycl::sorting_order::descending,
                                                   ElementsPerWorkItem>;
// calculate required local memory size
size_t temp_memory_size =
    RSorter::memory_required(sycl::memory_scope::work_group, local_range.size());

q.submit([&](sycl::handler& h) {
  auto keys_acc = sycl::accessor(keys_buf, h);
  auto vals_acc = sycl::accessor(vals_buf, h);
  auto scratch = sycl::local_accessor<std::byte, 1>( {temp_memory_size}, h);

  h.parallel_for(
    sycl::nd_range<1>{ local_range, local_range },
    [=](sycl::nd_item<1> id) {

      T keys_private[ElementsPerWorkItem];
      T vals_private[ElementsPerWorkItem];
      auto idx = id.get_global_id();
      for(std::size_t i = 0; i < ElementsPerWorkItem; ++i )
      {
        keys_private[i] = keys_acc[idx * ElementsPerWorkItem + i];
        vals_private[i] = vals_acc[idx * ElementsPerWorkItem + i];
      }

      my_sycl::sort_key_value_over_group(
        id.get_group(),
        sycl::span{keys_private},
        sycl::span{vals_private},
        RSorter(sycl::span{scratch.get_pointer(), temp_memory_size})
      );
      ...
    });
  });
...
----

== Issues

. It can be a separate proposal for key-value sorting basing on Projections.
It needs to be investigated what is the response for that.
. Sorter traits can be useful if there are Finder, Reducer or other objects
will be added to the Spec to be used with other Group algorithms,
e.g. find, reduce.
. Predefined sorters can be revisited to find a better interfaces
for `memory_required` overloads.
. `group_with_scratchpad` can be replaced with concepts that
requires 2 methods.
. Is Sorter needed to be applied to keys only or to keys and
values both in case of key-value sorting?
. Do we need to have separate predefined sorters for
fixed-size array interfaces?
e.g. instead of changing `default_sorter` and `radix_sorter`
to have new sorters `default_span_sorter`, `radix_span_sorter`.
. Will it be better to have an interface with `std::tuple` of `sycl::span`
to generalize key-value sorting? e.g.
`sort_over_group(group, std::make_tuple(sycl::span{keys}, sycl::span{values}), sorter);`
The thing is that tuple is not a span. It's better to have any _zip_span_
that allows the SoA data pattern. Interfaces without tuple highlights that
we have parameters with different meaning: only keys are comparing,
but keys and values are moving both. However, it can look like
inconsistent comparing to other interfaces of sorting.
. It can be a problem that users need to put the same `Compare` type during
calling `memory_required` function and the `default_sorter` constructor
because it's easy to pass different comparator types.
. Think about reducing overloads for sorting functions. The thing is that
overloads with `Compare` objects seems extra and overloads with sorters,
without sorters are enough.

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2021-04-28|Andrey Fedorov|Initial public working draft
|2|2021-09-15|Andrey Fedorov|Changes related to additional memory providing
|3|2021-12-16|Andrey Fedorov|Some refactoring, sections reordering,
making the entire extension experimental
|4|2022-11-14|Andrey Fedorov|Fixed size arrays, key-value sorting and properties
|5|2023-11-09|Andrey Fedorov|Changed `memory_required` functions for default sorters
|6|2024-07-17|Artur Gainullin|Align the description of data placement properties with the implementation
|========================================
