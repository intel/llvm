= sycl_ext_oneapi_async_memory_alloc

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]
:endnote: &#8212;{nbsp}end{nbsp}note

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2024 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 8 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:../experimental/sycl_ext_oneapi_properties.asciidoc[
  sycl_ext_oneapi_properties]
* link:../experimental/sycl_ext_oneapi_enqueue_functions.asciidoc[
  sycl_ext_oneapi_enqueue_functions]
* link:../supported/sycl_ext_oneapi_default_context.asciidoc[
  sycl_ext_oneapi_default_context]


== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*


== Backend support status

This extension is not yet implemented in {dpcpp}.

== Overview

This extension introduces an interface for allocating and freeing USM memory
asynchronously, as well as introducing a USM memory pool from which this memory
is allocated and freed from.

The asynchronous memory allocation and free are exposed via new free functions
taking a queue, which enqueue an asynchronous malloc or free command and return
immediately. The functions can take a memory pool object in order to allocate
from that memory pool specifically, however, if no memory pool object is
provided there is a default memory pool which will be used.

The memory pool introduced is a dynamic memory pool, as such memory is allocated
on demand. Alternatively a memory pool can be created with an existing USM
memory allocation provided by the user.

The immediate benefit of using the asynchronous malloc and free commands, as
opposed to the existing synchronous malloc and free functions, is that they are
enqueued to a queue. So applications which wish to allocate temporary USM
memory, but not carry around the pointer, no longer have to synchronize with the
execution of kernels accessing that memory and call the free function before
continuing.

A further benefit comes from the use of a memory pool for allocations, as
malloc and free commands are asynchronous, the runtime can opportunistically
re-use memory allocations from one kernel to another, without any intermediate
freeing and re-allocation. This benefit can be further extended beyond queue
synchronization by specifying a threshold, which will instruct the runtime to
(if possible) maintain a certain size of memory and not release that back to the
SYCL runtime or to the memory allocation provided by the user, even when the
queue is synchronized with.

There are also other properties which can be used when constructing a memory
pool object to control other aspects of how the memory is allocated.

== Integration with other extensions

It is a priority for this extension to integrate with the
link:../experimental/sycl_ext_oneapi_graph.asciidoc[
sycl_ext_oneapi_graph] extension. The asynchronous commands introduces in this
extension are intended to be compatible with the SYCL Graph record and replay
mode, however, the specifics of this will be defined in that extension.

It is a priority for this extension to integrate with the
link:../experimental/sycl_ext_oneapi_bindless_images.asciidoc[
sycl_ext_oneapi_bindless_images] extension. It is the intention that the memory
allocations from the memory pool in this extension be used for the bindless
images, however, this will need to be investigated further and so the details of
this are not included in this version of the extension.

== Examples

There are various ways in which this extension can be used but a typical usage
of the memory pool and the asynchronous malloc and free commands is described
below. In this example an explicit memory pool is created and this is used to
share memory allocated from the SYCL runtime between multiple asynchronous
malloc commands.

[source,c++]
----
namespace syclex = sycl::ext::oneapi::experimental;

int main(int argc, char *argv[])
{
  queue q(property::queue::in_order);

  syclex::memory_pool memPool(q.get_context(),
    q.get_device(), usm::alloc::device);
  
  {
    // memory pool allocates memory from the SYCL runtime
    void *temp = syclex::async_malloc_from_pool(q, 1024, memPool);

    // memory allocation is used for first kernel
    syclex::parallel_for(q, range{1024}, [=](id<1> idx) {
      do_something(idx, temp);
    });

    // memory is available to be used by another allocation
    syclex::async_free(q, temp);
  }

  {
    // memory pool re-uses previously allocated memory
    void *temp = syclex::async_malloc_from_pool(q, 1024, memPool);

    // memory allocation is used for second kernel
    syclex::parallel_for(q, range{1024}, [=](id<1> idx) {
      do_something_else(idx, temp);
    });

    // memory is available to be used by another allocation
    syclex::async_free(q, temp);
  }

  // memory pool releases memory back to the SYCL runtime
  q.wait();
}
----

The above example does not use SYCL events, so below is the same example using
an out-of-order SYCL queue and SYCL events to manage dependencies.

[source,c++]
----
namespace syclex = sycl::ext::oneapi::experimental;

int main(int argc, char *argv[])
{
  queue q;

  syclex::memory_pool memPool(q.get_context(),
    q.get_device(), usm::alloc::device);
  
  {
    void *temp = null;

    // memory pool allocates memory from the SYCL runtime
    auto e1 = syclex::submit_with_event(q, [&](handler &cgh) {
      temp = syclex::async_malloc_from_pool(cgh, 1024, memPool);
    });

    // memory allocation is used for first kernel
    auto e2 = syclex::submit_with_event(q, [&](handler &cgh) {
      cgh.depends_on(e1);
      syclex::parallel_for(cgh, range{1024}, [=](id<1> idx) {
        do_something(idx, temp);
      });
    });

    // memory is available to be used by another allocation
    auto e3 = syclex::submit_with_event(q, [&](handler &cgh) {
      cgh.depends_on(e2);
      syclex::async_free(cgh, temp);
    });
  }

  {
    void *temp = null;

    // memory pool re-uses previously allocated memory
    auto e4 = syclex::submit_with_event(q, [&](handler &cgh) {
      cgh.depends_on(e3);
      temp = syclex::async_malloc_from_pool(cgh, 1024, memPool);
    });

    // memory allocation is used for second kernel
    auto e5 = syclex::submit_with_event(q, [&](handler &cgh) {
      cgh.depends_on(e4);
      syclex::parallel_for(cgh, range{1024}, [=](id<1> idx) {
        do_something_else(idx, temp);
      });
    });

    // memory is available to be used by another allocation
    syclex::submit_with_event(q, [&](handler &cgh) {
      cgh.depends_on(e5);
      syclex::async_free(cgh, temp);
    });
  }

  // memory pool releases memory back to the SYCL runtime
  q.wait();
}
----

Another example of memory pool usage is described in the example below. In this
example rather than creating an explicit memory pool the default memory pool is
being used instead. There is also additional queue synchronization between the
commands enqueued which would ordinarily lead to memory being released back to
the SYCL runtime, however, the allocation threshold for the memory pool is
extended so the memory pool maintains the allocations and therefore still
provide the benefit of re-allocating memory from the memory pool.

[source,c++]
----
namespace syclex = sycl::ext::oneapi::experimental;

int main(int argc, char *argv[])
{
  queue q(property::queue::in_order);

  syclex::memory_pool memPool
    = q.get_context().ext_oneapi_get_default_memory_pool(
        q.get_device(), usm::alloc::device);

  memPool.set_new_threshold(1024);
  
  {
    // memory pool allocates memory from the SYCL runtime
    void *temp = syclex::async_malloc_from_pool(q, 1024, memPool);

    // memory allocation is used for first kernel
    syclex::parallel_for(q, range{1024}, [=](id<1> idx) {
      do_something(idx, temp);
    });

    // memory is available to be used by another allocation
    syclex::async_free(q, temp);
  }

  // memory pool does not release memory back to the SYCL runtime as it is still
  // within the specified threshold
  q.wait();

  {
    // memory pool re-uses previously allocated memory
    void *temp = syclex::async_malloc_from_pool(q, 1024, memPool);

    // memory allocation is used for second kernel
    syclex::parallel_for(q, range{1024}, [=](id<1> idx) {
      do_something_else(idx, temp);
    });

    // memory is available to be used by another allocation
    syclex::async_free(q, temp);
  }

  // again memory pool does not release memory back to the SYCL runtime
  q.wait();
}
----


== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.  An implementation supporting this extension must predefine the
macro `SYCL_EXT_ONEAPI_ASYNC_MEMORY_ALLOC` to one of the values defined in the
table below.  Applications can test for the existence of this macro to determine
if the implementation supports this feature, or applications can test the
macro's value to determine which of the extension's features the implementation
supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===

=== Memory pool

This extension introduces the memory pool, a dynamically allocated pool of
memory, which can be allocated from and freed back to via asynchronous malloc
and free commands. The `memory_pool` class provides an interface to a memory
pool, and adheres to the SYCL common reference semantics.

A memory pool has a number of properties and state which dictate it's behavior:

* A memory pool has an *allocation chunk size* (in bytes) which dictates the
  minimum chunk of memory which can be allocated to the pool, such that all
  allocations are a multiple of this value. The allocation chunk size is a
  property of the device the memory pool is associated with and is static.
* A memory pool has a *maximum size* (in bytes) which dictates the total amount
  of memory which can be allocated to the pool, such that if an allocation would
  exceed this value an error is thrown. The default maximum size is
  implementation defined.
* A memory pool has a *threshold size* (in bytes) which dictates an amount of
  the user would like the SYCL runtime to maintain in the pool, even when not
  allocated out to a USM pointer. The threshold size is a hint, and so an
  implementation should try to maintain memory in the pool to this value, but it
  is not required to do so. The default threshold size is `0`.
* A memory pool has a *current size* (in bytes) which tracks the total memory
  which is allocated to the pool.
* A memory pool has a *free size* (in bytes) which tracks the amount of the
  free memory; total memory which has not been allocated to a USM pointer, and
  is still available to be allocated.
* A memory pool has a *allocation kind* which is a value of `usm::alloc` which
  dictates the type of USM memory that is allocated to the pool.
* A memory pool is associated with a context and one or more device(s),
  depending on the allocation kind.

A memory pool and the asynchronous malloc and free commands which interact with
them adhere to the following behaviors:

* When an asynchronous malloc command is enqueued a valid USM pointer of the
  allocation kind is returned immediately. The asynchronous malloc command may
  execute any time between the command being enqueued and the command being
  synchronized with. The pointer returned is not valid until the asynchronous
  malloc command has completed.
* When an asynchronous malloc command executes it will allocate USM memory of
  the allocation kind from the memory pool.
* When a USM pointer is being allocated from the memory pool, it may allocate
  from free memory in the pool, including memory which was previously allocated
  to a USM pointer and has been freed or it may opportunistically re-use memory
  allocated to an existing USM pointer, for which an asynchronous free command
  has been enqueued to free, and that the asynchronous malloc command is
  dependent on.
* Additional memory can be allocated to the memory pool when required for an
  asynchronous malloc command or otherwise. Allocations to the pool must be in a
  multiple of the allocation chunk size.
* When an asynchronous free command is enqueued, the USM pointer to be freed is
  immediately no longer valid. The asynchronous free command may execute any
  time between the command being enqueued and the command being synchronized
  with. Once the asynchronous free command is enqueued memory allocated to that
  USM pointer is now free for the memory pool to re-allocate to another USM
  pointer either once the command has completed, or if an asynchronous command
  is dependent on this asynchronous free command.
* The memory pool will not release memory in the pool that is currently
  allocated to a USM pointer, however, it may release any free memory in the
  pool. When the memory pool releases memory from the pool, this is done so in
  multiples of the allocation chunk size.
* The memory pool should try to maintain an amount of memory in the pool
  set by the threshold size in order to better facilitate re-use of the memory
  between subsequent asynchronous malloc commends, however, it is not required
  to.
* The amount of total and free memory reported by the memory pool is updated
  immediately after returning from calls to enqueue asynchronous malloc and free
  commands, even if the command does not execute immediately.
* If the memory is not constructed from a user provided memory allocation, when
  the threshold size of the memory pool is set, the value specified will round
  down to the nearest multiple of the allocation chunk size and the memory pool
  will immediately start using this new size.
* When the maximum size of the memory pool is set, the value specified will
  round up to the nearest multiple of the allocation chunk size.

Memory pools are intended to be used for both in-order and out-of-order SYCL
queues.

[source,c++]
----
namespace ext::oneapi::experimental {

class memory_pool {

  template <typename Properties = empty_properties_t>
  memory_pool(context ctx, Properties props = {});

  template <typename Properties = empty_properties_t>
  memory_pool(context ctx, device dev, usm::alloc kind, Properties props = {});

  template <typename Properties = empty_properties_t>
  memory_pool(queue q, usm::alloc kind, Properties props = {});

  template <typename Properties = empty_properties_t>
  memory_pool(context ctx, void *ptr, size_t size, Properties props = {});

  ~memory_pool();

  context get_context() const;

  device get_device() const;

  usm::alloc get_alloc_kind() const;

  size_t get_allocation_chunk_size() const;

  size_t get_max_size() const;

  size_t get_threshold() const;

  size_t get_current_size() const;

  size_t get_free_size() const;

  void set_new_threshold(size_t newThreshold);

}; // memory_pool

}  // ext::oneapi::experimental
----

[source, c++]
----
template <typename Properties = empty_properties_t>
memory_pool(context ctx, Properties props = {});
----

_Effects_: Constructs a memory pool which is associated with the context `ctx`
and all SYCL devices associated with it, with the allocation kind
`usm::alloc::host` and applying any properties in `props`.

[source, c++]
----
template <typename Properties = empty_properties_t>
memory_pool(context ctx, device dev, usm::alloc kind, Properties props = {});
----

_Effects_: Constructs a memory pool which is associated with the context `ctx`
and device `dev`, with the allocation kind `kind` and applying any properties in
`props`.

_Throws_: An exception with the `errc::invalid` error code if `kind` is
`usm::alloc::host`.

[source, c++]
----
template <typename Properties = empty_properties_t>
memory_pool(queue q, usm::alloc kind, Properties props = {});
----

_Effects_: Constructs a memory pool which is associated with the context and
device from the queue `q``, with the allocation kind `kind` and applying any
properties in `props`. If `kind` is `usm::alloc::host` this is equivalent to
calling `memory_pool(queue.get_context(), props)` otherwise this is equivalent
to calling `memory_pool(queue.get_context(), queue.get_device(), props)`.

[source, c++]
----
template <typename Properties = empty_properties_t>
memory_pool(context ctx, void *ptr, size_t size, Properties props = {});
----

_Effects_: Constructs a memory pool which is associated with context `ctx`, 
uses an existing USM memory allocation `ptr` of size (in bytes) `size`,
and applying any properties in `props`. The memory pool will use the existing
USM memory allocation instead of allocating from the SYCL runtime. The
associated device and allocation kind of the memory pool is inferred from the
`ptr`. If `ptr` is not a valid USM pointer of kind `usm::alloc::host`,
`usm::alloc::device` or `usm::alloc::shared` or the value `size` does not match
the size of memory allocated for `ptr` the result is undefined behavior. If
`ptr` is freed or the memory it points to is written to whilst the memory pool
is still alive the result is undefined behavior. The maximum size and initial
threshold of the memory pool are set to `size`.

_Throws_: An exception with the `errc::invalid` error code if `props` contains
the `maximum_size` or `initial_threshold` properties.


[source, c++]
----
~memory_pool();
----

_Effects_: If this was the last copy, signals to the SYCL runtime for the memory
pool to be destroyed after all remaining allocations have been freed, and
returns immediately without waiting.

[source, c++]
----
context get_context() const;
----

_Returns_: The SYCL context associated with the memory pool.

[source, c++]
----
device get_device() const;
----

_Returns_: The SYCL device associated with the memory pool. If the memory pool
allocates memory of kind `usm::alloc::device` or `usm::alloc::host::shared` the
device returned is the same device which was passed when constructing the memory
pool. If the memory pool allocates memory of kind `usm::alloc::host` the device
returned is the first of the devices associated with the context, which is
associated with the memory pool.

[source, c++]
----
usm::alloc get_alloc_kind() const;
----

_Returns_: The memory allocation kind of the memory pool.

[source, c++]
----
size_t get_allocation_chunk_size() const;
----

_Returns_: The allocation chunk size of the device associated with the memory
pool.

[source, c++]
----
size_t get_max_size() const;
----

_Returns_: The maximum size of the memory pool.

[source, c++]
----
size_t get_threshold() const;
----

_Returns_: The deallocation threshold of the memory pool.

[source, c++]
----
size_t get_current_size() const;
----

_Returns_: The total memory allocated to the pool at the point the function is
called.

[source, c++]
----
size_t get_free_size() const;
----

_Returns_: The total free memory in the pool at the point the function is
called.

[source, c++]
----
void set_new_threshold(size_t newThreshold);
----

_Effects_: Sets the deallocation threshold of the memory pool if the value of
`newThreshold` is larger than the current threshold. If `newThreshold` is not a
multiple of the allocation chunk size, the new threshold is rounded down to the
nearest multiple.

_Throws_: An exception with the `errc::invalid` error code if the value of
`newThreshold` is lower than the current threshold or larger than the maximum
allocation size.


=== Memory pool properties

A memory pool can be constructed with a number of properties which can change
certain behaviors, these can be specified when constructing a `memory_pool`
object.

[source,c++]
----
namespace ext::oneapi::experimental {

struct initial_threshold {
  initial_threshold(size_t initialThreshold);
};

using initial_threshold_key = initial_threshold;

struct maximum_size {
  maximum_size(size_t maxSize);
};

using maximum_size_key = maximum_size;

struct read_only {
  read_only();
};

using read_only_key = read_only;

struct zero_init {
  zero_init();
};

using zero_init_key = zero_init;

}  // ext::oneapi::experimental
----

|===
|Property|Description

|`initial_threshold`
|The `initial_threshold` property specifies the initial deallocation threshold
 value for the memory pool. If this property is not used the default value is
 zero, and this can be increased after the memory pool is created by calling
 `memory_pool::set_new_threshold`.

|`maximum_size`
|The `maximum_size` property specifies the maximum size of the memory pool,
 after which any allocation will result in an exception. If the value specified
 is not a multiple of the allocation chunk size, the value is rounded up to the
 nearest multiple. If the value specified is larger than the implementation can
 support an exception with the `errc::memory_allocation` error code is thrown.
 If this property is not used the default value is implementation-defined.

|`read_only`
|The `read_only` property is a performance hint which asserts that all memory
 allocations from the memory pool will only ever be read from within SYCL kernel
 functions, this can be used by the SYCL runtime to optimize for performance.

|`zero_init`
|The `zero_init` property adds the requirement that all memory allocated to the
 memory as it is allocated to the memory pool will be initialised to zero. Note
 there is no guarantee that the memory allocation be re-initialized to zero when
 it is re-allocated from the pool, so users must re-initialize memory to zero if
 they wish for later allocations to have this behavior.

|===


=== Default memory pools

As well as being able to construct a memory pool explicitly, this extension
introduces a default memory pool per device for each SYCL context and device
pair for device allocations and a default memory pool per context for host
allocations.

New member functions are added to the `context` class to retrieve the default
memory pool as a copy of the `memory_pool` object. This can be modified and have
those modifications reflected as it conforms to the SYCL common reference
semantics.

[source,c++]
----
class context {

  memory_pool context::ext_oneapi_get_default_memory_pool() const;

  memory_pool context::ext_oneapi_get_default_memory_pool(device dev,
    usm::alloc kind) const;

}; // context
----

[source, c++]
----
memory_pool context::ext_oneapi_get_default_memory_pool() const;
----

_Returns_: The default memory pool associated with the context for allocating
with the allocation kind `usm::alloc::host`.

[source, c++]
----
memory_pool context::ext_oneapi_get_default_memory_pool(device dev,
  usm::alloc kind) const;
----

_Returns_: The default memory pool associated with the context and `dev` for
allocating with the allocations of kind `kind`.

_Throws_: An exception with the `errc::invalid` error code if `kind` is
`usm::alloc::host`.


=== Asynchronous malloc & free

This extension introduces a series of new enqueue functions for enqueueing
asynchronous malloc and free commands which operate with the memory pools also
introduced in this extension.

All enqueue functions introduced have overloads which take a SYCL `queue` and a
SYCL `handler`. None of enqueue functions return a SYCL `event` directly, as
this extension is in line with the
link:../experimental/sycl_ext_oneapi_enqueue_functions.asciidoc[
  sycl_ext_oneapi_enqueue_functions] extension, so events are returned when
calling `submit_with_event` and the `handler` overloads of these enqueue
functions.

[source,c++]
----
namespace ext::oneapi::experimental {

void *async_malloc(queue q, usm::alloc kind, size_t size);

void *async_malloc(handler h, usm::alloc kind, size_t size);

void *async_malloc_from_pool(queue q, size_t size, memory_pool pool);

void *async_malloc_from_pool(handler h, size_t size, memory_pool pool);

void async_free(queue q, void *ptr);

void async_free(handler h, void *ptr);

}  // ext::oneapi::experimental
----

[source, c++]
----
void *async_malloc(queue q, usm::alloc kind, size_t size);

void *async_malloc(handler h, usm::alloc kind, size_t size);

void *async_malloc_from_pool(queue q, size_t size, memory_pool pool);

void *async_malloc_from_pool(handler h, size_t size, memory_pool pool);
----

_Effects_: Enqueues a command to `q` or the SYCL queue associated with `h` which
will asynchronously allocate memory of size `size` in bytes, allocating from the
memory pool `pool` if provided, otherwise allocation from the default memory
pool associated with the SYCL context and device associated with `q` or `h`.
If a memory pool `pool` is provided the allocation kind is that of the memory
pool, otherwise if an allocation kind `kind` parameter is provided, this is the
allocation kind which is used. If a memory pool `pool` is provided, this must be
associated with the same SYCL context and device as `q` or the SYCL queue
associated with `h`. Memory can either be allocated directly from the memory
pool or allocated to the memory pool to provide enough memory in the memory pool
for the allocation. Accessing the memory at the address of the pointer returned
by asynchronous malloc functions before the command has completed execution is
undefined behavior.

_Returns_: A pointer to the address of a memory reservation if `size` is
non-zero, otherwise returns `nullptr`.

_Throws_: An exception with the `errc::memory_allocation` error code if the
allocation brings the memory pool over the maximum size. This error must be
thrown asynchronously.

[source, c++]
----
void async_free(queue q, void *ptr);

void async_free(handler h, void *ptr);
----

_Effects_: Enqueues a command to `q` or the SYCL queue associated with `h` which
will asynchronously free the memory allocation at the address of `ptr`. Memory
will be freed from the memory pool to be used by other asynchronous malloc
commands which execute later, and will not free until the SYCL queue associated
with the asynchronous allocation command has been synchronized with. Accessing
the memory at the address of `ptr` after the asynchronous free command has
completed execution is undefined behavior. If `ptr` is not the address of a
memory allocation allocated to a memory pool this is undefined behavior. 


== Implementation notes

It is expected that for L0 this extension will be implemented within the L0
adapter, by reserving allocations for the memory pool and opportunistically
re-using the memory allocated based on the command lists being enqueued to the
L0 driver.

It is expected that for CUDA this extension will be implemented by mapping onto
the CUDA stream-ordered allocator feature.


== Issues

. Should we allow mixing asynchronous and synchronous memory commands?
+
--
*UNRESOLVED*: CUDA allows memory allocated with the asynchronous malloc command
to be freed with the regular synchronous free command, should we extend this
capability to SYCL?
--

. Should we allow freeing memory with a different queue?
+
--
*UNRESOLVED*: Should we allow a memory allocation allocated with an asynchronous
malloc command from one queue to be freed by an asynchronous free command from
another queue?
--

. Should we allow setting a new threshold that is lower?
+
--
*UNRESOLVED*: Currently setting a new deallocation threshold is only permitted
if it increases the size of the threshold, however, we may want to also allow
setting a new lower threshold. This would work by not immediately freeing any
memory but using this lower threshold at the next synchronization point.
--
