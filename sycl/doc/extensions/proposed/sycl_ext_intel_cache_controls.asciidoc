= sycl_ext_intel_cache_controls

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2023-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 7 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

This extension depends on the following SYCL extensions:

* link:../experimental/sycl_ext_oneapi_properties.asciidoc[sycl_ext_oneapi_properties]
* link:../experimental/sycl_ext_oneapi_annotated_ptr.asciidoc[sycl_ext_oneapi_annotated_ptr]



== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*


== Overview

This extension introduces additional compile-time properties for
the `sycl::ext::oneapi::experimental::annotated_ptr` class to specify
cache control information.

The cache controls are a strong request that memory accesses through the
pointer should use instructions with the specified cache controls.
However, the implementation may choose a different cache control or none
if the requested one is unsupported or for any other reason.


== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.  An implementation supporting this extension must predefine the
macro `SYCL_EXT_INTEL_CACHE_CONTROLS` to one of the values defined in the table
below.  Applications can test for the existence of this macro to determine if
the implementation supports this feature, or applications can test the macro's
value to determine which of the extension's features the implementation
supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===

=== Properties

Below is a list of new compile-time constant properties supported with
`annotated_ptr`.

```c++
namespace sycl::ext {
namespace intel::experimental {

enum class cache_mode {
  uncached,
  cached,
  streaming,
  invalidate,
  constant,
  write_through,
  write_back
};
using cache_mode = sycl::ext::intel::experimental::cache_mode;
using cache_level = sycl::ext::oneapi::experimental::cache_level;

template <cache_mode M, cache_level... Ls> struct cache_control {};

struct read_hint_key {
  template <typename... Cs>
  using value_t = property_value<read_hint_key, Cs...>;
};

struct read_assertion_key {
  template <typename... Cs>
  using value_t = property_value<read_assertion_key, Cs...>;
};

struct write_hint_key {
  template <typename... Cs>
  using value_t = property_value<write_hint_key, Cs...>;
};

template <typename... Cs>
inline constexpr read_hint_key::value_t<Cs...> read_hint;

template <typename... Cs>
inline constexpr read_assertion_key::value_t<Cs...> read_assertion;

template <typename... Cs>
inline constexpr write_hint_key::value_t<Cs...> write_hint;

} // namespace intel::experimental

namespace oneapi {
namespace experimental {

using read_hint_key = intel::experimental::read_hint_key;
template <> struct is_property_key<read_hint_key> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<read_hint_key, annotated_arg<T, PropertyListT>>
    : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<read_hint_key, annotated_ptr<T, PropertyListT>>
    : std::true_type {};

using read_assertion_key = intel::experimental::read_assertion_key;
template <> struct is_property_key<read_assertion_key> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<read_assertion_key, annotated_arg<T, PropertyListT>>
    : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<read_assertion_key, annotated_ptr<T, PropertyListT>>
    : std::true_type {};

using write_hint_key = intel::experimental::write_hint_key;
template <> struct is_property_key<write_hint_key> : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<write_hint_key, annotated_arg<T, PropertyListT>>
    : std::true_type {};
template <typename T, typename PropertyListT>
struct is_property_key_of<write_hint_key, annotated_ptr<T, PropertyListT>>
    : std::true_type {};

} // namespace sycl::ext::oneapi::experimental
```
Each of these properties takes a `cache_control` parameter.
The `cache_control` parameter consists of a `cache_mode`
and a list of `cache_level` parameters the mode applies to.
Cache level `L1` indicates the cache closest to the processing unit,
cache level `L2` indicates the next furthest cache level, etc.
It is legal to specify a `cache_level` that does not exist on
the target device, but the property will be ignored in this case.

The cache control properties are divided into two categories: those that
are hints and those that are assertions by the application.

==== Cache control hints
These properties are hints requesting specific cache behavior when
loading or storing to memory through the `annotated_ptr`. These properties can
affect the performance of device code, but they do not change the semantics.

--
[options="header", cols="2,1"]
|====
| Property | Description
a|
[source]
----
read_hint<cache_control<cache_mode::uncached, Ls...>>
----
|
This property requests that loads from memory through the `annotated_ptr`
should not cache the data at levels `Ls` in the memory hierarchy.
a|
[source]
----
read_hint<cache_control<cache_mode::cached, Ls...>>
----
|
This property requests that loads from memory through the `annotated_ptr`
may cache the data at levels `Ls` in the memory hierarchy.
a|
[source]
----
read_hint<cache_control<cache_mode::streaming, Ls...>>
----
|
This property requests that loads from memory through the `annotated_ptr`
should cache the data at cache levels `Ls`. The eviction policy is to give
lower priority to data cached using this property versus the `cached`
property.
a|
[source]
----
write_hint<cache_control<cache_mode::uncached, Ls...>>
----
|
This property requests that writes to memory through the `annotated_ptr`
should not cache the data at levels `Ls` in the memory hierarchy.
a|
[source]
----
write_hint<cache_control<cache_mode::write_through, Ls...>>
----
|
This property requests that writes to memory through the `annotated_ptr`
should immediately write the data to the next-level cache after `Ls`
and mark the cache line at levels `Ls` as "not dirty".
a|
[source]
----
write_hint<cache_control<cache_mode::write_back, Ls...>>
----
|
This property requests that writes to memory through the `annotated_ptr`
should write the data into the cache at levels `Ls` and mark the cache line as
"dirty". Upon eviction, "dirty" data will be written into the cache at
level higher than `Ls`.
a|
[source]
----
write_hint<cache_control<cache_mode::streaming, Ls...>>
----
|
This property is the same as `write_through`, but requests use of a
policy that gives lower priority to data in the cache present
via a `streaming` cache control.
|====
--

==== Assertions by the application
These properties are assertions by the application, promising that the
application accesses memory in a certain way. Care must be taken when
using these properties because they can lead to undefined behavior if
they are misused.

--
[options="header", cols="3,1"]
|====
| Property | Description
a|
[source]
----
read_assertion<cache_control<cache_mode::invalidate, Ls...>>
----
|
This property asserts that the cache line into which data is loaded
from memory through the `annotated_ptr` will not be read again
until it is overwritten. Therefore the load operation can invalidate
the cache line and discard "dirty" data. If the assertion is violated 
(i.e., the cache line is read again) then the behavior is undefined.
a|
[source]
----
read_assertion<cache_control<cache_mode::constant, Ls...>>
----
|
This property asserts that the cache line containing the data
loaded from memory through the `annotated_ptr` will not be written
until kernel execution is completed.
If the assertion is violated (the cache line is written), the behavior
is undefined.
|====
--


It is legal to specify several different `cache_control` properties in the
same `annotated_ptr`. However, at any cache level there should be at most
one `cache_mode` of `read_hint` or `read_assertion` type
and at most one of `write_hint` type.
