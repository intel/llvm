= sycl_ext_intel_cache_controls

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2023-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 7 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

This extension depends on the following SYCL extensions:

* link:../experimental/sycl_ext_oneapi_properties.asciidoc[sycl_ext_oneapi_properties]
* link:../experimental/sycl_ext_oneapi_annotated_ptr.asciidoc[sycl_ext_oneapi_annotated_ptr]

This extension also depends on the following SPIR-V extension:

* link:../supported/sycl_ext_oneapi_myotherextension.asciidoc[SPV_INTEL_cache_controls]


== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*


== Backend support status

This extension is not implemented.

== Overview

This extension introduces additional compile-time properties for
the proposed `sycl::ext::oneapi::experimental::annotated_ptr` class to specify
cache control information.

The cache controls are a strong request that memory accesses through the
pointer should use instructions with the specified cache controls.
However, the implementation may choose a different cache control or none
if the requested one is unsupported or for any other reason.


== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.  An implementation supporting this extension must predefine the
macro `SYCL_EXT_INTEL_CACHE_CONTROLS` to one of the values defined in the table
below.  Applications can test for the existence of this macro to determine if
the implementation supports this feature, or applications can test the macro's
value to determine which of the extension's features the implementation
supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===

=== Properties

Below is a list of new compile-time constant properties supported with
`annotated_ptr`.

```c++
namespace sycl::ext::intel::experimental {

enum cache_control_types_read {
    Cached, Uncached, Streaming, InvalidateAfterRead, ConstCached};
enum cache_control_types_write {
    Uncached, Streaming, WriteThrough, WriteBack};

struct cache_control_read {
  template<enum cache_control_types_read, int L>
  using value_t = property_value<cache_control_read, enum control, std::integral_constant<int, L>>;
};
struct cache_control_write {
  template<enum cache_control_types_write, int L>
  using value_t = property_value<cache_control_write, enum control, std::integral_constant<int, L>>;
};

template<cache_control_types_read C, int L>
inline constexpr cache_control_read::value_t<C, K> read_control;
template<cache_control_types_write C, int L>
inline constexpr cache_control_write::value_t<C, K> write_control;

template<>
struct is_property<cache_control_read> : std::true_type {};
template<>
struct is_property<cache_control_write> : std::true_type {};

template<typename T, typename PropertyListT>
struct is_property_of<
  cache_control_read, annotated_ptr<T, PropertyListT>> : std::true_type {};
template<typename T, typename PropertyListT>
struct is_property_of<
  cache_control_write, annotated_ptr<T, PropertyListT>> : std::true_type {};

template<typename T, typename PropertyListT>
} // namespace sycl::ext::intel::experimental
```
--
[options="header"]
|====
| Property | Description
|`cache_control_read<Cached, L>`
|
This property requests that loads from memory through the `annotated_ptr`
may cache the data at level L in the memory hierarchy.
|`cache_control_read<UnCached, L>`
|
This property requests that loads from memory through the `annotated_ptr`
should not cache the data at level L in the memory hierarchy.
|`cache_control_read<Streaming, L>`
|
This property requests that loads from memory through the `annotated_ptr`
should cache the data at cache level L. The eviction policy is to give
lower priority to data cached using this property versus the Cached
property.
|`cache_control_read<InvalidateAfterRead, L>`
|
This property asserts that the cache line into which data is loaded
from memory through the `annotated_ptr` will not be read again
until it is overwritten. Therefore the load operation can invalidate
the cache line and discard "dirty" data. If the assertion is violated 
(i.e., the cache line is read again) then the behavior is undefined.
|`cache_control_read<ConstCached, L>`
|
This property asserts that the cache line containing the data
loaded from memory through the `annotated_ptr` will not be written
until kernel execution is completed.
If the assertion is violated (the cache line is written), the behavior
is undefined.
|`cache_control_write<UnCached, L>`
|
This property requests that writes to memory through the `annotated_ptr`
should not cache the data at level L in the memory hierarchy.
|`cache_control_write<WriteThrough, L>`
|
This property requests that writes to memory through the `annotated_ptr`
should immediately write the data to the next-level cache after L
and mark the cache line at level L as "not dirty".
|`cache_control_write<WriteBack, L>`
|
This property requests that writes to memory through the `annotated_ptr`
should write the data into the cache at level L and mark the cache line as
"dirty". Upon eviction, "dirty" data will be written into the cache at
level higher than L.
|`cache_control_write<Streaming, L>`
|
This property is the same as `WriteThrough`, but requests use of a
policy that gives lower priority to data in the cache present
via a `Streaming` cache control.
|====
--

== Implementation notes

It is intended that the SYCL cache control properties will be used by the compiler
to generate SPIR-V cache control operations.

