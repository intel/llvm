= sycl_ext_oneapi_group_load_store

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]
:language: {basebackend@docbook:c++:cpp}

== Introduction

IMPORTANT: This specification is a draft.


== Notice

[%hardbreaks]
Copyright (c) 2022 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.

== Dependencies

This extension is written against the SYCL 2020 specification, Revision 6.
All references below to the "core SYCL specification" or to section numbers in
the SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/proposed/sycl_ext_oneapi_group_sort.asciidoc[
  sycl_ext_oneapi_group_sort] (`group_with_scratchpad` class used as GroupHelper).

* link:../experimental/sycl_ext_oneapi_properties.asciidoc[
  sycl_ext_oneapi_properties].

== Overview

This extension defines free functions for load/store operations within work
group scope.

== Single Value Functions

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

// Load API scalar
template<typename Group, typename InputIteratorT,
         typename OutputT, typename Properties = properties<>>
void group_load(Group g, InputIteratorT in_ptr,
                      OutputT& out, Properties = {}); // (1)

// Store API scalar
template<typename Group, typename InputT,
         typename OutputIteratorT, typename Properties = properties<>>
void group_store(Group g, const InputT& in,
                      OutputIteratorT out_ptr, Properties = {}); // (2)

}
----

(1) _Preconditions_: `in_ptr` must be the same for all work-items
in the group.

._Constraints_:
* Only available if `Group` is a work-group or sub-group.
* `InputIteratorT` suppose to be a random access iterator.
* Value type of `InputIteratorT` must be convertible to OutputT.

_Effects_: Loads single element from `in_ptr` to `out` by using the `g` group
object to identify memory location as `in_ptr` + `g.get_local_id()`.

`Properties` argument is reserved for future revisions of this extention and is
ignored now. Default value is empty `sycl::ext::oneapi::experimental::properties<>`
May be used in future for setting boundary values or limiting numbers of work items.

(2) _Preconditions_: `out_ptr` must be the same for all work-items
in the group.

._Constraints_:
* Only available if `Group` is a work-group or sub-group.
* `OutputIteratorT` suppose to be a random access iterator.
* InputT must be convertible to value type of `OutputIteratorT`.

_Effects_: Stores single element `in` to `out_ptr` by using the `g` group
object to identify memory location as `out_ptr` + `g.get_local_id()`

`Properties` argument is reserved for future revisions of this extention and is
ignored now. Default value is empty `sycl::ext::oneapi::experimental::properties<>`
May be used in future for setting boundary values or limiting numbers of work items.

== `sycl::vec` Functions

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

// Load API sycl::vec overload
template<typename Group, typename InputIteratorT,
         typename OutputT, int N, typename Properties = properties<>>
void group_load(Group g, InputIteratorT in_ptr,
                      sycl::vec<OutputT, N>& out, Properties = {}); // (3)

// Store API sycl::vec overload
template<typename Group, typename InputT, int N,
         typename OutputIteratorT, typename Properties = properties<>>
void group_store(Group g, const sycl::vec<InputT, N>& in,
                      OutputIteratorT out_ptr, Properties = {}); // (4)
}
----

(3) _Preconditions_: `in_ptr` must be the same for all work-items
in the group.

._Constraints_:
* Only available if `Group` is a work-group or sub-group.
* `InputIteratorT` suppose to be a random access iterator.
* value type of `InputIteratorT` and OutputT types must be convertible basic
scalar types supported in device code.

_Effects_: Loads `N` elements from `in_ptr` to `out`
using the `g` group object.
Properties may specify xref:data_placement[data placement].
Default data placement is a blocked one:
`out[i]` = `in_ptr[g.get_local_id() * N + i];`
in striped case:
`out[i]` = `in_ptr[g.get_local_id() + g.get_max_local_range() * i];`
for `i` between `0` and `N`.

(4) _Preconditions_: `out_ptr` must be the same for all work-items
in the group.

._Constraints_:
* Only available if `Group` is a work-group or sub-group.
* `OutputIteratorT` suppose to be a random access iterator.
* value type of `OutputIteratorT` and InputT types must be convertible basic
scalar types supported in device code.

_Effects_: Stores `N` elements from `in` vec to `out_ptr`
using the `g` group object.
Properties may specify xref:data_placement[data placement].
Default placement is a blocked one:
`out_ptr[g.get_local_id() * N + i]` = `in[i];`
in striped case:
`out_ptr[g.get_local_id() + g.get_max_local_range() * i]` = `in[i];`
for `i` between `0` and `N`.

== Functions with fixed-size arrays

This API provides the following features:

* load/store with temporary memory buffer, which can be passed via GroupHelper
such as `group_with_scratchpad` link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/proposed/sycl_ext_oneapi_group_sort.asciidoc#group-helper[group_with_scratchpad description from sort over group proposal]

* load/store flexible amount of elements per work item as sycl::span

* specify data placement type via properties (6) or extra options such as
setting boundary values or limiting numbers of work items (TODO in design
considerations)

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

// Load API
template<typename GroupHelper, typename InputIteratorT, typename OutputT,
        std::size_t ElementsPerWorkItem, typename Properties = properties<>>
void group_load(GroupHelper gh, InputIteratorT in_ptr,
                sycl::span<OutputT, ElementsPerWorkItem> out, Properties = {}); // (6)


// Store API
template<typename GroupHelper, typename OutputIteratorT, typename InputT,
        std::size_t ElementsPerWorkItem, typename Properties = properties<>>
void group_store(GroupHelper gh, sycl::span<InputT, ItemsPerWorkItem> in,
                 OutputIteratorT out_ptr,  Properties = {}); // (7)


// Support memory function to define the needed amount of temporary memory
// needed (name TBD)

template<typename T, std::size_t ElementsPerWorkItem>
constexpr std::size_t memory_required(sycl::memory_scope scope,
                                      std::size_t block_size); // (8)

}
----

.(6) _Preconditions_:
* `in_ptr` must be the same for all work-items in the group.
* `out` must be a `sycl::span` made from a pointer to the private memory space.

._Constraints_:
* Only available if `GroupHelper` is a
work-group or sub-group or `GroupHelper` was created with a
work-group or sub-group and some associated scratch space
(link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/proposed/sycl_ext_oneapi_group_sort.asciidoc[`group_with_scratchpad`]).
* `InputIteratorT` suppose to be a random access iterator.
* Value type of `InputIteratorT` must be convertible to OutputT.

_Effects_: Loads `ElementsPerWorkItem` elements from `in_ptr` to `out`
using the `gh` group helper object.
Properties may specify xref:data_placement[data placement].
Default placement is a blocked one:
`out[i]` = `in_ptr[gh.get_local_id() * ElementsPerWorkItem + i];`
in striped case:
`out[i]` = `in_ptr[gh.get_local_id() + gh.get_max_local_range() * i];`
for `i` between `0` and `ElementsPerWorkItem`.

.(7) _Preconditions_:
* `out_ptr` must be the same for all work-items in the group.
* `in` must be a `sycl::span` made from a pointer to the private memory space.

._Constraints_:
* Only available if `GroupHelper` is a
work-group or sub-group or `GroupHelper` was created with a
work-group or sub-group and some associated scratch space
(link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/proposed/sycl_ext_oneapi_group_sort.asciidoc[`group_with_scratchpad`]).
* `OutputIteratorT` suppose to be a random access iterator.
* InputT must be convertible to value type of `OutputIteratorT`.

_Effects_: Stores `ElementsPerWorkItem` elements from `in` span to `out_ptr`
using the `gh` group helper object.

Properties may specify xref:data_placement[data placement].
Default placement is a blocked one:
`out_ptr[gh.get_local_id() * ItemsPerWorkItem + i]` = `in[i];`
in striped case:
`out_ptr[gh.get_local_id() + gh.get_max_local_range() * i]` = `in[i];`
for `i` between `0` and `ItemsPerWorkItem`.

(8)_Effects_: Returns size of temporary memory (in bytes) that is required for
scratch space in `GroupHelper`. Result depends on type `T`, `ElementsPerWorkItem`
and the scope parameter: use sycl::memory_scope::work_group to get memory size
required for each work-group; use sycl::memory_scope::sub_group to get memory
size required for each sub-group. If other scope values are passed, behavior is
unspecified.

== Data placement

anchor:data_placement[]

To specify a correct data placement for placing of resulting data
there is a enum (proposed in link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/proposed/sycl_ext_oneapi_group_sort.asciidoc[`group_sort extention`]):

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

// Properties:
enum class group_algorithm_data_placement {
  blocked,
  striped
};

}
----

Data placement layout example on group_load:

* ElementsPerWorkItem = 4
* 3 work-items in the group
* input is: in_ptr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}

Consider 2 layouts:

1.`sycl::ext::oneapi::experimental::group_algorithm_data_placement::blocked`.

|===
|Work-item id|Output stored in private fixed-size array

|0
|{0, 1, 2, 3}
|1
|{4, 5, 6, 7}
|2
|{8, 9, 10, 11}
|===

2.`sycl::ext::oneapi::experimental::group_algorithm_data_placement::striped`.

|===
|Work-item id|Output stored in private fixed-size array

|0
|{0, 3, 6, 9}
|1
|{1, 4, 7, 10}
|2
|{2, 5, 8, 11}
|===

There is a property that satisfies
link:sycl_ext_oneapi_properties.asciidoc[SYCL Properties Extension]
requirements:

[source,c++]
----
namespace sycl::ext::oneapi::experimental::property
{
    template<group_algorithm_data_placement type>
    struct data_placement; // (9)
}
----

(9) Specifies data layout used in group_load/store for `sycl::vec` or fixed-size
arrays functions.

Example:
`group_load(g, input, output_span, properties<data_placement<blocked>>{});`

== Usage Examples

1.Example shows the simplest case without local memory usage of blocked load
of global memory from `input` to the private array `data` and store it back to
`output`

[source,c++]
----
namespace sycl_exp = sycl::ext::oneapi::experimental;

q.submit([&](sycl::handler& cgh) {
    cgh.parallel_for(
        sycl::nd_range<1>(global_size, local_size),
        [=](sycl::nd_item<1> item) {
            T data[items_per_thread];

            sycl_exp::group_load(item.get_group(), input, sycl::span{ data });

            // Work with data...

            sycl_exp::group_store(item.get_group(), output, sycl::span{ data });
        });
});
----

2.Example shows the simple case of blocked load of global memory from `input` to
the private array `data` and store it back to `output`
The temporary memory is allocated via `sycl::local_accessor`

[source,c++]
----
namespace sycl_exp = sycl::ext::oneapi::experimental;

q.submit([&](sycl::handler& cgh) {
    constexpr auto temp_memory_size = sycl_exp::memory_required<T, items_per_thread>(
        sycl::memory_scope::work_group, block_size);
    sycl::local_accessor<std::byte> buf(temp_memory_size, cgh);
    cgh.parallel_for(
        sycl::nd_range<1>(global_size, local_size),
        [=](sycl::nd_item<1> item) {
            T data[items_per_thread];
            std::byte* buf_ptr = buf.get_pointer().get();
            sycl_exp::group_with_scratchpad gh{ item.get_group(),
                                                sycl::span{ buf_ptr, temp_memory_size } };

            sycl_exp::group_load(gh, input, sycl::span{ data });

            // Work with data...

            sycl_exp::group_store(gh, output, sycl::span{ data });
        });
});
----

3.Example shows the case of striped load of global memory from `input` to
the private array `data` and store it back to `output`
The temporary memory is allocated via `group_local_memory` API, described in
link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/supported/sycl_ext_oneapi_local_memory.asciidoc[sycl_ext_oneapi_local_memory]

[source,c++]
----
namespace sycl_exp = sycl::ext::oneapi::experimental;

q.submit([&](sycl::handler& cgh) {
    constexpr auto temp_memory_size = sycl_exp::memory_required<T, items_per_thread>(
        sycl::memory_scope::work_group, block_size);
    cgh.parallel_for(
        sycl::nd_range<1>(block_count * block_size, block_size),
        [=](sycl::nd_item<1> item) {
            T data[items_per_thread];
            auto scratch =
                sycl::ext::oneapi::group_local_memory<std::byte[temp_memory_size]>(
                    item.get_group());
            std::byte* buf_ptr = (std::byte*)(scratch.get());

            sycl_exp::group_with_scratchpad gh{ item.get_group(),
                                                sycl::span{ buf_ptr, temp_memory_size } };

            sycl_exp::group_load(gh, input, sycl::span{ data },
                                 sycl::properties<sycl_exp::data_placement<sycl_exp::striped>>{});

            // Work with data...

            sycl_exp::group_store(gh, output, sycl::span{ data },
                                  sycl::properties<sycl_exp::data_placement<sycl_exp::striped>>{});
        });
});
----

== Design Considerations

* consider extending sycl::span to std::mdspan for C++23 for 2d and 3d kernels

* TODO: consider adding extra properties for setting boundary values or limiting
number of work-items
