= sycl_ext_oneapi_annotated_ptr

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

// This is necessary for asciidoc, but not for asciidoctor
:cpp: C++
:dpcpp: DPC++

== Notice

Copyright (c) 2021-2022 Intel Corporation.  All rights reserved.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.

== Contact

Abhishek Tiwari, Intel (abhishek2 'dot' tiwari 'at' intel 'dot' com)

== Contributors

Abhishek Tiwari, Intel +
Gregory Lueck, Intel +
Jason Sewall, Intel +
Jessica Davies, Intel +
Joe Garvey, Intel +
John Pennycook, Intel +
Michael Kinsner, Intel +
Roland Schulz, Intel

== Dependencies

This extension is written against the SYCL 2020 specification, revision 4.

It also depends on the 
link:../experimental/sycl_ext_oneapi_properties.asciidoc[sycl_ext_oneapi_properties]
extension.

== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*

== Overview

This extension introduces a pointer wrapper class that provides a mechanism to
attach compile-time constant information to a pointer in a manner that allows
the compiler to reliably maintain and analyze the information.

[NOTE]
====
In this document, we use the shortened form `annotated_ptr` to refer to the
proposed `sycl::ext::oneapi::annotated_ptr` class.
====

The purpose of this document is to clearly describe and specify `annotated_ptr`
and related concepts, types, and mechanisms, and to give examples and context
for their usage.

== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification, Section 6.3.3 "Feature test macros". Therefore, an
implementation supporting this extension must predefine the macro
`SYCL_EXT_ONEAPI_ANNOTATED_PTR` to one of the values defined in the table below.
Applications can test for the existence of this macro to determine if the
implementation supports this feature, or applications can test the macro's
value to determine which of the extension's features
that the implementation supports.

[%header,cols="1,5"]
|===
|Value |Description
|1     |Initial extension version
|===

=== Motivation

When compiling a program with pointer operations, it is often desirable to
attach certain information such as optimization hints or functional directives
onto the pointer itself.

Any acceptable mechanism to attach such information should meet the following
requirements:

  1. It should not be burdensome for users to use the mechanism.
  2. It should be reasonably scalable and not add significant burden on compiler
  developers to maintain the mechanism.
  3. It should preserve the attached information through most uses of the
  pointer.

For example, consider the following case: We want to specify some compile-time
constant information `I` for a pointer. One possible method to do so is for the
compiler to provide a special function for reading to and writing from the
pointer and have this function convey `I` to the compiler at the call site where
the read or write occurs.

That is, users would convert code that looks like:
```c++
{
  SomeType* a;
  ...
  *a = some_val;
  ...
  read_val = *a
}
```

To code that looks like:
```c++
{
  SomeType* a;
  ...
  __special_store_with_annotation(a, some_val,
    I /*some compile time constant information*/);
  ...
  __special_load_with_annotation(a, &read_val,
    I /*some compile time constant information*/);
}
```

This mechanism does not meet requirement (1) listed above because:

  * Users have to replace all their pointer read/write code with special
  function calls.

Another mechanism could be that the compiler provide attributes which can be
applied to the pointer declaration to convey some compile-time constant
information. In this case users would change their code to:
```cpp
{
  // 'I' is the compiler time constant information being annotated on 'a'
  [[special_annotations::use_case_x_attribute(I)]] SomeType* a;
  ...
  *a = some_val;
  ...
  read_val = *a
}
```
However, this mechanism fails to meet requirements (2) and (3) listed above
since:

  * Adding new attributes can add non-trivial attribute creation overheads for
  compiler developers. With growing set of attributes, there is an associated
  burden of maintaining them and of preparing diagnostic checks.
  * Compilers are not required to preserve information propagated as attributes.
  Hence this method is only suitable for hints, and not functional directives.
  Further, from a given load/store call a compiler may not be able to
  successfully trace back to the declaration to deduce which annotation was
  applied to it.

The `annotated_ptr` class described in this document is a class template that
encapsulates a pointer. The template accepts a list of compile-time constant
properties. The implementation of the class defined here should preserve the
information provided as compile-time constant properties through all uses of the
pointer unless noted otherwise.


=== Representation of `annotated_ptr`

`annotated_ptr` is a class template, parameterized by the type of the underlying
allocation `T`, and a list of properties `PropertyListT`.

[source,c++]
----
namespace sycl::ext::oneapi {
template <typename T, typename PropertyListT = properties<>>
class annotated_ptr {
  ...
----

`PropertyListT` enables properties to be associated with an `annotated_ptr`.
Properties may be specified for an `annotated_ptr` to provide semantic
modification or optimization hint information.

Here's an example of how a property could be used:

[source,c++]
----
using namespace sycl::ext::oneapi;
{
  sycl::queue q;
  // alignment of the pointer in bytes specified using the property 'alignment'
  annotated_ptr<int, properties<alignment<4>>> kernel_arg = ...;

  q.submit([=]{
    *kernel_arg = (*kernel_arg) * 2;
  });
  ...
}
----

The section below and the table that follows, describe the constructors, member
functions and factory methods for `annotated_ptr`.
The section below refers to an `annotated_ref` class which is described in the
section following this one.

[source,c++]
----
namespace sycl::ext::oneapi {
template <typename T, typename PropertyListT = properties<>>
class annotated_ptr {
  public:
    using reference = annotated_ref<T, PropertyListT>;

    annotated_ptr() noexcept;
    explicit annotated_ptr(T *Ptr, const properties<PropertyListT> &) noexcept;
    annotated_ptr(annotated_ptr const &) noexcept;
    template <T, typename P> explicit annotated_ptr(
      annotated_ptr<T, P> const &) noexcept;
    template <T, typename PropertyListU, typename PropertyListV>
    explicit annotated_ptr(annotated_ptr<T, PropertyListU> const &,
      properties<PropertyListV>) noexcept;

    reference operator*() const noexcept;
    reference operator[](std::ptrdiff_t) const noexcept;
    annotated_ptr operator+(size_t) const noexcept;
    std::ptrdiff_t operator-(annotated_ptr) const noexcept;

    operator bool() const noexcept;

    // Implicit conversion is not supported
    operator T*() noexcept = delete;
    operator const T*() const noexcept = delete;

    T* get() noexcept;
    const T* get() const noexcept;

    annotated_ptr& operator=(const T*) noexcept;
    annotated_ptr& operator=(annotated_ptr const&) noexcept;

    annotated_ptr& operator++() noexcept;
    annotated_ptr operator++(int) noexcept;
    annotated_ptr& operator--() noexcept;
    annotated_ptr operator--(int) noexcept;

    template<typename propertyT>
    static constexpr bool has_property();

    // The return type is an unspecified internal class used to represent
    // instances of propertyT
    template<typename propertyT>
    static constexpr /*unspecified*/ get_property();

  private:
    T *Ptr;
  };
} // namespace sycl::ext::oneapi

----

[frame="topbot",options="header"]
|===
|Functions |Description

// --- ROW BREAK ---
a|
[source,c++]
----
annotated_ptr() noexcept;
----
|
Constructs an `annotated_ptr` object. Does not allocate new storage. The
underlying pointer is initialized to `nullptr`.

// --- ROW BREAK ---
a|
[source,c++]
----
explicit annotated_ptr(T *Ptr, const properties<PropertyListT> &P) noexcept;
----
|
Constructs an `annotated_ptr` object. Does not allocate new storage. The
underlying pointer is initialized with `Ptr`. `P` is used to specify the
`PropertyListT` type on the class.

The new property set `PropertyListT` must contain all properties from `P`,
and if any common property takes a value, the value must be the same.

// --- ROW BREAK ---
a|
[source,c++]
----
template <T, typename PropertyListU, typename PropertyListV>
explicit annotated_ptr<T, PropertyListT>(
  annotated_ptr<T, PropertyListU> const &Ptr,
  properties<PropertyListV> P) noexcept;
----
|
Constructs an `annotated_ptr` object. Does not allocate new storage. The
underlying pointer is initialized with `Ptr`. `PropertyListU` and
`PropertyListV` will be combined to construct `PropertyListT`.

// --- ROW BREAK ---
a|
[source,c++]
----
annotated_ptr(annotated_ptr const &) noexcept = default;
----
|
Constructs an `annotated_ptr` object from another `annotated_ptr` with the same
template parameterization object.

// --- ROW BREAK ---
a|
[source,c++]
----
template <typename T, typename P> explicit annotated_ptr(
  annotated_ptr<T, P> const & ConvertFrom);
----
|
Constructs the `annotated_ptr` object from the `ConvertFrom` object if
the list of properties in `PropertyListT` is a superset of the list of
properties in `P`.

// --- ROW BREAK ---
a|
[source,c++]
----
reference operator*() const;
----
|
Returns an `annotated_ref` reference wrapper which can be used to read or write
to the underlying pointer. Reads/Writes using the reference will retain the
annotations.

// --- ROW BREAK ---
a|
[source,c++]
----
reference operator[](std::ptrdiff_t Index) const;
----
|
Returns an `annotated_ref` reference wrapper to the object at offset `Index`.

// --- ROW BREAK ---
a|
[source,c++]
----
annotated_ptr operator+(size_t Offset) const;
----
|
Returns an `annotated_ptr` that points to `this[Offset]`.

// --- ROW BREAK ---
a|
[source,c++]
----
std::ptrdiff_t operator-(annotated_ptr FromPtr) const;
----
|
Returns the distance between the underlying pointer and the pointer encapsulated
by `FromPtr`.

// --- ROW BREAK ---
a|
[source,c++]
----
operator bool() const noexcept;
----
|
Returns `false` if the underlying pointer is null, returns `true` otherwise.

// --- ROW BREAK ---
a|
[source,c++]
----
/*unspecified*/ operator T*() noexcept = delete;
/*unspecified*/ operator const T*() const noexcept = delete;
----
|
Implicit conversion to a pointer to the underlying type is not supported.

// --- ROW BREAK ---
a|
[source,c++]
----
T* get() noexcept;
const T* get() const noexcept;
----
|
Returns the underlying raw pointer. The raw pointer will not retain the
annotations.

// --- ROW BREAK ---
a|
[source,c++]
----
annotated_ptr& operator=(const T*) noexcept;
----
|
Allows assignment from a pointer to type `T`.

// --- ROW BREAK ---
a|
[source,c++]
----
annotated_ptr& operator=(annotated_ptr const&) noexcept;
----
|
Allows assignment from an `annotated_ptr` with the same parameterization.

// --- ROW BREAK ---
a|
[source,c++]
----
annotated_ptr& operator++() noexcept;
----
|
Prefix increment operator.

// --- ROW BREAK ---
a|
[source,c++]
----
annotated_ptr operator++() noexcept;
----
|
Postfix increment operator.

// --- ROW BREAK ---
a|
[source,c++]
----
annotated_ptr& operator--() noexcept;
----
|
Prefix decrement operator.

// --- ROW BREAK ---
a|
[source,c++]
----
annotated_ptr operator--() noexcept;
----
|
Postfix decrement operator.

// --- ROW BREAK ---
a|
[source,c++]
----
template<typename propertyT>
static constexpr bool has_property();
----
| 
Returns true if the property list contains the property with property key class
`propertyT`. Returns false if it does not.

Available only when `propertyT` is a property key class.

// --- ROW BREAK ---
a|
[source,c++]
----
template<typename propertyT>
static constexpr auto get_property();
----
| 
Returns a copy of the property value contained in the property list
`PropertyListT`. Must produce a compile error if `PropertyListT` does not
contain a property with the `propertyT` key.

Available only if `propertyT` is the property key class of a compile-time
constant property.
|===

=== Add new reference wrapper class `annotated_ref` to enable `annotated_ptr`

The purpose of the `annotated_ref` class template is to provide reference
wrapper semantics. It enables the implementation to preserve the properties on
loads from and stores to the pointers.

```c++
namespace sycl::ext::oneapi {
template <typename T, typename PropertyListT = properties<>>
class annotated_ref {
  public:
    annotated_ref(T *);
    operator T() noexcept;
    operator const T() const noexcept;
    void operator=(const T &);
  private:
    T *Ptr;
  };
} // namespace sycl::ext::oneapi
```


Member Functions are described in the table below
[frame="topbot",options="header"]
|===
|Functions |Description

// --- ROW BREAK ---
a|
[source,c++]
----
annotated_ref(T * InputPtr);
----
|
Constructs an `annotated_ref` object. Does not allocate new storage. The
underlying pointer is initialized to `InputPtr`.

// --- ROW BREAK ---
a|
[source,c++]
----
operator T() noexcept;
operator const T() const noexcept;
----
|
Reads the object of type `T` that is referenced by this wrapper, applying the
annotations when the object is loaded from memory.

// --- ROW BREAK ---
a|
[source,c++]
----
void operator=(const T &);
----
|
Writes an object of type `T` to the location referenced by this wrapper,
applying the annotations when the object is stored to memory.

|===

=== Properties

Below is a list of compile-time constant properties supported with
`annotated_ptr`. 

```c++
namespace sycl::ext::oneapi::experimental {
struct alignment_key {
  template<int K>
  using value_t = property_value<alignment_key, std::integral_constant<int, K>>;
};

struct kernel_arg_restrict_key {
  using value_t = property_value<kernel_arg_restrict_key>;
};

struct runtime_aligned_key {
  using value_t = property_value<runtime_aligned_key>;
};

template<int K>
inline constexpr alignment_key::value_t<K> alignment;
inline constexpr kernel_arg_restrict_key::value_t kernel_arg_restrict;
inline constexpr runtime_aligned_key::value_t runtime_aligned;

template<>
struct is_property_key<alignment_key> : std::true_type {};
template<>
struct is_property_key<kernel_arg_restrict_key> : std::true_type {};
template<>
struct is_property_key<runtime_aligned_key> : std::true_type {};

template<typename T, typename PropertyListT>
struct is_property_key_of<
  alignment_key, annotated_ptr<T, PropertyListT>> : std::true_type {};
template<typename T, typename PropertyListT>
struct is_property_key_of<
  kernel_arg_restrict_key, annotated_ptr<T, PropertyListT>> : std::true_type {};
template<typename T, typename PropertyListT>
struct is_property_key_of<
  runtime_aligned_key, annotated_ptr<T, PropertyListT>> : std::true_type {};
} // namespace experimental::oneapi::ext::sycl
```
--
[options="header"]
|====
| Property | Description
|`alignment`
|
Sets the alignment of the pointer address in bytes.

|`restrict`
|
Informs the compiler that writes to the address pointed to by this pointer
are only done by this pointer or pointers derived from it.

|`runtime_aligned`
|
Informs the compiler that the pointer has the alignment as determined by the
runtime specification.
|====
--

== Issues related to `annotated_ptr`

1) [RESOLVED] Should we allow implicit conversion to base class by default?
Ans: Enabling conversion to underlying pointer will result in loss of the
annotations when that underlying pointer is used. Some use-cases will benefit
from this if they only need to retain the annotations on the kernel function
interface (and not on the load/store sites within the device code). Hence,
conversion will be allowed except when the property list contains properties
whose definitions disallow implicit conversion.
This can be implemented via SFINAE.

2) [RESOLVED] How do we support `operator->`?
We will not support `operator->` with the initial release, since we do
not have meaningful usecases that require this support. Building the support
is complicated

3) [RESOLVED] Can `sycl::atomic_ref` be used with `annotated_ref`?
`atomic_ref` will not work with `annotated_ref` as is since `atomic_ref`
restricts the types it can take. If we want, we can create a sycl extension for
`atomic_ref` to support `annotated_ref`. The implementation complexity will
depend on how we chose to implement `annotated_ref`: via builtins or via pointer
annotations.

4) [RESOLVED] Should we provide conversion functions to convert to/from
multi_ptr?
No we do not want to support multi_ptr conversion. 'multi_ptr's provide
a way to annotate address spaces. That can be built with annotated_ptr.

5) We need a property to capture local, global or private address-spaces. Within
global space we may want to distinguish between general, host, and device memory
spaces.

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|3|2022-04-05|Abhishek Tiwari|*Addressed review comments*
|2|2022-03-07|Abhishek Tiwari|*Corrected API and updated description*
|1|2021-11-01|Abhishek Tiwari|*Initial internal review version*
|========================================