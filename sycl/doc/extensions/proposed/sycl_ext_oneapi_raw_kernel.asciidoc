= sycl_ext_oneapi_raw_kernel

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2023-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.
OpenCL(TM) is a trademark of Apple Inc. used by permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 8 specification.
All references below to the "core SYCL specification" or to section numbers in
the SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:../experimental/sycl_ext_oneapi_properties.asciidoc[
  sycl_ext_oneapi_properties]
* link:../proposed/sycl_ext_oneapi_free_function_queries.asciidoc[
  sycl_ext_oneapi_free_function_queries]


== Status

This is a proposed extension specification, intended to gather community
feedback.
Interfaces defined in this specification may not be implemented yet or may be
in a preliminary state.
The specification itself may also change in incompatible ways before it is
finalized.
*Shipping software products should not rely on APIs defined in this
specification.*


== Overview

This extension introduces a new way to define a kernel as a simple C++
function, where the kernel arguments are parameters to the function.
This is different from standard SYCL kernels, where the kernel arguments are
either captures of a lambda expression or member variables of a callable
object.

The primary motivation for this extension is the
link:../proposed/sycl_ext_oneapi_kernel_compiler.asciidoc[
sycl_ext_oneapi_kernel_compiler], which allows online compilation of a kernel
from source code.
These kernels must have a clean separation between host and device code, and
they must have a defined order to their arguments because the application sets
the argument values by their "index" via `handler::set_arg(index, value)`.
Because variables captured by lambda expressions have no defined order, we need
some other way to define kernel arguments for use with the
sycl_ext_oneapi_kernel_compiler extension, and the sycl_ext_oneapi_raw_kernel
extension provides that mechanism.
The "raw kernel" feature is a separate extension, though, because it can also
be used independently from sycl_ext_oneapi_kernel_compiler.
For example, some users may find it more familiar to define kernels as plain
functions or they might have other reasons to prefer a clean separation between
host and device code.


== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.
An implementation supporting this extension must predefine the macro
`SYCL_EXT_ONEAPI_RAW_KERNEL`
to one of the values defined in the table below.
Applications can test for the existence of this macro to determine if the
implementation supports this feature, or applications can test the macro's
value to determine which of the extension's features the implementation
supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===

=== Defining a raw kernel

A raw kernel is a normal C++ function definition, where the function definition
is decorated with one of the following compile-time properties: `range_kernel`,
`nd_range_kernel`, or `single_task_kernel`.
Each of these properties takes a template parameter `Name`, which serves as the
name of the kernel, similar to the `KernelName` template parameter to
`parallel_for` for a standard SYCL kernel.
When a raw kernel has a name, the type used as the name must not be used to
name any other kernel in the application (either a raw kernel or a "named"
standard kernel).
The type used to name a raw kernel has the same limitations as the type used to
name a standard SYCL kernel as specified in section 5.2 "Naming of kernels" of
the core SYCL specification.
A raw kernel may be defined as a function template, however, all instantiations
of the function must have a unique name, which implies that the type used to
name the kernel is also somehow templated.

Usually, a raw kernel must have a type-name because the type-name is used to
obtain a `kernel` object that represents the raw kernel, and a `kernel` object
is needed in order to enqueue the kernel.
However, when raw kernels are used with the
link:../proposed/sycl_ext_oneapi_kernel_compiler.asciidoc[
sycl_ext_oneapi_kernel_compiler] extension, it is possible to obtain the
`kernel` even without a type-name.
In this case, the raw kernel can be unnamed by letting the `Name` template
parameter have its default value of `void`.

The following table provides additional details about these compile-time
properties.

|====
a|
*`range_kernel` property*

[frame=all,grid=none]
!====
a!
[source]
----
struct range_kernel_key {
  template <int Dims, typename Name>
  using value_t = property_value<range_kernel_key, Dims, Name>;
};

template<int Dims, typename Name = void>
inline constexpr range_kernel_key::value_t<Dims, Name> range_kernel;

template<>
struct is_property_key<range_kernel_key> : std::true_type {};
----
!====

Indicates that the function is a raw kernel that is invoked with a simple
`range` iteration space of `Dims` dimensions.
When the `Name` parameter is not `void`, it is a type that represents the name
of the kernel.

The `property_value` struct has the following member variables and type
aliases:

[%header,cols="1,1"]
!====
!Member
!Description

a!
[source]
----
static constexpr int dimensions = Dims
----
!
The number of dimensions of the kernel's range.

a!
[source]
----
using name = Name
----
!
The type-name of the kernel.
!====

a|
*`nd_range_kernel` property*

[frame=all,grid=none]
!====
a!
[source]
----
struct nd_range_kernel_key {
  template <int Dims, typename Name>
  using value_t = property_value<nd_range_kernel_key, Dims, Name>;
};

template<int Dims, typename Name = void>
inline constexpr nd_range_kernel_key::value_t<Dims, Name> nd_range_kernel;

template<>
struct is_property_key<nd_range_kernel_key> : std::true_type {};
----
!====

Indicates that the function is a raw kernel that is invoked with an
`nd_range` iteration space of `Dims` dimensions.
When the `Name` parameter is not `void`, it is a type that represents the name
of the kernel.

The `property_value` struct has the following member variables and type
aliases:

[%header,cols="1,1"]
!====
!Member
!Description

a!
[source]
----
static constexpr int dimensions = Dims
----
!
The number of dimensions of the kernel's range.

a!
[source]
----
using name = Name
----
!
The type-name of the kernel.
!====

a|
*`single_task_kernel` property*

[frame=all,grid=none]
!====
a!
[source]
----
struct single_task_kernel_key {
  template <typename Name>
  using value_t = property_value<single_task_kernel_key, Name>;
};

template<typename Name = void>
inline constexpr single_task_kernel_key::value_t<Name> single_task_kernel;

template<>
struct is_property_key<single_task_kernel_key> : std::true_type {};
----
!====

Indicates that the function is a raw kernel that is invoked via `single_task`
(i.e. without any iteration space).
When the `Name` parameter is not `void`, it is a type that represents the name
of the kernel.

The `property_value` struct has the following member type alias:

[%header,cols="1,1"]
!====
!Member
!Description

a!
[source]
----
using name = Name
----
!
The type-name of the kernel.
!====
|====

When a function is defined as a raw kernel, each parameter to the function is
a kernel argument, which must abide by the rules for allowable kernel parameter
types specified in section 4.12.4 "Rules for parameter passing to kernels" of
the core SYCL specification.
The function's return type must be `void`.

The following example demonstrates how a raw kernel can be defined using the
`range_kernel` property:

```
namespace syclex = sycl::ext::oneapi::experimental;

struct my_iota;

SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::range_kernel<1, my_iota>)
void iota(float start, float *ptr) {
   // ...
}
```

=== Interaction with the kernel bundle APIs

Raw kernels work with the kernel bundle APIs defined in section 4.11 "Kernel
bundles" of the core SYCL specification in a natural way.
Any kernel bundle API that accepts a kernel's type-name may be used with the
type-name of a raw kernel.
In fact, an application must use the kernel bundle APIs in order to invoke a
raw kernel because the application must first obtain a `kernel` object.
Typically, the application first obtains a kernel bundle from the raw kernel's
name and then obtains its `kernel` object as shown in the following example:

```
namespace syclex = sycl::ext::oneapi::experimental;

struct my_iota;

SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::range_kernel<1, my_iota>)
void iota(float start, float *ptr) {
   // ...
}

int main() {
  sycl::queue q;
  sycl::context ctxt = q.get_context();

  // Get a kernel bundle that contains the raw kernel "my_iota".
  auto exe_bndl =
    sycl::get_kernel_bundle<my_iota, sycl::bundle_state::executable>(ctxt);

  // Get a kernel object for the "my_iota" function from that bundle.
  sycl::kernel myiota = exe_bndl.get_kernel<my_iota>();
}
```

=== Enqueuing a raw kernel and setting parameter values

Once the application obtains a `kernel` object for a raw kernel, it can enqueue
the kernel to a device using any of the SYCL functions that allow a kernel to
be enqueued via a `kernel` object.
The application must enqueue the raw kernel according to its type.
For example, a raw kernel defined via `range_kernel` can be enqueued by calling
the `handler::parallel_for` overload taking a `range`.
A raw kernel defined via `nd_range_kernel` can be enqueued by calling the
`handler::parallel_for` overload taking an `nd_range`.
A raw kernel defined via `single_task_kernel` can be enqueued by calling
`handler::single_task`.

Attempting to enqueue a raw kernel using a mechanism that does not match its
type results in undefined behavior.
Attempting to enqueue a raw kernel with a `range` or `nd_range` whose
dimensionality does not match the raw kernel definition results in undefined
behavior.

The application is also responsible for setting the values of any kernel
arguments when the kernel is enqueued.
For example, when enqueuing a kernel with `handler::parallel_for` or
`handler::single_task`, the kernel argument values must be set via
`handler::set_arg` or `handler::set_args`.
Failing to set the value of a kernel argument results in undefined behavior.

=== Obtaining the iteration id for a kernel

In a standard SYCL kernel, the iteration ID is passed as a parameter to the
kernel's callable object.
However, this is not the case for a raw kernel because the function parameters
are used to pass the kernel arguments instead.
Therefore, a raw kernel must obtain the iteration ID in some other way.
Typically, a raw kernel uses the free functions specified in
link:../proposed/sycl_ext_oneapi_free_function_queries.asciidoc[
sycl_ext_oneapi_free_function_queries] for this purpose.

=== Interaction with kernel properties

If the implementation supports
link:../experimental/sycl_ext_oneapi_kernel_properties.asciidoc[
sycl_ext_oneapi_kernel_properties], a raw kernel may be decorated with these
properties by applying the properties to the function definition as illustrated
below.

```
struct my_iota;

SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::nd_range_kernel<1, my_iota>)
SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::work_group_size<32>)
void iota(float start, float *ptr) {
   // ...
}
```

As with standard SYCL kernels, these properties can be queried via
`kernel::get_info` using either the `info::kernel::attributes` information
descriptor or the `info::kernel_device_specific` information descriptors.


== Example

The following example demonstrates how to define a raw kernel and then enqueue
it on a device.

```
namespace syclex = sycl::ext::oneapi::experimental;

struct my_iota;
static constexpr size_t NUM = 1024;

SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(syclex::range_kernel<1, my_iota>)
void iota(float start, float *ptr) {
  // Get the ID of this kernel iteration.
  size_t id = syclex::this_kernel::get_id();

  ptr[id] = start + static_cast<float>(id);
}

void main() {
  sycl::queue q;
  sycl::context ctxt = q.get_context();

  // Get a kernel bundle that contains the raw kernel "my_iota".
  auto exe_bndl =
    sycl::get_kernel_bundle<my_iota, sycl::bundle_state::executable>(ctxt);

  // Get a kernel object for the "my_iota" function from that bundle.
  sycl::kernel myiota = exe_bndl.get_kernel<my_iota>();

  float *ptr = sycl::malloc_shared<float>(NUM, q);
  q.submit([&](sycl::handler &cgh) {
    // Set the values of the kernel arguments.
    cgh.set_args(3.14f, ptr);

    cgh.parallel_for({NUM}, myiota);
  }).wait();
}
```


== Issues

* The front-end team has expressed concern about implementing this syntax
  because it requires the front-end to recognize the property names
  `range_kernel`, `nd_range_kernel`, and `single_task_kernel`.
  This is necessary because the front-end must know that functions decorated
  with these properties are device code, and it must somehow get the kernel
  name in order to generate the integration header.
  Currently, the front-end does not intrinsicly know any of the property names.
  Rather, the front-end simply passes the properties verbatim into the
  generated LLVM IR.
  If we want to avoid teaching the front-end about these property names, we
  could instead change the syntax for declaring a raw kernel to be like this:
+
```
SYCL_EXT_ONEAPI_RANGE_KERNEL(1, my_iota)
void iota(float start, float *ptr) {
  // ...
}
```
+
Here, the macro `SYCL_EXT_ONEAPI_RANGE_KERNEL` would expand to two things.
One part of the expansion would be a C++ attribute that tells the front-end
that this function is a raw "range" kernel with the given type-name.
Another part of the expansion would add the same IR attributes as the
`range_kernel` property (assuming there is even a need to represent this
information in the IR).
There are two drawbacks to this approach.
One is purely aesthetic: we would need to add a new macro to the language
instead of using our existing property mechanism.
The other relates to error messages.
Error messages with macros tend to be worse when the user passes incorrect
parameters.
+
This same issue exists also for the extension
link:https://github.com/intel/llvm/pull/10540[
sycl_ext_oneapi_virtual_functions] because that extension adds the property
`indirectly_callable<name>` which must be used to decorate virtual functions
that can be called from device code.
Again, the front-end would either need to recognize this property name, or we
would need to use a new macro like `SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE(name)`
instead of the property.

* We need to investigate whether there will be problems passing kernel
  arguments that are "decomposed" by the front-end.
  For example, if a kernel argument is a struct that contains an accessor as a
  member variable, the front-end decomposes the struct, passing each member
  variable as a separate kernel argument.
  We could still support arguments like this if `handler::set_arg` is smart
  enough to also do the decomposition, passing multiple arguments when the
  argument type requires decomposition.
  If this is too difficult to implement, we could restrict the arguments to
  only those types that do not require decomposition.
  If we add this restriction, the front-end should diagnose an error if a
  raw kernel is defined to take such an argument.

* We currently say it is UB if there is a mismatch between a raw kernel's type
  or dimensionality and the call to `parallel_for` or `single_task`.
  Should we go a step further and require an exception to be thrown in these
  cases?
  I'm pretty sure we can implement this in {dpcpp}, but I'm not sure about a
  library-only implementation.
  However, I'm not sure _any_ of this can be implemented without compiler
  support.

* We currently say it is UB if a raw kernel is enqueued without setting a value
  for each of its arguments.
  Should we go a step further and require an exception in this case?
  This seems easier to implement, even for library-only.
