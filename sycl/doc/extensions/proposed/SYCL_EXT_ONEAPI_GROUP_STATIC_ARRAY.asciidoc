= SYCL_EXT_ONEAPI_GROUP_STATIC_ARRAY
:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

== Notice

Copyright (c) 2022 Intel Corporation.  All rights reserved.

IMPORTANT: This specification is a draft.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc. OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.

== Dependencies

This extension is written against the SYCL 2020 specification, Revision 4 and
the following extensions:

- link:SYCL_EXT_ONEAPI_PROPERTIES.asciidoc[SYCL_EXT_ONEAPI_PROPERTIES]
- link:../experimental/SYCL_EXT_ONEAPI_GROUP_SORT.asciidoc[SYCL_EXT_ONEAPI_GROUP_SORT]

NOTE: This extension is experimental: interfaces are subject to change later.

== Introduction

This extension introduces interfaces for Group algorithms library (core SYCL specification 4.17.4)
that are based on static arrays.

== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification section 6.3.3 "Feature test macros". Therefore, an
implementation supporting this extension must predefine the macro
`SYCL_EXT_ONEAPI_GROUP_STATIC_ARRAY` to one of the values defined in the table below.
Applications can test for the existence of this macro to determine if the
implementation supports this feature, or applications can test the macro's
value to determine which of the extension's APIs the implementation supports.

Table 1. Values of the `SYCL_EXT_ONEAPI_STATIC_ARRAY_INPUT` macro.
[%header,cols="1,5"]
|===
|Value |Description
|1     |Initial extension version. Base features are supported.
|===

== Changes for Interfaces of Group Algorithms

=== Reduce

Using static arrays for reduction might be more performant
than calling reduce functions many times to avoid extra barriers.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

  template <typename Group, typename T, std::size_t ItemsPerWorkItem, typename BinaryOperation>
  T reduce_over_group(Group g, sycl::span<T, ItemsPerWorkItem> x, BinaryOperation binary_op); // (1)

  template <typename Group, typename V, std::size_t ItemsPerWorkItem, typename T, typename BinaryOperation>
  T reduce_over_group(Group g, sycl::span<V, ItemsPerWorkItem> x, T init, BinaryOperation binary_op); // (2)

}
----

_Preconditions_: `binary_op` must be an instance of a SYCL function object.
`init` and `binary_op` must be the same for all work-items in the group.

1._Constraints_: Available only if `sycl::is_group_v<std::decay_t<Group>>` is true,
`T` is a fundamental type, `BinaryOperation` is a SYCL function object type and
`ItemsPerWorkItem` is not equal to `sycl::dynamic_extent`.

_Mandates_: `binary_op(x[i], x[j])`, where `i, j < ItemsPerWorkItem`,
must return a value of type `T`.

_Returns_: The result of combining all the values inside `x` for all work-items in the group
using the `binary_op` operator, where the values are combined according to the generalized
sum defined in the {cpp} Standard.

2._Constraints_: Available only if `sycl::is_group_v<std::decay_t<Group>>` is true, `V` and `T`
are fundamental types, `BinaryOperation` is a SYCL function object type and `ItemsPerWorkItem`
is not equal to `sycl::dynamic_extent`.

_Mandates_: `binary_op(init, x[i])`, where `i < ItemsPerWorkItem`, must return a value of type `T`.

_Returns_: The result of combining the initial value `init` and all the values inside `x` for
all work-items in the group using the `binary_op` operator, where the values are combined
according to the generalized sum defined in the {cpp} Standard.

=== Exclusive Scan and Inclusive Scan

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

  template <typename Group, typename T, std::size_t ItemsPerWorkItem, typename BinaryOperation, typename Properties = sycl::ext::oneapi::experimental::properties<>>
  void exclusive_scan_over_group(Group g, sycl::span<T, ItemsPerWorkItem> in_data, sycl::span<T, ItemsPerWorkItem> out_data, BinaryOperation binary_op, Properties properties = {}); // (1)

  template <typename Group, typename V, std::size_t ItemsPerWorkItem, typename T, typename Properties = sycl::ext::oneapi::experimental::properties<>>
  void exclusive_scan_over_group(Group g, sycl::span<V, ItemsPerWorkItem> in_data, sycl::span<V, ItemsPerWorkItem> out_data, T init, BinaryOperation binary_op, Properties properties = {}); // (2)

}
----

_Preconditions_: `binary_op` must be an instance of a SYCL function object.
`init` and `binary_op` must be the same for all work-items in the group.

1._Constraints_: Available only if `sycl::is_group_v<std::decay_t<Group>>` is true,
`T` is a fundamental type, `BinaryOperation` is a SYCL function object type,
`ItemsPerWorkItem` is not equal to `sycl::dynamic_extent` and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Mandates_: `binary_op(in_data[i], in_data[j])`, where `i, j < ItemsPerWorkItem`,
must return a value of type `T`.

_Effects_: Perform the exclusive scan of all values of `in_data` for all work-items in the group
and the identity value of `binary_op`, using the operator `binary_op`. The scan is computed
using a generalized noncommutative sum as defined in standard {cpp}. For multi-dimensional groups,
the order of work-items in the group is determined by their linear id.
Result is written to `out_data` with the layout specified by `properties`.
Default layout is one that is specified by the `layout<blocked>` property.
`in_data` mustn't be changed by the algorithm.

2._Constraints_: Available only if `sycl::is_group_v<std::decay_t<Group>>` is true,
`V` and `T` are fundamental types, `BinaryOperation` is a SYCL function object type,
`ItemsPerWorkItem` is not equal to `sycl::dynamic_extent` and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Mandates_: `binary_op(init, in_data[i])`, where `i < ItemsPerWorkItem`,
must return a value of type `T`.

_Effects_: Perform the exclusive scan of all values of `in_data` for all work-items in the group
and an initial value specified by `init`, using the operator `binary_op`.
The scan is computed using a generalized noncommutative sum as defined in standard {cpp}.
For multi-dimensional groups, the order of work-items in the group is determined by their linear id.
Result is written to `out_data` with the layout specified by `properties`.
Default layout is one that is specified by the `layout<blocked>` property.
`in_data` mustn't be changed by the algorithm.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

  template <typename Group, typename T, std::size_t ItemsPerWorkItem, typename BinaryOperation, typename... Properties>
  void inclusive_scan_over_group(Group g, sycl::span<T, ItemsPerWorkItem> in_data, sycl::span<T, ItemsPerWorkItem> out_data, BinaryOperation binary_op, Properties properties = {}); // (1)

  template <typename Group, typename V, std::size_t ItemsPerWorkItem, typename T, typename BinaryOperation, typename... Properties>
  void inclusive_scan_over_group(Group g, sycl::span<V, ItemsPerWorkItem> in_data, sycl::span<V, ItemsPerWorkItem> out_data, BinaryOperation binary_op, T init, Properties properties = {}); // (2)

}
----

_Preconditions_: `binary_op` must be an instance of a SYCL function object
and must be the same for all work-items in the group.

1._Constraints_: Available only if `sycl::is_group_v<std::decay_t<Group>>` is true,
`T` is a fundamental type, `BinaryOperation` is a SYCL function object type,
`ItemsPerWorkItem` is not equal to `sycl::dynamic_extent` and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Mandates_: `binary_op(in_data[i], in_data[j])`, where `i, j < ItemsPerWorkItem`,
must return a value of type `T`.

_Effects_: Perform the inclusive scan of all values of `in_data` for all work-items in the group
and the identity value of `binary_op`, using the operator `binary_op`. The scan is computed
using a generalized noncommutative sum as defined in standard C++. For multi-dimensional groups,
the order of work-items in the group is determined by their linear id.
Result is written to `out_data` with the layout specified by `properties`.
Default layout is one that is specified by the `layout<blocked>` property.
`in_data` mustn't be changed by the algorithm.

2._Constraints_: Available only if `sycl::is_group_v<std::decay_t<Group>>` is true,
`V` and `T` are fundamental types, `BinaryOperation` is a SYCL function object type,
`ItemsPerWorkItem` is not equal to `sycl::dynamic_extent` and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Mandates_: `binary_op(init, in_data[i])`, where `i < ItemsPerWorkItem`,
must return a value of type `T`.

_Effects_: Perform the inclusive scan of all values of `in_data` for all work-items in the group
and an initial value specified by `init`, using the operator `binary_op`. The scan is computed
using a generalized noncommutative sum as defined in standard C++. For multi-dimensional groups,
the order of work-items in the group is determined by their linear id.
Result is written to `out_data` with the layout specified by `properties`.
Default layout is one that is specified by the `layout<blocked>` property.
`in_data` mustn't be changed by the algorithm.

=== Sorting functions

Sorting function is a SYCL Sorting Extension.

Following functions perform sorting including key-value variant.

NOTE: key value sorting is a sorting algorithm where keys are compared,
but keys and values are reordered both.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

  template <typename GroupHelper, typename T, std::size_t ItemsPerWorkItem, typename Properties = sycl::ext::oneapi::experimental::properties<>>
  void sort_over_group(GroupHelper gh, sycl::span<T, ItemsPerWorkItem> values, Properties properties = {}); // (1)

  template <typename GroupHelper, typename T, typename U, std::size_t ItemsPerWorkItem, typename Properties = sycl::ext::oneapi::experimental::properties<>>
  void sort_over_group(GroupHelper gh, sycl::span<T, ItemsPerWorkItem> keys, sycl::span<U, ItemsPerWorkItem> values, Properties properties = {}); // (2)

  template <typename GroupHelper, typename T, std::size_t ItemsPerWorkItem, typename Compare, typename Properties = sycl::ext::oneapi::experimental::properties<>>
  void sort_over_group(GroupHelper gh, sycl::span<T, ItemsPerWorkItem> values, Compare comp, Properties properties = {}); // (3)

  template <typename GroupHelper, typename T, typename U, std::size_t ItemsPerWorkItem, typename Properties = sycl::ext::oneapi::experimental::properties<>>
  void sort_over_group(GroupHelper gh, sycl::span<T, ItemsPerWorkItem> keys, sycl::span<U, ItemsPerWorkItem> values, Compare comp, Properties properties = {}); // (4)

  template<typename Group, typename T, std::size_t ItemsPerWorkItem, typename Sorter, typename Properties = sycl::ext::oneapi::experimental::properties<>>
  void sort_over_group(Group g, sycl::span<T, ItemsPerWorkItem> values, Sorter sorter, Properties properties = {}); // (5)

  template<typename Group, typename T, typename U, std::size_t ItemsPerWorkItem, typename Sorter, typename Properties = sycl::ext::oneapi::experimental::properties<>>
  void sort_over_group(Group g, sycl::span<T, ItemsPerWorkItem> keys, sycl::span<U, ItemsPerWorkItem> values, Sorter sorter, Properties properties = {}); // (6)

}
----

1._Constraints_: Only available if `GroupHelper` was created with a work-group or a sub-group and
some associated scratch space and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Effects_: Sort elements in the range containing of elements inside `values` from all work-items
from the group using the `gh` group helper object.
Result of sorting is placed into `values` with the layout specified by `properties`.
Default layout is one that is specified by the `layout<blocked>` property.
Elements are compared by `operator<`.

_Complexity_: Let `N` be the group size. `O(N*log(N)*log(N))` comparisons.

2._Constraints_: Only available if `GroupHelper` was created with a work-group or a sub-group and
some associated scratch space and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Effects_: Perform key-value sorting for elements in ranges containing of elements
inside `keys` and `values` from all work-items from the group using the `gh` group helper object.
Result of sorting is placed into `keys` and `values` with the layout specified by `properties`.
Default layout is one that is specified by the `layout<blocked>` property.
Elements are compared by `operator<`.

_Complexity_: Let `N` be the group size. `O(N*log(N)*log(N))` comparisons.

3._Constraints_: Only available if `GroupHelper` was created with a work-group or a sub-group and
some associated scratch space and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Mandates_: `comp` must satisfy the requirements of `Compare` from the {cpp} standard.

_Effects_: Sort elements in the range containing of elements inside `values` from all work-items
from the group with respect to the binary comparison function object `comp` using the `gh` group
helper object.
Result of sorting is placed into `values` with the layout specified by `properties`.
Default layout is one that is specified by the `layout<blocked>` property.

_Complexity_: Let `N` be the work-group or sub-group size. `O(N*log(N)*log(N))` comparisons.

4._Constraints_: Only available if `GroupHelper` was created with a work-group or a sub-group and
some associated scratch space and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Mandates_: `comp` must satisfy the requirements of `Compare` from the {cpp} standard.

_Effects_: Perform key-value sorting for elements in ranges containing of elements
inside `keys` and `values` from all work-items from the group with respect to the binary comparison
function object `comp` using the `gh` group helper object.
Result of sorting is placed into `keys` and `values` with the layout specified by `properties`.
Default layout is one that is specified by the `layout<blocked>` property.
Elements are compared by `operator<`.

_Complexity_: Let `N` be the work-group or sub-group size. `O(N*log(N)*log(N))` comparisons.

5._Constraints_: All functions are available only if `Sorter` is a SYCL Sorter and
it provides `operator()(Group, sycl::span)` overload and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Effects_: Equivalent to: `return sorter(g, values, properties)`.

6._Constraints_: All functions are available only if `Sorter` is a SYCL Sorter and
it provides `operator()(Group, sycl::span, sycl::span)` overload and
`sycl::ext::oneapi::is_property_list_v<std::decay_t<Properties>>` is true.

_Effects_: Equivalent to: `return sorter(g, keys, values, properties)`.

=== Sorters

Following operators are added to interfaces of Sorter.
Sorters are described into
link:../experimental/SYCL_EXT_ONEAPI_GROUP_SORT.asciidoc[the SYCL Sorting Extension].

[source,c++]
----
template<typename Group, typename T, std::size_t ItemsPerWorkItem, typename... Properties>
void operator()(Group g, sycl::span<T, ItemsPerWorkItem> values, sycl::ext::oneapi::experimental::properties properties = {});

template<typename Group, typename T, typename U, std::size_t ItemsPerWorkItem, typename... Properties>
void operator()(Group g, sycl::span<T, ItemsPerWorkItem> keys, sycl::span<U, ItemsPerWorkItem> values, sycl::ext::oneapi::experimental::properties properties = {});

----

Table 2. Changes for `operator()` of Sorters.
|===
|`operator()`|Description

|`template<typename Group, typename T, std::size_t ItemsPerWorkItem, typename... Properties>
void operator()(Group g, sycl::span<T, ItemsPerWorkItem> values, sycl::ext::oneapi::experimental::properties properties = {});`
|Implements a sorting algorithm that is called by `sort_over_group` and that accepts
the `sycl::span` value as an input parameter.
Result of sorting is placed into `values` with the layout specified by `properties`.
Default layout is one that is specified by the `layout<blocked>` property.
Available only if `sycl::is_group_v<std::decay_t<Group>>` is true and
`ItemsPerWorkItem` is not equal to `sycl::dynamic_extent`.

|`template<typename Group, typename T, typename U, std::size_t ItemsPerWorkItem, typename... Properties>
void operator()(Group g, sycl::span<T, ItemsPerWorkItem> keys, sycl::span<U, ItemsPerWorkItem> values, sycl::ext::oneapi::experimental::properties properties = {});`
|Implements a sorting algorithm that is called by `sort_over_group` and that
accepts two `sycl::span` values as input parameters.
Result of sorting is placed into `keys` and `values` with the layout specified by `properties`.
Default layout is one that is specified by the `layout<blocked>` property.
Available only if `sycl::is_group_v<std::decay_t<Group>>` is true and
`ItemsPerWorkItem` is not equal to `sycl::dynamic_extent`.
|===

=== Predefined Sorters

Following changes are required for interfaces of Predefined Sorters.
Predefined Sorters are described into
link:../experimental/SYCL_EXT_ONEAPI_GROUP_SORT.asciidoc[the SYCL Sorting Extension].

Two `operator()` methods are added.

[source,c++]
----
template<typename Group, typename T, std::size_t ItemsPerWorkItem, typename... Properties>
void operator()(Group g, sycl::span<T, ItemsPerWorkItem> values, sycl::ext::oneapi::experimental::properties properties = {});

template<typename Group, typename T, typename U, std::size_t ItemsPerWorkItem, typename... Properties>
void operator()(Group g, sycl::span<T, ItemsPerWorkItem> keys, sycl::span<U, ItemsPerWorkItem> values, sycl::ext::oneapi::experimental::properties properties = {});

----

==== Changes for `default_sorter`.

[source,c++]
----

template<typename T, std::size_t ItemsPerWorkItem = 1, std::int32_t dimensions = 1>
static constexpr size_t
memory_required(sycl::memory_scope scope, sycl::range<dimensions> r);

template<typename T, typename U, std::size_t ItemsPerWorkItem, std::int32_t dimensions = 1>
static constexpr size_t
key_value_memory_required(sycl::memory_scope scope, sycl::range<dimensions> r);

----

Table 3. `memory_required` and `key_value_memory_required` member functions of `default_sorter`.
|===
|Member function|Description

|`template<typename T, std::size_t ItemsPerWorkItem = 1, std::int32_t dimensions = 1>
static std::size_t memory_required(sycl::memory_scope scope, sycl::range<dimensions> local_range)`
|Returns size of temporary memory (in bytes) that is required by the default
sorting algorithm defined by the sorter calling by `sort_over_group`.
`ItemsPerWorkItem` is a parameter for `sycl::span<T, ItemsPerWorkItem>`
that is an input parameter for `sort_over_group`. The function can be used
for `sort_over_group` without `sycl::span` as an input parameter if `ItemsPerWorkItem == 1`.
If `scope = sycl::memory_scope::work_group`,
`local_range` is a local range of `sycl::nd_range` that was used to run the kernel;
if `scope = sycl::memory_scope::sub_group`, `local_range` is a sub-group size.
If other `scope` values are passed, behavior is unspecified.

|`template<typename T, typename U, std::size_t ItemsPerWorkItem, std::int32_t dimensions = 1>
static constexpr size_t
key_value_memory_required(sycl::memory_scope scope, sycl::range<dimensions> r);`
|Returns size of temporary memory (in bytes) that is required by the default key-value
sorting algorithm defined by the sorter calling by `sort_over_group`
with `sycl::span<T, ItemsPerWorkItem>` and `sycl::span<U, ItemsPerWorkItem>` as input parameters.
If `scope = sycl::memory_scope::work_group`,
`local_range` is a local range of `sycl::nd_range` that was used to run the kernel;
if `scope = sycl::memory_scope::sub_group`, `local_range` is a sub-group size.
If other `scope` values are passed, behavior is unspecified.

|===

==== Changes for `radix_sorter`.

[source,c++]
----

template<std::size_t ItemsPerWorkItem = 1, std::int32_t dimensions = 1>
static constexpr size_t
memory_required(sycl::memory_scope scope, sycl::range<dimensions> r);

template<typename U, std::size_t ItemsPerWorkItem, std::int32_t dimensions = 1>
static constexpr size_t
key_value_memory_required(sycl::memory_scope scope, sycl::range<dimensions> r);
----

Table 4. `memory_required` and `key_value_memory_required` member functions of `radix_sorter`.
|===
|Member function|Description

|`template<std::size_t ItemsPerWorkItem = 1, std::int32_t dimensions = 1>
static std::size_t memory_required(sycl::memory_scope scope, sycl::range<dimensions> local_range)`
|Returns size of temporary memory (in bytes) that is required by the radix
sorting algorithm defined by the sorter calling by `sort_over_group`.
`ItemsPerWorkItem` is a parameter for `sycl::span<T, ItemsPerWorkItem>`
that is an input parameter for `sort_over_group`, where `T` is a first template argument
for `radix_sorter`. The function can be used for `sort_over_group` without `sycl::span`
as an input parameter if `ItemsPerWorkItem == 1`.
If `scope = sycl::memory_scope::work_group`,
`local_range` is a local range of `sycl::nd_range` that was used to run the kernel;
if `scope = sycl::memory_scope::sub_group`, `local_range` is a sub-group size.
If other `scope` values are passed, behavior is unspecified.

|`template<typename U, std::size_t ItemsPerWorkItem, std::int32_t dimensions = 1>
static constexpr size_t
key_value_memory_required(sycl::memory_scope scope, sycl::range<dimensions> r);`
|Returns size of temporary memory (in bytes) that is required by the radix key-value
sorting algorithm defined by the sorter calling by `sort_over_group`
with `sycl::span<T, ItemsPerWorkItem>` and `sycl::span<U, ItemsPerWorkItem>`
as input parameters, where `T` is a first template argument for `radix_sorter`.
If `scope = sycl::memory_scope::work_group`,
`local_range` is a local range of `sycl::nd_range` that was used to run the kernel;
if `scope = sycl::memory_scope::sub_group`, `local_range` is a sub-group size.
If other `scope` values are passed, behavior is unspecified.

|===

=== SYCL Properties for Interfaces with Static Private Arrays

Group algorithms using the static array interface are performed across
`N * ItemsPerWorkItem` elements in the group, where `N` is the work-group size and
`ItemsPerWorkItem` is the number of elements that are processed by one work-item.

When a work-item contributes multiple values to a group algorithm,
there are multiple ways to interpret the order of that data.
Let `r` is a virtual range for sorting of `N * ItemsPerWorkItem` elements.
The extension supports two layouts:

a) Data from the `[r + id * ItemsPerWorkItem; r + (id + 1) * ItemsPerWorkItem)` virtual range
placed into the private memory under the span for `id`-th work-item.

b) `i * N + id` element of `r` fill the `i`-th element of the private memory
under the span for `id`-th work-item.

To specify a correct layout for placing of resulting data there is a enum:

[source,c++]
----
class enum group_algorithm_layout{
  blocked,
  striped
};
----

1.`sycl::ext::oneapi::experimental::group_algorithm_layout::blocked`
to specify layout described in a).

2.`sycl::ext::oneapi::experimental::group_algorithm_layout::striped`
to specify layout described in b).

Example:

N = 3;

|===
|Work-item id|Input private static array

|0
|{11, 10, 9, 8}
|1
|{7, 6, 5, 4}
|2
|{3, 2, 1, 0}
|===

After performing sorting by ascending there is the following virtual range:
`{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}`.

Consider 2 layouts:

1.`sycl::ext::oneapi::experimental::group_algorithm_layout::blocked`.

|===
|Work-item id|Output private static array

|0
|{0, 1, 2, 3}
|1
|{4, 5, 6, 7}
|2
|{8, 9, 10, 11}
|===

2.`sycl::ext::oneapi::experimental::group_algorithm_layout::striped`.

|===
|Work-item id|Output private static array

|0
|{0, 3, 6, 9}
|1
|{1, 4, 7, 10}
|2
|{2, 5, 8, 11}
|===

There are 3 properties that satisfy
link:SYCL_EXT_ONEAPI_PROPERTIES.asciidoc[SYCL Properties Extension] requirements:

[source,c++]
----
namespace sycl::ext::oneapi::experimental::property
{
    template<group_algorithm_layout type>
    struct layout_in; // (1)

    template<group_algorithm_layout type>
    struct layout_out; // (2)

    template<group_algorithm_layout type>
    struct layout; // (3)
}
----

1. `layout_in` specifies the layout for input data.
2. `layout_out` specifies the layout for output data.
3. `layout` specifies the same layout for input and output data both.

Example:
`sort_over_group(g, my_span, properties<layout_in<blocked>, layout_out<striped>>{});`

It's specified that data initially in `my_span` satisfies the `blocked` layout.
After sorting data will be placed to `my_span` corresponding to the `striped` layout.

== Examples

Use the key-value version of `sort_over_group` and `radix_sorter`

[source,c++]
----
...
namespace my_sycl = sycl::ext::oneapi::experimental;

sycl::range<1> local_range{256};
constexpr std::size_t ItemsPerWorkItem = 8;

// predefine radix_sorter to calculate local memory size
using RSorter = my_sycl::radix_sorter<T, my_sycl::sorting_order::descending>;
// calculate required local memory size
size_t temp_memory_size =
    RSorter::key_value_memory_required(sycl::memory_scope::work_group, local_range);

q.submit([&](sycl::handler& h) {
  auto keys_acc = sycl::accessor(keys_buf, h);
  auto vals_acc = sycl::accessor(vals_buf, h);
  auto scratch = sycl::local_accessor<std::byte, 1>( {temp_memory_size}, h);

  h.parallel_for(
    sycl::nd_range<1>{ local_range, local_range },
    [=](sycl::nd_item<1> id) {

      T keys_private[ItemsPerWorkItem];
      T vals_private[ItemsPerWorkItem];
      auto idx = id.get_global_id();
      for(std::size_t i = 0; i < ItemsPerWorkItem; ++i )
      {
        keys_private[i] = keys_acc[idx * ItemsPerWorkItem + i];
        vals_private[i] = vals_acc[idx * ItemsPerWorkItem + i];
      }

      my_sycl::sort_over_group(
        id.get_group(),
        sycl::span{keys_private},
        sycl::span{vals_private},
        RSorter(sycl::span{scratch.get_pointer(), temp_memory_size})
      );
      ...
    });
  });
...
----

== Open Questions

1.Will it be better to have an interface with `std::tuple` of `sycl::span` to generalize key-value sorting? e.g.
[source,c++]
----
sort_over_group(group, std::make_tuple(sycl::span{keys}, sycl::span{values}), sorter);
----

The thing is that tuple is not a span. It's better to have any _zip_span_ that allows the SoA layout. Interfaces without tuple highlights that we have parameters with different meaning: only keys are comparing, but keys and values are moving both. However, it can look like inconsistent comparing to other interfaces of sorting.

2.Is Sorter needed to be applied to keys only or to keys and values both in case of key-value sorting?

3.Do we need to have separate predefined sorters for static array interfaces?
e.g. instead of changing `default_sorter` and `radix_sorter` to have new sorters `default_span_sorter`, `radix_span_sorter`.

4.Will it be better to add interfaces for other group algorithms?

5.Should our interfaces have `sycl::span` or `std::span`?

6.What is a better name for properties? e.g. `plain`/`packed`/`close` and `strode`/`spread`.

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2022-02-08|Andrey Fedorov|Initial public working draft
|========================================
