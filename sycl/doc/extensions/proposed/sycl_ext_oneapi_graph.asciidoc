= SYCL_EXT_ONEAPI_GRAPH
:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

== Notice

Copyright (c) 2022 Intel Corporation.  All rights reserved.

IMPORTANT: This specification is a draft.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc. OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.


This extension is written against the SYCL 2020 revision 5 specification. All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*

== Introduction

This extension introduces an interface that enables a lazy execution and easy replay of a kernel graph by separating
its definition and execution.

== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification section 6.3.3 "Feature test macros".  Therefore, an
implementation supporting this extension must predefine the macro
`SYCL_EXT_ONEAPI_GRAPH` to one of the values defined in the table below.
Applications can test for the existence of this macro to determine if the
implementation supports this feature, or applications can test the macro's
value to determine which of the extension's APIs the implementation supports.

Table 1. Values of the `SYCL_EXT_ONEAPI_GRAPH` macro.
[%header,cols="1,5"]
|===
|Value |Description
|1     |Initial extension version. Base features are supported.
|===

== SYCL Graph Terminology

Table 2. Terminology.
[%header,cols="1,3"]
|===
|Concept|Description
|graph| Class that stores structured work units and their dependencies
|node| The unit of work. Can have different attributes.
|edge| Dependency between work units. Happens-before relation.
|===

== Node

Node is a class that encapsulates tasks like SYCL kernel functions or host tasks for deferred execution.
A graph has to be created first, the structure of a graph is defined second by adding nodes and edges.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

  class node{
  };
}
----

== Edge

A dependency between two nodes representing a happens-before relationship. `sender` and `receiver` may be associated to different graphs.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

	// Adding dependency between two nodes.
    	void make_edge(node sender, node receiver);
}
----

== Graph

Graph is a class that represents a directed acyclic graph of nodes. 
A graph can have different states, can be nested, can have multiple root nodes that are scheduled for execution first and multiple leaf nodes that are scheduled for execution last. The execution of a graph has been completed when all leaf node tasks have been completed.
Member functions as listed in Table 3 to 6 can be used to add nodes to a graph.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

  enum class graph_state{
    modifiable,
    executable
  };

  template<graph_state State=graph_state::modifiable>
  class command_graph {
  public:
    operator command_graph<graph_state::executable>();
  };
  
  template<>
  class command_graph<graph_state::executable>{
      public:
      command_graph() = delete;
  };
  
}

----

The following member functions are added to the queue class.

[source,c++]
----

namespace sycl {

event submit(const ext::oneapi::experimental::command_graph<ext::oneapi::experimental::graph_state::executable>& my_graph);

} // namespace sycl

----

=== Executable Graph

A `command_graph` object in `graph_state::executable` represents a user generated device and context specific execution object that is submitted to a queue for execution.
The structure of such a `command_graph` object in this state is immutable and cannot be changed, so are the tasks assigned with each node.
Support of submitting a graph for execution, before a previous execution has been completed is backend specific. The runtime may throw an error.

=== Graph member and helper functions

Table 3. Constructor of the `command_graph` class.
[cols="2a,a"]
|===
|Constructor|Description

|
[source,c++]
----
/* available only when graph_state == modifiable */`
command_graph();
----
|Creates a `command_graph` object.

|===

Table 4. Member functions of the `command_graph` class.
[cols="2a,a"]
|===
|Member function|Description

|
[source,c++]
----
node add(const std::vector<node>& dep = {});
----
|This creates an empty node which is associated to no task. Its intended use is either a connection point inside a graph between groups of nodes, and can significantly reduce the number of edges ( O(n) vs. O(n^2) ). Another use-case is building the structure of a graph first and adding tasks later.

|
[source,c++]
----
template<typename T>
    node add(T cgf, const std::vector<node>& dep = {});
----
|This function adds a command group function object to a graph. The function object can contain single or multiple commands such as a host task which is scheduled by the SYCL runtime or a SYCL function for invoking kernels with all restrictions that apply as described in the spec.

|
[source,c++]
----
command_graph<graph_state::executable> finalize(context &syclContext) const;
----
| This function creates an executable graph object with an immutable topology that can be executed on a queue that matches the given context.

|===

Memory that is allocated by the following functions is owned by the specific graph. When freed inside the graph, the memory is only accessible before the `free` node is executed and after the `malloc` node is executed.

Table 5. Member functions of the `command_graph` class (memory operations).
[cols="2a,a"]
|===
|Member function|Description

|
[source,c++]
----
node add_malloc_device(void *&data, size_t numBytes, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `malloc` operation.

|
[source,c++]
----
node add_free(void *data, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `free` operation.

|===

== Examples

// NOTE: The examples below demonstrate intended usage of the extension, but are not compatible with the proof-of-concept implementation. The proof-of-concept implementation currently requires different syntax, as described in the "Non-implemented features" section at the end of this document.

1. Dot product

[source,c++]
----
...

#include <sycl/ext/oneapi/experimental/graph.hpp>

int main() {
  const size_t n = 10;
  float alpha = 1.0f;
  float beta = 2.0f;
  float gamma = 3.0f;

  sycl::queue q;

  sycl::ext::oneapi::experimental::command_graph g;

  float *x , *y, *z;
  
  float *dotp = sycl::malloc_shared<float>(1, q);

  auto n_x = g.add_malloc_device<float>(x, n);
  auto n_y = g.add_malloc_device<float>(y, n);
  auto n_z = g.add_malloc_device<float>(z, n);

  /* init data on the device */
  auto n_i = g.add([&](sycl::handler &h) {
    h.parallel_for(n, [=](sycl::id<1> it){
      const size_t i = it[0];
      x[i] = 1.0f;
      y[i] = 2.0f;
      z[i] = 3.0f;
    });
  }, {n_x, n_y, n_z});

  auto node_a = g.add([&](sycl::handler &h) {
    h.parallel_for(sycl::range<1>{n}, [=](sycl::id<1> it) {
      const size_t i = it[0];
      x[i] = alpha * x[i] + beta * y[i];
    });
  }, {n_i});

  auto node_b = g.add([&](sycl::handler &h) {
    h.parallel_for(sycl::range<1>{n}, [=](sycl::id<1> it) {
      const size_t i = it[0];
      z[i] = gamma * z[i] + beta * y[i];
    });
  }, {n_i});

  auto node_c = g.add(
      [&](sycl::handler &h) {
        h.parallel_for(sycl::range<1>{n},
                       sycl::reduction(dotp, 0.0f, std::plus()),
                       [=](sycl::id<1> it, auto &sum) {
                         const size_t i = it[0];
                         sum += x[i] * z[i];
                       });
      },
      {node_a, node_b});
      
  auto node_f1 = g.add_free(x, {node_c});
  auto node_f2 = g.add_free(y, {node_b});

  auto exec = g.finalize(q.get_context());

  q.submit(exec).wait();

  // memory can be freed inside or outside the graph
  sycl::free(z, q.get_context());
  sycl::free(dotp, q);

  return 0;
}


...
----

// == Issues for later investigations
//
// . Explicit memory movement can cause POC to stall.
//
// == Non-implemented features
// Please, note that the following features are not yet implemented:
//
// . Level Zero backend only
// . Memory operation nodes not implemented
// . Host node not implemented
// . Submit overload of a queue. `submit(graph)` Use a combination of `executable_graph::exec_and_wait()` and queue property `sycl::ext::oneapi::property::queue::lazy_execution{}` instead.
// . `class graph<graph_state>` Use dedicated `class graph` (equivalent to `graph_state == modifiable`) and `class executable_graph` (equivalent to `graph_state == executable`) instead.

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2022-02-11|Pablo Reble|Initial public working draft
|2|2022-03-11|Pablo Reble|Incorporate feedback from PR
|3|2022-05-25|Pablo Reble|Extend API and Example
|4|2022-08-10|Pablo Reble|Adding USM shortcuts
|========================================
