= sycl_ext_oneapi_graph
:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:sectnums:

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

== Notice

Copyright (c) 2022 Intel Corporation.  All rights reserved.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc. OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues

== Contributors

Pablo Reble, Intel +
Julian Miller, Intel +
John Pennycook, Intel +
Guo Yejun, Intel +
Dan Holmes, Intel +
Greg Lueck, Intel +
Ewan Crawford, Codeplay +
Ben Tracy, Codeplay +
Duncan McBain, Codeplay +
Peter Žužek, Codeplay +
Ruyman Reyes, Codeplay +
Gordon Brown, Codeplay +
Erik Tomusk, Codeplay +
Bjoern Knafla, Codeplay +
Lukas Sommer, Codeplay +
Ronan Keryell, AMD +

== Dependencies

This extension is written against the SYCL 2020 revision 6 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*

== Introduction

With command groups SYCL is already able to create a dependency
graph (in the form of a directed acyclic graph) of kernel execution at runtime,
as a command group object defines a set of requisites (edges) which must be
satisfied for kernels (nodes) to be executed. However, because command-group
submission is tied to execution on the queue, without having a prior
construction step before starting execution, optimization opportunities are
missed from the runtime not being made aware of a defined dependency graph ahead
of execution.

The following benefits would become possible if the user could define a
dependency graph to the SYCL runtime prior to execution:

* Reduction in runtime overhead by only submitting a single graph object, rather
  than many individual command groups.

* Enable more work to be done ahead of time to improve runtime performance. This
  early work could be done in a setup phase of the program prior to repeated
  executions of the graph. Alternately, a future offline AOT compiler in a different
  process could run be prior to the execution of the application.

* Unlock DMA hardware features through graph analysis by the runtime.

* Graph optimizations become available, including but not limited to:
** Kernel fusion/fission.
** Inter-node memory reuse from data staying resident on device.
** Identification of the peak intermediate output memory requirement, used for
   more optimal memory allocation.

As well as benefits to the SYCL runtime, there are also advantages to the user
developing SYCL applications, as repetitive workloads no longer have to
redundantly issue the same sequence of commands. Instead, a graph is only
constructed once and submitted for execution as many times as is necessary, only
changing the data in input buffers or USM allocations. For applications from
specific domains, such as machine learning, where the same command group pattern
is run repeatedly for different inputs, this is particularly useful.

=== Requirements

In order to achieve the goals described in previous sections, the following
requirements were considered:

1. Ability to update inputs/outputs of the graph between submissions, without
   changing the overall graph structure.
2. Enable low effort porting of existing applications to use the extension.
3. Profiling, debugging, and tracing functionality at the granularity of graph
   nodes.
4. Integrate sub-graphs (previously constructed graphs) when constructing a new
   graph.
5. Support the USM model of memory as well as buffer model.
6. Compatible with other SYCL extensions and features, e.g. kernel fusion &
   built-in kernels.
7. Ability to record a graph with commands submitted to different devices in the
   same context.
8. Capability to serialize graphs to a binary format which can then be
   de-serialized and executed. This is helpful for AOT cases where a graph
   can be created by an offline tool to be loaded and run without the end-user
   incurring the overheads of graph creation.
9. Backend interoperability, the ability to retrieve a native graph object from
    the graph and use that in a native backend API.

To allow for prototype implementations of this extension to be developed
quickly for evaluation the scope of this proposal was limited to a subset
of these requirements. In particular, the serialization functionality (8),
backend interoperability (9), and a profiling/debugging interface (3) were
omitted. As these are not easy to abstract over several backends without
significant investigation. It is also hoped these features can be exposed as
additive changes to the API, and thus introduced in future versions of the
extension.

Another reason for deferring a serialize/deserialize API (8) is that its scope
could extend from emitting the graph in a binary format, to emitting a
standardized IR format that enables further device specific graph optimizations.

Multi-device support (7) is something that we are considering introducing into
the extension in later revisions, which may result in API changes. It has been
planned for to the extent that the definition of a graph node is device
specific, however currently all nodes in a graph must target the same device
provided to the graph constructor.

=== Graph Building Mechanisms

This extension contains two different API mechanisms for constructing a graph
of commands:

1. **Explicit graph building API** - Allows users to specify the exact nodes
and edges they want to add to the graph.

2. **Queue recording API (aka "Record & Replay")** - Introduces state to a
`sycl::queue` such that rather than scheduling commands immediately for
execution, they are added to the graph object instead, with edges captured from
the dependencies of the command group.

Each of these mechanisms for constructing a graph have their own advantages, so
having both APIs available allows the user to pick the one which is most
suitable for them. The queue recording API allows quicker porting of existing
applications, and can capture external work that is submitted to a queue, for
example via library function calls. While the explicit API can better express
what data is internal to the graph for optimization, and dependencies don't need
to be inferred.

It is valid to combine these two mechanisms, however it is invalid to modify
a graph using the explicit API while that graph is currently being recorded to,
for example:

[source, c++]
----
graph.begin_recording(queue);
graph.add(/*command group*/);    // Invalid as graph is being recorded to
graph.end_recording();
----

== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification section 6.3.3 "Feature test macros".  Therefore, an
implementation supporting this extension must predefine the macro
`SYCL_EXT_ONEAPI_GRAPH` to one of the values defined in the table below.
Applications can test for the existence of this macro to determine if the
implementation supports this feature, or applications can test the macro's
value to determine which of the extension's APIs the implementation supports.

Table {counter: tableNumber}. Values of the `SYCL_EXT_ONEAPI_GRAPH` macro.
[%header,cols="1,5"]
|===
|Value |Description
|1     |Initial extension version. Base features are supported.
|===

=== SYCL Graph Terminology

:explicit-memory-ops: https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#subsec:explicitmemory

Table {counter: tableNumber}. Terminology.
[%header,cols="1,3"]
|===
| Concept | Description

| Graph
| A directed and acyclic graph (DAG) of commands (nodes) and their dependencies
(edges), represented by the `command_graph` class.

| Node
| A command, which can have different attributes, targeting a specific device.

| Edge
| Dependency between commands as a happens-before relationship.

|===

==== Explicit Graph Building API

When using the explicit graph building API to construct a graph, nodes and
edges are captured as follows.

Table {counter: tableNumber}. Explicit Graph Definition.
[%header,cols="1,3"]
|===
| Concept | Description

| Node
| In the explicit graph building API nodes are created by the user invoking
methods on a modifiable graph. Each node represents either a command-group
function or an empty operation.

| Edge
| In the explicit graph building API edges are primarily defined by the user
through newly added interfaces. This is either using the `make_edge()` function
to define an edge between existing nodes, or using a
`property::node::depends_on` property list when adding a new node to the graph.

Edges can also be created when explicitly adding nodes to the graph through
existing SYCL mechanisms for expressing dependencies. Data dependencies from
buffer accessors to existing nodes in the graph are captured as an edge. Using
`handler::depends_on()` will also create a graph edge when passed an event
returned from a queue submission captured by a queue recording to the same graph.
|===

==== Queue Recording API

When using the record & replay API to construct a graph by recording a queue,
nodes and edges are captured as follows.

Table {counter: tableNumber}. Recorded Graph Definition.
[%header,cols="1,3"]
|===
| Concept | Description

| Node
| A node in a queue recorded graph represents a command group submission to the
device associated with the queue begin recorded. Each submission encompasses
either one or both of a.) some data movement, b.) a single asynchronous kernel
launch. Nodes cannot define forward edges, only backwards. That is, kernels can
only create dependencies on command-groups that have already been submitted.
This means that transparently a node can depend on a previously recorded graph
(sub-graph), which works by creating edges to the individual nodes in the old
graph. Explicit memory operations without kernels, such as a memory copy, are
still classed as nodes under this definition, as the
{explicit-memory-ops}[SYCL 2020 specification states] that these can be seen as
specialized kernels executing on the device.

| Edge
| An edge in a queue recorded graph is expressed through command group
dependencies in one of two ways. Firstly, through buffer accessors that
represent data dependencies between two command groups captured as nodes.
Secondly, by using the `handler::depends_on()` mechanism inside a command group
captured as a node. However, for an event passed to `handler::depends_on()` to
create an edge, it must be an event returned from a queue
submission captured by the same graph. Otherwise, a synchronous error will be
thrown with error code `invalid`. `handler::depends_on()` can be
used to express edges when a user is working with USM memory rather than SYCL
buffers.
|===

==== Sub-Graph

A node in a graph can take the form of a nested sub-graph. This occurs when
a command-group submission that invokes `handler::ext_oneapi_graph()` with an
executable graph object is added to the graph as a node.

=== API Modifications

[source, c++]
----
namespace sycl {
namespace ext::oneapi::experimental {

// State of a queue, returned by info::queue::state
enum class queue_state {
  executing,
  recording
};

namespace property {
namespace node {

class depends_on {
  public:
    template<typename... NodeTN>
    depends_on(NodeTN... nodes);
};

} // namespace node
} // namespace property

class node {};

// State of a graph
enum class graph_state {
  modifiable,
  executable
};

// New object representing graph
template<graph_state State = graph_state::modifiable>
class command_graph {};

template<>
class command_graph<graph_state::modifiable> {
public:
  command_graph(const device& syclDevice, const property_list& propList = {});

  command_graph<graph_state::executable>
  finalize(const context& syclContext, const property_list& propList = {}) const;

  bool begin_recording(queue& recordingQueue);
  bool begin_recording(const std::vector<queue>& recordingQueues);

  bool end_recording();
  bool end_recording(queue& recordingQueue);
  bool end_recording(const std::vector<queue>& recordingQueues);

  node add(const property_list& propList = {});

  template<typename T>
  node add(T cgf, const property_list& propList = {});

  void make_edge(node& src, node& dest);
};

template<>
class command_graph<graph_state::executable> {
public:
    command_graph() = delete;
    void update(const command_graph<graph_state::modifiable>& graph);
};
}  // namespace ext::oneapi::experimental

// New methods added to the sycl::queue class
using namespace ext::oneapi::experimental;
class queue {
public:
  /* -- graph convenience shortcuts -- */

  event ext_oneapi_graph(command_graph<graph_state::executable>& graph);
  event ext_oneapi_graph(command_graph<graph_state::executable>& graph,
                   event depEvent);
  event ext_oneapi_graph(command_graph<graph_state::executable>& graph,
                   const std::vector<event>& depEvents);
};

// New methods added to the sycl::handler class
class handler {
public:
  void ext_oneapi_graph(command_graph<graph_state::executable>& graph);
}

}  // namespace sycl
----

=== Node

:crs: https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#sec:reference-semantics

Node is a class that encapsulates tasks like SYCL kernel functions, memory
operations, or host tasks for deferred execution. A graph must
be created first, the structure of a graph is defined second by adding nodes and
edges.

The `node` class provides the {crs}[common reference semantics].

[source,c++]
----
namespace sycl::ext::oneapi::experimental {
  class node {};
}
----

==== Depends-On Property

The API for explicitly adding nodes to a `command_graph` includes a
`property_list` parameter. This extension defines the `depends_on` property to
be passed here. `depends_on` defines any `node` objects for the created node to
be dependent on, and therefore form an edge with. These nodes are in addition to
the dependent nodes identified from the command-group requisites of the created
node.

[source,c++]
----
namespace sycl::ext::oneapi::experimental::property::node
class depends_on {
  public:
    template<typename... NodeTN>
    depends_on(NodeTN... nodes);
};
}
----

=== Graph

This extension adds a new `command_graph` object which follows the
{crs}[common reference semantics] of other SYCL runtime objects.

A `command_graph` represents a directed acyclic graph of nodes, where each node
represents a single command for a specific device or a sub-graph. The execution
of a graph completes when all its nodes have completed.

A `command_graph` is built up by either recording queue submissions or
explicitly adding nodes, then once the user is happy that the graph is complete,
the graph instance is finalized into an executable variant which can have no
more nodes added to it. Finalization may be a computationally expensive
operation as the runtime can perform optimizations based on the graph
structure. After finalization the graph can be submitted for execution on a
queue one or more times with reduced overhead.

==== Graph State

An instance of a `command_graph` object can be in one of two states:

* **Modifiable** - Graph is under construction and new nodes may be added to it.
* **Executable** - Graph topology is fixed after finalization and graph is ready to
  be submitted for execution.

A `command_graph` object is constructed in the _recording_ state and is made
_executable_ by the user invoking `command_graph::finalize()` to create a
new executable instance of the graph. An executable graph cannot be converted
to a modifiable graph. After finalizing a graph in the modifiable state, it is
valid for a user to add additional nodes and finalize again to create subsequent
executable graphs. The state of a `command_graph` object is made explicit by
templating on state to make the class strongly typed, with the default template
argument being `graph_state::modifiable` to reduce code verbosity on
construction.

.Graph State Diagram
[source, mermaid]
....
graph LR
    Modifiable -->|Finalize| Executable
....

==== Executable Graph Update

A graph in the executable state can have each nodes inputs & outputs updated
using the `command_graph::update()` method. This takes a graph in the
modifiable state and updates the executable graph to use the node input &
outputs of the modifiable graph, a technique called _Whole Graph Update_. The
modifiable graph must have the same topology as the graph originally used to
create the executable graphs, with the nodes targeting the same devices and
added in the same order.

==== Graph Member Functions

Table {counter: tableNumber}. Constructor of the `command_graph` class.
[cols="2a,a"]
|===
|Constructor|Description

|
[source,c++]
----
command_graph(const device& syclDevice, const property_list& propList = {});
----
|Creates a SYCL `command_graph` object in the modifiable state for device
`syclDevice`. Zero or more properties can be provided to the constructed SYCL
`command_graph` via an instance of `property_list`.

Preconditions:

* This constructor is only available when the `command_graph` state is
  `graph_state::modifiable`.

Parameters:

* `syclDevice` - Device that all nodes added to the graph will target,
  an immutable characteristic of the graph.

* `propList` - Optional parameter for passing properties. No `command_graph`
  constructor properties are defined by this extension.

|===

Table {counter: tableNumber}. Member functions of the `command_graph` class.
[cols="2a,a"]
|===
|Member function|Description

|
[source,c++]
----
node add(const property_list& propList = {});
----
|This creates an empty node which contains no command. Its intended use is
to make a connection point inside a graph between groups of nodes, and can
significantly reduce the number of edges ( O(n) vs. O(n^2^) ).

Preconditions:

* This member function is only available when the `command_graph` state is
  `graph_state::modifiable`.

Parameters:

* `propList` - Zero or more properties can be provided to the constructed node
  via an instance of `property_list`.

Returns: The empty node which has been added to the graph.

Exceptions:

* Throws synchronously with error code `invalid` if a queue is recording
  commands to the graph.

|
[source,c++]
----
template<typename T>
node add(T cgf, const property_list& propList = {});
----
|This function adds a command group function object to a graph. The function
object statically contains a group of commands, of which a single command is
executed at runtime. A function object can be a host task which is scheduled by
the SYCL runtime, or a SYCL function for invoking kernels with all restrictions
that apply as described in the core specification. The requisites of `cgf` will
be used to identify any dependent nodes in the graph to form edges with.

Preconditions:

* This member function is only available when the `command_graph` state is
  `graph_state::modifiable`.

Parameters:

* `cgf` - Command group function object to be added as a node.

* `propList` - Zero or more properties can be provided to the constructed node
  via an instance of `property_list`.

Returns: The command-group function object node which has been added to the graph.

Exceptions:

* Throws synchronously with error code `invalid` if a queue is recording
  commands to the graph.

|
[source,c++]
----
void make_edge(node& src, node& dest);
----

|Creates a dependency between two nodes representing a happens-before relationship.

Preconditions:

* This member function is only available when the `command_graph` state is
  `graph_state::modifiable`.

Parameters:

* `src` - Node which will be a dependency of `dest`.

* `dest` - Node which will be dependent on `src`.

Exceptions:

* Throws synchronously with error code `invalid` if a queue is recording
  commands to the graph object.

* Throws synchronously with error code `invalid` if `src` or `dest`
  are not valid nodes assigned to the graph object.

* Throws synchronously with error code `invalid` if `src` and `dest`
  are the same node.

|
[source,c++]
----
command_graph<graph_state::executable>
finalize(const context& syclContext, const property_list& propList = {}) const;
----

|Synchronous operation that creates a new graph in the executable state with a
fixed topology that can be submitted for execution on any queue sharing the
supplied context. It is valid to call this method multiple times to create
subsequent executable graphs. It is also valid to continue to add new nodes to
the modifiable graph instance after calling this function. It is valid to
finalize an empty graph instance with no recorded commands.

Preconditions:

* This member function is only available when the `command_graph` state is
  `graph_state::modifiable`.

Parameters:

* `syclContext` - The context associated with the queues to which the
  executable graph will be able to be submitted.

* `propList` - Optional parameter for passing properties. No finalization
  properties are defined by this extension.

Returns: A new executable graph object which can be submitted to a queue.

Exceptions:

* Throws synchronously with error code `invalid` if the graph contains a cycle.
  A cycle may be introduced to the graph via a call to `make_edge()` that
  creates a forward dependency.

* Throws synchronously with error code `invalid` if the graph contains a
  node which targets a device not present in `syclContext`.

|===

Table {counter: tableNumber}. Member functions of the `command_graph` class for queue recording.
[cols="2a,a"]
|===
|Member function|Description

|
[source, c++]
----
bool begin_recording(queue& recordingQueue)
----

|Synchronously changes the state of `recordingQueue` to the
`queue_state::recording` state.

Parameters:

* `recordingQueue` - A `sycl::queue` object to change to the
  `queue_state::recording` state and start recording commands to the graph
  instance.

Returns: `true` if `recordingQueue` has its state changed from
`queue_state::executing` to `queue_state::recording`, `false` otherwise.

Exceptions:

* Throws synchronously with error code `invalid` if `recordingQueue` is
  already recording to a different graph.

* Throws synchronously with error code `invalid` if `recordingQueue` is
  associated with a device that is different from the device used on creation
  of the graph.
|
[source, c++]
----
bool begin_recording(const std::vector<queue>& recordingQueues)
----

|Synchronously changes the state of each queue in `recordingQueues` to the
`queue_state::recording` state.

Parameters:

* `recordingQueues` - List of `sycl::queue` objects to change to the
  `queue_state::recording` state and start recording commands to the graph
  instance.

Returns: `true` if any queue in `recordingQueues` has its state changed from
`queue_state::executing` to `queue_state::recording`, `false` otherwise.

Exceptions:

* Throws synchronously with error code `invalid` if the any queue in
  `recordingQueues` is already recording to a different graph.

|
[source, c++]
----
bool end_recording()
----

|Synchronously finishes recording on all queues that are recording to the
graph and sets their state to `queue_state::executing`.

Returns: `true` if any queue recording to the graph has its state changed from
`queue_state::recording` to `queue_state::executing`, `false` otherwise.

|
[source, c++]
----
bool end_recording(queue& recordingQueue)
----

|Synchronously changes the state of `recordingQueue` to the
`queue_state::executing` state.

Parameters:

* `recordingQueue` - A `sycl::queue` object to change to the executing state.

Returns: `true` if `recordingQueue` has its state changed from
`queue_state::recording` to `queue_state::executing`, `false` otherwise.

Exceptions:

* Throws synchronously with error code `invalid` if `recordingQueue` is
  recording to a different graph.

|
[source, c++]
----
bool end_recording(const std::vector<queue>& recordingQueues)
----

|Synchronously changes the state of each queue in `recordingQueues` to the
`queue_state::executing` state.

Parameters:

* `recordingQueues` - List of `sycl::queue` objects to change to the executing
  state.

Returns: `true` if any queue in `recordingQueues` has its state changed from
`queue_state::recording` to `queue_state::executing`, `false` otherwise.

Exceptions:

* Throws synchronously with error code `invalid` if any queue in
  `recordingQueues` is recording to a different graph.

|===

Table {counter: tableNumber}. Member functions of the `command_graph` class (executable graph update).
[cols="2a,a"]
|===
|Member function|Description

|
[source, c++]
----
void command_graph<graph_state::executable> update(const command_graph<graph_state::modifiable>& graph);
----

|Updates the executable graph node inputs & outputs from a topologically
identical modifiable graph. The effects of the update will be visible
on the next submission of the executable graph without the need for additional
user synchronization. No changes to commands themselves will occur, such as to
updating kernel or host task code to match that of the modifiable graph.

Preconditions:

* This member function is only available when the `command_graph` state is
  `graph_state::executable`.

Parameters:

* `graph` - Modifiable graph object to update graph node inputs & outputs with.
  This graph must have the same topology as the original graph used on
  executable graph creation.

Exceptions:

* Throws synchronously with error code `invalid` if the topology of `graph` is
  not the same as the existing graph topology, or if the nodes were not added in
  the same order.
|===

=== Queue Class Modifications

:queue-class: https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#sec:interface.queue.class

This extension modifies the {queue-class}[SYCL queue class] such that
<<queue-state, state>> is introduced to queue objects, allowing an instance to be
put into a mode where command-groups are recorded to a graph rather than
submitted immediately for execution.

<<new-queue-member-functions, Three new member functions>> are also added to the
`sycl::queue` class in this extension as queue shortcuts for `handler::graph()`.

==== Queue State

:queue-info-table: https://registry.khronos.org/SYCL/specs/sycl-2020/html/sycl-2020.html#table.queue.info

The `sycl::queue` object can be in either of two states. The default
`queue_state::executing` state is where the queue has its normal semantics of
submitted command-groups being immediately scheduled for asynchronous execution.

The alternative `queue_state::recording` state is used for graph construction.
Instead of being scheduled for execution, command-groups submitted to the queue
are recorded to a graph object as new nodes for each submission. After recording
has finished and the queue returns to the executing state, the recorded commands are
not then executed, they are transparent to any following queue operations.

.Queue State Diagram
[source, mermaid]
....
graph LR
    Executing -->|Begin Recording| Recording
    Recording -->|End Recording| Executing
....

The state of a queue can be queried with `queue::get_info` using template
parameter `info::queue::state`. The following entry is added to the
{queue-info-table}[queue info table] to define this query:

Table {counter: tableNumber}. Queue info query
[cols="2a,a,a"]
|===
| Queue Descriptors | Return Type | Description

| `info::queue::state`
| `ext::oneapi::experimental::queue_state`
| Returns the state of the queue

|===

Events returned from queue submissions when a queue is in the recording state
may only be used as parameters to `handler::depends_on()` or as dependent
events for queue shortcuts like `queue::parallel_for()` for submissions which
are being recorded to the same modifiable `command_graph`. These events have
status `info::event_command_status::complete`. The event status of an event
returned from an executable graph submission will have
`info::event_command_status::running` once any command group node starts
executing on a device, and status `info::event_command_status::complete`
once all the nodes have finished execution.

Waiting on an event returned from a queue submission recorded to a graph
will throw synchronously with error code `invalid`.

Calling `queue::wait()` on a queue in the recording state is an error and
will throw synchronously with error code `invalid`.

==== Queue Properties

:queue-properties: https://registry.khronos.org/SYCL/specs/sycl-2020/html/sycl-2020.html#sec:queue-properties

There are {queue-properties}[two properties] defined by the core SYCL
specification that can be passed to a `sycl::queue` on construction via the
property list parameter. They interact with this extension in the following
ways:

1. `property::queue::in_order` - When a queue is created with the in-order
   property, recording its operations results in a straight-line graph, as each
   operation has an implicit dependency on the previous operation. However,
   a graph submitted to an in-order queue will keep its existing structure such
   that the complete graph executes in-order with respect to the other
   command-groups submitted to the queue.

2. `property::queue::enable_profiling` - This property has no effect on graph
   recording. When set on the queue a graph is submitted to however, it allows
   profiling information to be obtained from the event returned by a graph
   submission. As it is not defined how a submitted graph will be split up for
   scheduling at runtime, the `uint64_t` timestamp reported from a profiling
   query on a graph execution event has the following semantics, which may be
   pessimistic about execution time on device.

   * `info::event_profiling::command_submit` - Timestamp when the graph is
      submitted to the queue.
   * `info::event_profiling::command_start` - Timestamp when the first
      command-group node begins running.
   * `info::event_profiling::command_end` - Timestamp when the last
      command-group node completes execution.


For any other queue property that is defined by an extension, it is the
responsibility of the extension to define the relationship between that queue
property and this graph extension.

==== New Queue Member Functions

Table {counter: tableNumber}. Additional member functions of the `sycl::queue` class.
[cols="2a,a"]
|===
|Member function|Description

|
[source,c++]
----
event queue::ext_oneapi_graph(command_graph<graph_state::executable>& graph)
----

|Queue shortcut function that is equivalent to submitting a command-group
containing `handler::ext_oneapi_graph(graph)`.

|
[source,c++]
----
event queue::ext_oneapi_graph(command_graph<graph_state::executable>& graph,
                        event depEvent);
----

|Queue shortcut function that is equivalent to submitting a command-group
containing `handler::depends_on(depEvent)` and
`handler::ext_oneapi_graph(graph)`.

|
[source,c++]
----
event queue::ext_oneapi_graph(command_graph<graph_state::executable>& graph,
                        const std::vector<event>& depEvents);
----

|Queue shortcut function that is equivalent to submitting a command-group
containing `handler::depends_on(depEvents)` and
`handler::ext_oneapi_graph(graph)`.
|===

==== New Handler Member Functions

Table {counter: tableNumber}. Additional member functions of the `sycl::handler` class.
[cols="2a,a"]
|===
|Member function|Description

|
[source,c++]
----
void handler::ext_oneapi_graph(command_graph<graph_state::executable>& graph)
----

|Invokes the execution of a graph. Support for invoking an executable graph,
before a previous execution of the same graph has been completed is backend
specific. The runtime may throw an error.

Parameters:

* `graph` - Graph object to execute.

Exceptions:

* Throws synchronously with error code `invalid` if the handler is submitted
  to a queue which doesn't have a SYCL context which matches the context of
  the executable graph.
|===

=== Thread Safety

The new functions in this extension are thread-safe, the same as member
functions of classes in the base SYCL specification. If user code does
not perform synchronization between two threads accessing the same queue,
there is no strong ordering between events on that queue, and the kernel
submissions, recording and finalization will happen in an undefined order.

When one thread ends recording on a queue while another
thread is submitting work, which kernels will be part of the subsequent
graph is undefined. If user code enforces a total order on the queue
events, then the behavior is well-defined, and will match the observable
total order.

The returned value from the `info::queue::state` should be considered
immediately stale in multi-threaded usage, as another thread could have
preemptively changed the state of the queue.

=== Exception Safety

In addition to the destruction semantics provided by the SYCL
{crs}[common reference semantics], when a modifiable `command_graph` is
destroyed recording is ended on any queues that are recording to that
graph, equivalent to `+this->end_recording()+`.

As a result, users don't need to manually wrap queue recording code in a
`try` / `catch` block to reset the state of recording queues on an exception
back to the executing state. Instead, an uncaught exception destroying the
modifiable graph will perform this action, useful in RAII pattern usage.

=== Error Handling

Errors are reported through exceptions, as usual in the SYCL API. For new APIs,
submitting a graph for execution can generate unspecified asynchronous errors,
while `command_graph::finalize()` may throw unspecified synchronous exceptions.
Synchronous exception errors codes are defined for all of
`command_graph::add()`, `command_graph::make_edge()`, `command_graph::update()`,
`command_graph::begin_recording()`, and `command_graph::end_recording()`.

Submitting an executable graph using `handler::ext_oneapi_graph()` to
a queue with a different SYCL context than that of the executable graph will
result in a synchronous exception.

When a queue is in recording mode asynchronous exceptions will not be
generated, as no device execution is occurring. Synchronous errors specified as
being thrown in the default queue executing state, will still be thrown when a
queue is in the recording state.

The `command_graph::begin_recording` and `command_graph::end_recording`
entry-points return a `bool` value informing the user whether a related queue
state change occurred. False is returned rather than throwing an exception when
no queue state is changed. This design is because the queues are already in
the state the user desires, so if the function threw an exception in this case,
the application would likely swallow it and then proceed.

While a queue is in the recording state, methods performed on that queue which
are not command submissions behave as normal except for waits. Waiting on a
queue in the recording state is an error and will throw a synchronous
exception. Other methods are ignored by the graph system as opposed to
throwing in recording mode. As any query about the state of the queue may
be immediately stale, any code which relies on queue waits should take care
to ensure waits are not performed on queues in recording mode. For example, by
using separate queues for graph recording and normal queue operations.

=== Storage Lifetimes

The lifetime of any buffer recorded as part of a submission
to a command graph will be extended in keeping with the common reference
semantics and buffer synchronization rules in the SYCL specification. It will be
extended either for the lifetime of the graph (including both modifiable graphs
and the executable graphs created from them) or until the buffer is no longer
required by the graph (such as after being replaced through executable graph update).

Because of the extension of storage lifetimes, users should avoid the use of the
buffer copy-back on destruction mechanism. If used in code intended to be
executed as part of a graph, it may not perform as expected.

=== Buffer Limitations for Record & Replay API

Because of the delayed execution of a recorded graph, it is not possible to support
captured code which relies on the copy-back on destruction behavior of buffers.
Typically, applications would rely on this behavior to do work on the host which
cannot inherently be captured inside a command graph. Thus, when recording to a graph
it is an error to submit a command which has an accessor on a buffer which would
cause a write-back to happen. Using an incompatible buffer in this case will result
in a synchronous error being thrown with error code `invalid`.

The copy-back mechanism can be disabled explicitly for buffers with attached host
storage using either `buffer::set_final_data(nullptr)` or
`buffer::set_copy_back(false)`.

It is also an error to create a host accessor to a buffer which is used in
commands which are currently being recorded to a command graph. Attempting to
construct a host accessor to an incompatible buffer will result in a
synchronous error being thrown with error code `invalid`.

=== Host Tasks

:host-task: https://registry.khronos.org/SYCL/specs/sycl-2020/html/sycl-2020.html#subsec:interfaces.hosttasks

A {host-task}[host task] is a native C++ callable, scheduled according to SYCL
dependency rules. It is valid to record a host task as part of graph, though it
may lead to sub-optimal graph performance because a host task node may prevent
the SYCL runtime from submitting the entire executable `command_graph` to the
device at once.

Host tasks can be updated as part of <<executable-graph-update, executable graph update>>
by replacing the whole node with the new callable.

=== Command Group Function Evaluation

Host code within a command group function object is evaluated when the command
group is added to a graph. This is either before the return of the call to
`command_graph::add()` when using the explicit API or before the return of the call to
`queue::submit()` when submitting a command group to a queue that is recording to a graph.

This does not apply to code within a {host-task}[host task] which is
evaluated as normal during command graph execution.

[source,c++]
----
auto node = graph.add([&](sycl::handler& cgh){
  // Host code here is evaluated during the call to add()
  cgh.host_task([=](){
    // Code here is evaluated as part of executing the command graph node
  });
});
----

=== Memory Allocation Nodes

There is no provided interface for users to define a USM allocation/free
operation belonging to the scope of the graph. It would be error prone and
non-performant to allocate or free memory as a node executed during graph
submission. Instead, such a memory allocation API needs to provide a way to
return a pointer which won't be valid until the allocation is made on graph
finalization, as allocating at finalization is the only way to benefit from
the known graph scope for optimal memory allocation, and even optimize to
eliminate some allocations entirely.

Such a deferred allocation strategy presents challenges however, and as a result
we recommend instead that prior to graph construction users perform core SYCL
USM allocations to be used in the graph submission. Before to coming to this
recommendation we considered the following explicit graph building interfaces
for adding a memory allocation owned by the graph:

1. Allocation function returning a reference to the raw pointer, i.e. `void*&`,
   which will be instantiated on graph finalization with the location of the
   allocated USM memory.

2. Allocation function returning a handle to the allocation. Applications use
   the handle in node command-group functions to access memory when allocated.

3. Allocation function returning a pointer to a virtual allocation, only backed
   with an actual allocation when graph is finalized or submitted.

Design 1) has the drawback of forcing users to keep the user pointer variable
alive so that the reference is valid, which is unintuitive and is likely to
result in bugs.

Design 2) introduces a handle object which has the advantages of being a less
error prone way to provide the pointer to the deferred allocation. However, it
requires kernel changes and introduces an overhead above the raw pointers that
are the advantage of USM.

Design 3) needs specific backend support for deferred allocation.

=== Device Specific Graph

A modifiable state `command_graph` contains nodes targeting specific devices,
rather than being a device agnostic representation only tied to devices on
finalization. This allows the implementation to process nodes which require
device information when the command group function is evaluated. For example,
a SYCL reduction implementation may desire the work-group/sub-group size, which
is normally gathered by the runtime from the device associated with the queue.

This design also enables the future capability for a user to compose a graph
with nodes targeting different devices, allowing the benefits of defining an
execution graph ahead of submission to be extended to multi-device platforms.
Without this capability a user currently has to submit individual single-device
graphs and use events for dependencies, which is a usage model this extension is
aiming to optimize. Automatic load balancing of commands across devices is not a
problem this extension currently aims to solve, it is the responsibility of the
user to decide the device each command will be processed for, not the SYCL
runtime.

== Examples

[NOTE]
====
The examples below demonstrate intended usage of the extension, but may not be
compatible with the proof-of-concept implementation, as the proof-of-concept
implementation is currently under development.
====

Examples for demonstrative purposes only, and may leave out details such as how
input data is set.

=== Dot Product

[source,c++]
----
...

#include <sycl/ext/oneapi/experimental/graph.hpp>

int main() {
  namespace sycl_ext = sycl::ext::oneapi::experimental;

  const size_t n = 10;
  float alpha = 1.0f;
  float beta = 2.0f;
  float gamma = 3.0f;

  sycl::queue q;
  sycl_ext::command_graph g(q.get_device());

  float *dotp = sycl::malloc_shared<float>(1, q);
  float *x = sycl::malloc_device<float>(n, q);
  float *y = sycl::malloc_device<float>(n, q);
  float *z = sycl::malloc_device<float>(n, q);

  // Add commands to the graph to create the following topology.
  //
  //     i
  //    / \
  //   a   b
  //    \ /
  //     c

  /* init data on the device */
  auto node_i = g.add([&](sycl::handler& h) {
    h.parallel_for(n, [=](sycl::id<1> it){
      const size_t i = it[0];
      x[i] = 1.0f;
      y[i] = 2.0f;
      z[i] = 3.0f;
    });
  });

  auto node_a = g.add([&](sycl::handler& h) {
    h.parallel_for(sycl::range<1>{n}, [=](sycl::id<1> it) {
      const size_t i = it[0];
      x[i] = alpha * x[i] + beta * y[i];
    });
  }, { sycl_ext::property::node::depends_on(node_i)});

  auto node_b = g.add([&](sycl::handler& h) {
    h.parallel_for(sycl::range<1>{n}, [=](sycl::id<1> it) {
      const size_t i = it[0];
      z[i] = gamma * z[i] + beta * y[i];
    });
  }, { sycl_ext::property::node::depends_on(node_i)});

  auto node_c = g.add(
      [&](sycl::handler& h) {
        h.parallel_for(sycl::range<1>{n},
                       sycl::reduction(dotp, 0.0f, std::plus()),
                       [=](sycl::id<1> it, auto &sum) {
                         const size_t i = it[0];
                         sum += x[i] * z[i];
                       });
      },
      { sycl_ext::property::node::depends_on(node_a, node_b)});

  auto exec = g.finalize(q.get_context());

  // use queue shortcut for graph submission
  q.ext_oneapi_graph(exec).wait();

  // memory can be freed inside or outside the graph
  sycl::free(x, q);
  sycl::free(y, q);
  sycl::free(z, q);
  sycl::free(dotp, q);

  return 0;
}


...
----

=== Diamond Dependency

The following snippet of code shows how a SYCL `queue` can be put into a
recording state, which allows a `command_graph` object to be populated by the
command-groups submitted to the queue. Once the graph is complete, recording
finishes on the queue to put it back into the default executing state. The
graph is then finalized so that no more nodes can be added. Lastly, the graph is
submitted in its entirety for execution via
`handler::ext_oneapi_graph(command_graph<graph_state::executable>)`.

[source, c++]
----
  using namespace sycl;
  queue q{default_selector{}};

  // New object representing graph of command-groups
  ext::oneapi::experimental::command_graph graph(q.get_device());
  {
    buffer<T> bufferA{dataA.data(), range<1>{elements}};
    buffer<T> bufferB{dataB.data(), range<1>{elements}};
    buffer<T> bufferC{dataC.data(), range<1>{elements}};

    // `q` will be put in the recording state where commands are recorded to
    // `graph` rather than submitted for execution immediately.
    graph.begin_recording(q);

    // Record commands to `graph` with the following topology.
    //
    //      increment_kernel
    //       /         \
    //   A->/        A->\
    //     /             \
    //   add_kernel  subtract_kernel
    //     \             /
    //   B->\        C->/
    //       \         /
    //     decrement_kernel

    q.submit([&](handler& cgh) {
      auto pData = bufferA.get_access<access::mode::read_write>(cgh);
      cgh.parallel_for<increment_kernel>(range<1>(elements),
                                         [=](item<1> id) { pData[id]++; });
    });

    q.submit([&](handler& cgh) {
      auto pData1 = bufferA.get_access<access::mode::read>(cgh);
      auto pData2 = bufferB.get_access<access::mode::read_write>(cgh);
      cgh.parallel_for<add_kernel>(range<1>(elements),
                                   [=](item<1> id) { pData2[id] += pData1[id]; });
    });

    q.submit([&](handler& cgh) {
      auto pData1 = bufferA.get_access<access::mode::read>(cgh);
      auto pData2 = bufferC.get_access<access::mode::read_write>(cgh);
      cgh.parallel_for<subtract_kernel>(
          range<1>(elements), [=](item<1> id) { pData2[id] -= pData1[id]; });
    });

    q.submit([&](handler& cgh) {
      auto pData1 = bufferB.get_access<access::mode::read_write>(cgh);
      auto pData2 = bufferC.get_access<access::mode::read_write>(cgh);
      cgh.parallel_for<decrement_kernel>(range<1>(elements), [=](item<1> id) {
        pData1[id]--;
        pData2[id]--;
      });
    });

    // queue `q` will be returned to the executing state where commands are
    // submitted immediately for extension.
    graph.end_recording();
  }

  // Finalize the modifiable graph to create an executable graph that can be
  // submitted for execution.
  auto exec_graph = graph.finalize(q.get_context());

  // Execute graph
  q.submit([&](handler& cgh) {
    cgh.ext_oneapi_graph(exec_graph);
  });

----

== Issues

=== Multi Device Graph

Allow an executable graph to contain nodes targeting different devices.

**Outcome:** This feature is something that we are considering introducing into
the extension in later revisions. It has been planned for to the extent that the
definition of a graph node is device specific.

=== Memory Allocation API

We would like to provide an API that allows graph scope memory to be
allocated and used in nodes, such that optimizations can be done on
the allocation. No mechanism is currently provided, but see the
section on <<memory-allocation-nodes, Memory Allocation Nodes>> for
some designs being considered.

**Outcome:** Designs under consideration

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes

|1|2023-03-23|Pablo Reble, Ewan Crawford, Ben Tracy, Julian Miller
|Initial public working draft

|========================================
