= SYCL_EXT_ONEAPI_GRAPH
:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

== Notice

Copyright (c) 2022 Intel Corporation.  All rights reserved.

IMPORTANT: This specification is a draft.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc. OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.

NOTE: This document is better viewed when rendered as html with asciidoctor.
GitHub does not render image icons.

This extension is written against the SYCL 2020 revision 4 specification. All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

NOTE: This extension is experimental: interfaces are subject to change later.

== Introduction

This extension introduces an interface that enables a lazy execution and easy replay of a kernel graph by separating
its definition and execution.

== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification section 6.3.3 "Feature test macros".  Therefore, an
implementation supporting this extension must predefine the macro
`SYCL_EXT_ONEAPI_GRAPH` to one of the values defined in the table below.
Applications can test for the existence of this macro to determine if the
implementation supports this feature, or applications can test the macro's
value to determine which of the extension's APIs the implementation supports.

Table 1. Values of the `SYCL_EXT_ONEAPI_GRAPH` macro.
[%header,cols="1,5"]
|===
|Value |Description
|1     |Initial extension version. Base features are supported.
|===

== SYCL Graph Terminology

Table 2. Terminology.
[%header,cols="1,3"]
|===
|Concept|Description
|graph| Class that stores structured work units and their dependencies
|node| The unit of work. Can have different attributes.
|edge| Dependency between work units. Happens-before relation.
|===

== Node

Node is a class that encapsulates tasks like SYCL kernel functions or host tasks for deferred execution.
A graph has to be created first, the structure of a graph is defined second by adding nodes and edges.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

  class node{
  };
}
----

== Edge

A dependency between two nodes representing a happens-before relationship. `sender` and `receiver` may be associated to different graphs.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

	// Adding dependency between two nodes.
    	void make_edge(node sender, node receiver);
}
----

== Graph

Graph is a class that represents a directed acyclic graph of nodes. 
A graph can have different states, can be nested, can have multiple root nodes that are scheduled for execution first and multiple leaf nodes that are scheduled for execution last. The execution of a graph has been completed when all leaf node tasks have been completed.
Member functions as listed in Table 3 to 6 can be used to add nodes to a graph.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

  enum class graph_state{
    modifiable,
    executable
  };

  template<graph_state State>
  class graph {
  public:
    operator graph<graph_state::executable>();
  };
  
  graph<graph_state::modifiable> make_graph();
  
  graph<graph_state::executable> compile(const graph<graph_state::modifiable> Graph);
  
}

----

The following member functions are added to the queue class.

[source,c++]
----

namespace sycl {

event submit(const ext::oneapi::experimental::graph<ext::oneapi::experimental::graph_state::executable>& my_graph);

} // namespace sycl

----

=== Executable Graph

A `graph` object in `graph_state::executable` represents a user generated device and context specific execution object that is submitted to a queue for execution.
The structure of such a `graph` object in this state is immutable and cannot be changed, so are the tasks assigned with each node.
Support of submitting a graph for execution, before a previous execution has been completed is backend specific. The runtime may throw an error.

=== Graph member and helper functions

Table 3. Constructor of the `graph` class.
[cols="2a,a"]
|===
|Constructor|Description

|
[source,c++]
----
/* available only when graph_state == modifiable */`
graph();
----
|Creates a `graph` object.

|===

Table 4. Member functions of the `graph` class.
[cols="2a,a"]
|===
|Member function|Description

|
[source,c++]
----
node add_node(const std::vector<node>& dep = {});
----
|This creates an empty node which is associated to no task. Its intended use is either a connection point inside a graph between groups of nodes, and can significantly reduce the number of edges ( O(n) vs. O(n^2) ). Another use-case is building the structure of a graph first and adding tasks later.

|
[source,c++]
----
template<typename T>
    node add_node(T cgf, const std::vector<node>& dep = {});
----
|This node captures a command group function object containing host task which is scheduled by the SYCL runtime or a SYCL function for invoking kernels with all restrictions that apply as described in the spec.

|===

Memory that is allocated by the following functions is owned by the specific graph. When freed inside the graph, the memory is only accessible before the `free` node is executed and after the `malloc` node is executed.

Table 5. Member functions of the `graph` class (memory operations).
[cols="2a,a"]
|===
|Member function|Description

|
[source,c++]
----
node memcpy(void* dest, const void* src, size_t numBytes, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `memcpy` operation.

|
[source,c++]
----
template<typename T> node
copy(const T* src, T* dest, size_t count, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `copy` operation.

|
[source,c++]
----
node memset(void* ptr, int value, size_t numBytes, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `memset` operation.

|
[source,c++]
----
template<typename T>
node fill(void* ptr, const T& pattern, size_t count, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `fill` operation.

|
[source,c++]
----
node malloc(void *data, size_t numBytes, usm::alloc kind, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `malloc` operation.

|
[source,c++]
----
node malloc_shared(void *data, size_t numBytes, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `malloc` operation.

|
[source,c++]
----
node malloc_host(void *data, size_t numBytes, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `malloc` operation.

|
[source,c++]
----
node malloc_device(void *data, size_t numBytes, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `malloc` operation.

|
[source,c++]
----
node free(void *data, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `free` operation.

|===

Table 6. Member functions of the `graph` class (convenience shortcuts).
[cols="2a,a"]
|===
|Member function|Description

|
[source,c++]
----
template <typename KernelName, typename KernelType>
node single_task(const KernelType &kernelFunc, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `single_task` operation.

|
[source,c++]
----
template <typename KernelName, int Dims, typename... Rest>
node parallel_for(range<Dims> numWorkItems, Rest&& rest, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `parallel_for` operation.

|
[source,c++]
----
template <typename KernelName, int Dims, typename... Rest>
node parallel_for(nd_range<Dims> executionRange, Rest&& rest, const std::vector<node>& dep = {});
----
|Adding a node that encapsulates a `parallel_for` operation.

|===

Table 7. Helper functions of the `graph` class.
[cols="a,a"]
|===
|Function name|Description

|
[source,c++]
----
graph<graph_state::modifiable> make_graph();
----
|Creates a `graph` object. It's state is `graph_state::modifiable`.

|===

=== Node member functions

Table 8. Constructor of the `node` class.
[cols="a,a"]
|===
|Constructor|Description

|
[source,c++]
----
node();
----
|Creates an empty `node` object. That encapsulates no tasks and is not assigned to a graph. Prior to execution it has to be assigned to a graph.

|===

Table 9. Member functions of the `node` class.
[cols="2a,a"]
|===
|Function name|Description

|
[source,c++]
----
void set_graph(graph<graph_state::modifiable>& Graph);
----
|Assigns a `node` object to a `graph`.

|
[source,c++]
----
template<typename T>
void update(T cgf);
----
|Update a `node` object.

|
[source,c++]
----
template<typename T>
void update(T cgf, graph<graph_state::modifiable>& Graph);
----
|Update a `node` object and assign it to a task.

|===

== Examples

NOTE: The examples below demonstrate intended usage of the extension, but are not compatible with the proof-of-concept implementation. The proof-of-concept implementation currently requires different syntax, as described in the "Non-implemented features" section at the end of this document.

1. Dot product

[source,c++]
----
...

#include <sycl/ext/oneapi/experimental/graph.hpp>

int main() {
  const size_t n = 10;
  float alpha = 1.0f;
  float beta = 2.0f;
  float gamma = 3.0f;

  sycl::queue q;

  auto g = sycl::ext::oneapi::experimental::make_graph();

  float *x , *y, *z;

  auto n_x = g.malloc_shared<float>(x, n, q);
  auto n_y = g.malloc_shared<float>(y, n, q);
  auto n_z = g.malloc_shared<float>(z, n, q);

  float *dotp = sycl::malloc_shared<float>(1, q);

  /* init data by using usm shortcut */
  auto n_i = g.parallel_for(n, [=](sycl::id<1> it){
    const size_t i = it[0];
    x[i] = 1.0f;
    y[i] = 2.0f;
    z[i] = 3.0f;
  }, {n_x, n_y, n_z});

  auto node_a = g.add_node([&](sycl::handler &h) {
    h.parallel_for(sycl::range<1>{n}, [=](sycl::id<1> it) {
      const size_t i = it[0];
      x[i] = alpha * x[i] + beta * y[i];
    });
  }, {n_i});

  auto node_b = g.add_node([&](sycl::handler &h) {
    h.parallel_for(sycl::range<1>{n}, [=](sycl::id<1> it) {
      const size_t i = it[0];
      z[i] = gamma * z[i] + beta * y[i];
    });
  }, {n_i});

  auto node_c = g.add_node(
      [&](sycl::handler &h) {
        h.parallel_for(sycl::range<1>{n},
                       sycl::reduction(dotp, 0.0f, std::plus()),
                       [=](sycl::id<1> it, auto &sum) {
                         const size_t i = it[0];
                         sum += x[i] * z[i];
                       });
      },
      {node_a, node_b});
      
  auto node_f1 = g.free(x, {node_c});
  auto node_f1 = g.free(y, {node_b});

  auto exec = compile(q);

  q.submit(exec).wait();

  // memory can be freed inside or outside the graph
  sycl::free(z, q);
  sycl::free(dotp, q);

  return 0;
}


...
----

== Issues for later investigations

. Explicit memory movement can cause POC to stall.

== Non-implemented features
Please, note that the following features are not yet implemented:

. Level Zero backend only
. Memory operation nodes not implemented
. Host node not implemented
. Submit overload of a queue. `submit(graph)` Use a combination of `executable_graph::exec_and_wait()` and queue property `sycl::ext::oneapi::property::queue::lazy_execution{}` instead.
. `class graph<graph_state>` Use dedicated `class graph` (equivalent to `graph_state == modifiable`) and `class executable_graph` (equivalent to `graph_state == executable`) instead.

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2022-02-11|Pablo Reble|Initial public working draft
|2|2022-03-11|Pablo Reble|Incorporate feedback from PR
|3|2022-05-25|Pablo Reble|Extend API and Example
|4|2022-08-10|Pablo Reble|Adding USM shortcuts
|========================================
