= SYCL_EXT_ONEAPI_DEVICE_GLOBAL

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

// This is necessary for asciidoc, but not for asciidoctor
:cpp: C++

== Introduction
In OpenCL 2.0 and later, a user is able to allocate program
scope memory which can be accessed like a {cpp} global variable by any kernel in
an OpenCL program (`cl_program`). When a program is shared between multiple devices,
each device receives its own unique instance of the program scope memory allocation.

This extension introduces device scoped memory allocations into SYCL that can be accessed
within a kernel using syntax similar to {cpp} global variables, but that have unique
instances per `sycl::device`. Mechanisms are provided for the host program to enqueue
copies to or from the allocations on a specific device.  Restrictions are
placed on the types of data that can be stored within `device_global` allocations, particularly
around copyability and constructors/destructors.

== Notice

Copyright (c) 2021 Intel Corporation.  All rights reserved.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.

== Status

Working Draft

This is a preview extension specification, intended to provide early access to
a feature for review and community feedback. When the feature matures, this
specification may be released as a formal extension.

Because the interfaces defined by this specification are not final and are
subject to change they are not intended to be used by shipping software
products.

== Version

Built On: 2021-08-01 +
Revision: 2

== Contact

Artem Radzikhovskyy, Intel (artem 'dot' radzikhovskyy 'at' intel 'dot' com)

== Contributors

Artem Radzikhovskyy, Intel +
Michael Kinsner, Intel +
Jessica Davies, Intel +
Joe Garvey, Intel +
Mohammad Fawaz, Intel +
Tommy Hoffner, Intel +
John Pennycook, Intel +
Greg Lueck, Intel +
Roland Schulz, Intel

== Dependencies

This extension is written against the SYCL 2020 specification, revision 3.

It also depends on the `SYCL_EXT_ONEAPI_PROPERTY_LIST` extension.

== Overview

[NOTE]
====
In this document, we use `device_global` to indicate the proposed `sycl::ext::oneapi::device_global`.
====

The purpose of this document is to clearly describe and specify `device_global` and related
concepts, types, and mechanisms, and to give examples and context for their usage.

=== Motivation

Device scope memory allocations can provide an efficient mechanism for communication
between multiple invocations of a kernel, or between kernels executing on a device.
There are additional benefits and optimization opportunities when a device compiler
has visibility into the allocation size (static sizing) and uses of the allocation.

Syntax allowing direct use of an allocation (without passing pointers or parameters
through function call boundaries) can also lead to syntax simplification in some
important use cases.

=== Examples

Two example `device_global` variables can be declared at namespace scope, as follows:

[source,c++]
----
struct MyClass {
  bool flag;
};

using namespace sycl::ext::oneapi;

device_global<MyClass> dm1;
static device_global<int[4]> dm2;
----

`dm1` creates an allocation on each `sycl::device` that contains an object of type `MyClass`.
`dm2` has internal linkage (due to `static`), and creates allocations containing an array
of four `int` per device.

Uses of `dm1` and `dm2` in device functions are syntactically similar to uses of global variables
in {cpp} (access directly through the namespace scope identifier), and `device_global` has
reference wrapper-like semantics on a device.  Of note, because {cpp} doesn't allow for
overloading of the "dot operator", a `get()` member of `device_global` allows a reference
to be extracted, to which the usual dot operator may be applied as in:

[source,c++]
----
sycl::queue Q;
Q.submit([&](sycl::handler& h) {
  h.single_task([=] {
    int x = 5;
    if (dm1.get().flag)
      x = dm2[0];
  });
});
----

For both `dm1` and `dm2`, the `MyClass` and `int[4]` allocations on each device are zero-initialized before any non-initialization accesses occur.

== Proposal

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification, Section 6.3.3 "Feature test macros". Therefore, an
implementation supporting this extension must predefine the macro
`SYCL_EXT_ONEAPI_DEVICE_GLOBAL` to one of the values defined in the table below.
Applications can test for the existence of this macro to determine if the
implementation supports this feature, or applications can test the macro's
value to determine which of the extension's features
that the implementation supports.

[%header,cols="1,5"]
|===
|Value |Description
|1     |Initial extension version
|===

=== Representation of device globals

`device_global` provides a mechanism to allocate device scope memory - memory which has unique underlying storage (of type _T_) for each `sycl::device` object. If multiple device objects are present then each device object receives its own unique underlying allocation. All kernels that reference the same `device_global` entity (either directly or via a pointer to its underlying object of type _T_) share the same allocation of that object when those kernels run on the same device.

`device_global` allocations are in the global address space, as are any underlying allocations of type `T` which are implicitly allocated on each device as a result of a `device_global` object. It is undefined behavior if the host program directly accesses a `device_global` or any address obtained from a `device_global` member function, and similarly it is undefined behavior if a `device_global` or address obtained on one device from a `device_global` member function is accessed on a different device.  There is no mechanism to obtain addresses of or directly access a device's `device_global` allocation within the host program.

A `device_global` on a given device maintains its state (address of the allocation and data within the allocation) even after the application changes the value of a specialization constant via `handler::set_specialization_constant()`.  Additionally, a `device_global` maintains its state even when it is referenced from a kernel in a different `kernel_bundle`.

[source,c++]
----
namespace sycl::ext::oneapi {
template <typename T, typename PropertyListT = property_list<>>
class device_global {
  ...
----

`device_global` is a class template, parameterized by the type of the underlying allocation _T_, and a list of properties _PropertyListT_. The type of the allocation _T_ also encodes the size of the allocation for potentially multidimensional array types.

_T_ is restricted to types that have a trivial destructor and a trivial default constructor in this revision of the specification (the constructor restriction may be partially relaxed in a future revision). _PropertyListT_ enables properties to be associated with a `device_global`.

Since _T_ is restricted to types with trivial default constructors in this version of the specification, there are no non-default `device_global` constructors, and therefore no initialization values may be specified for the content of a `device_global` allocation on a device.

The allocation of type _T_ is zero-initialized on each device prior to the first access to that `device_global` variable.

`device_global` may only be declared with static storage duration at namespace scope or class scope. If a `device_global` is declared with any other storage duration or scope, the program is ill-formed.

Properties may be specified for a `device_global` to provide semantic modification or optimization hint information to the compiler.  Specific properties are defined in other extensions, but example uses of a property (with a "no copy" attribute described by another extension) are:

[source,c++]
----
device_global<MyClass, property_list_t<no_copy::value_t>> dm1;
device_global<int[4], property_list_t<no_copy::value_t>> dm2;
----

[NOTE]
====

On a device, `device_global` has similar semantics to a reference wrapper.  The dot operator (`operator.`) cannot be overloaded, so a `get()` member is provided to allow a reference to be extracted directly when needed.  Some operators are declared in `device_global` that must be members (e.g. `operator[]` and `+operator->+`).  Note that other operators can be overloaded by specific `T` as free functions, which will be selected through implicit conversion to `T` in device functions.

====


The section below and the table following describe the constructors, member functions and factory methods for `device_global`.

[source,c++]
----
namespace sycl::ext::oneapi {

template <typename T, typename PropertyListT = property_list<>>
class device_global {
  using subscript_return_t =
    std::remove_reference_t<decltype(std::declval<T>()[std::ptrdiff_t{}])>;

public:
  using element_type = std::remove_extent_t<T>; 
  
  static_assert(std::is_trivially_default_constructible_v<T>,
                "Type T must be trivially default constructable (until C++20 "
                "consteval is supported and enabled)");

  static_assert(std::is_trivially_destructible_v<T>,
      "Type T must be trivially destructible.");

  // Only default construction is allowed.  The underlying memory allocations
  // of type T on devices will be zero-initialized before any non-initialization
  // accesses occur.
  device_global();

  device_global(const device_global &) = delete;
  device_global(const device_global &&) = delete;
  device_global &operator=(const device_global &) = delete;
  device_global &operator=(const device_global &&) = delete;

  template <access::decorated IsDecorated>
  multi_ptr<T, access::address_space::global_space, IsDecorated>
    get_multi_ptr() noexcept;

  template <access::decorated IsDecorated>
  multi_ptr<const T, access::address_space::global_space, IsDecorated>
    get_multi_ptr() const noexcept;

  // Access the underlying data
  operator T&() noexcept;
  operator const T&() const noexcept;
 
  T& get() noexcept;
  const T& get() const noexcept;

  // Enable assignments from underlying type
  device_global& operator=(const T&) noexcept;

  // Available if the operator[] is valid for objects of type T
  subscript_return_t& operator[]( std::ptrdiff_t idx ) noexcept;
  const subscript_return_t& operator[]( std::ptrdiff_t idx ) const noexcept;

  // Available if the operator-> is valid for objects of type T
  T& operator->() noexcept;
  const T& operator->() const noexcept;

  // Note that there is no need for "device_global" to define member functions for
  // operators like "++", comparison, etc.  Instead, the type "T" need only define
  // these operators as non-member functions.  Because there is an implicit conversion
  // from "device_global" to "T&", the operations can be applied to objects of type
  // "device_global<T>".

  template<typename propertyT>
  static constexpr bool has_property();

  // The return type is an unspecified internal class used to represent 
  // instances of propertyT
  template<typename propertyT>
  static constexpr /*unspecified*/ get_property();
};

} // namespace sycl::ext::oneapi
----

[frame="topbot",options="header"]
|===
|Functions |Description

// --- ROW BREAK ---
a|
[source,c++]
----
device_global();
----
|
Constructs a `device_global` object, and implicit storage for `T` in the global address space on each device that may access it.

The storage on each device for `T` is zero-initialized.

`T` must be trivially default constructable and trivially destructible.

// --- ROW BREAK ---
a|
[source,c++]
----
template <access::decorated IsDecorated>
multi_ptr<T, access::address_space::global_space, IsDecorated>
  get_multi_ptr() noexcept;

template <access::decorated IsDecorated>
multi_ptr<T, access::address_space::global_space, IsDecorated>
  get_multi_ptr() const noexcept;

----
|
Available only in device functions.

Returns a `multi_ptr` to the underlying `T` on the device. It is undefined behavior to dereference the returned pointer or any address derived from the pointer on a different device or on the host.

// --- ROW BREAK ---
a|
[source,c++]
----
operator T&() noexcept;
operator const T&() const noexcept;
----
|
Available only in device functions.

Implicit conversion to a reference to the underlying `T` on the device. It is undefined behavior to access the reference or any address derived from it on a different device or on the host.

// --- ROW BREAK ---
a|
[source,c++]
----
T& get() noexcept;
const T& get() const noexcept;
----
|
Available only in device functions.

Returns a reference to the underlying `T` on the device. It is undefined behavior to access the reference or any address derived from it on a different device or on the host.

// --- ROW BREAK ---
a|
[source,c++]
----
device_global& operator=(const T&) noexcept;
----
|
Available only in device functions.

Enables assignment of type `T` to the underlying allocation on the device.

// --- ROW BREAK ---
a|
[source,c++]
----
element_type& operator[]( std::ptrdiff_t idx ) noexcept;
const element_type& operator[]( std::ptrdiff_t idx ) const noexcept;
----
|
Available only in device functions.

Available only when the underlying `T` defines an `operator[]`.

Indexes into the underlying `T`. It is undefined behavior if _idx_ is negative.

// --- ROW BREAK ---
a|
[source,c++]
----
T& operator->() noexcept;
const T& operator->() const noexcept;
----
|
Available only in device functions.

Available only when `+operator->+` is valid for objects of type `T`.

Provides member access through `T` that is a pointer or a class which defines `+operator->+`.

// --- ROW BREAK ---
a|
[source,c++]
----
template<typename propertyT>
static constexpr bool has_property();
----
| Returns true if the `PropertyListT` contains the property specified by `propertyT`. Returns false if it does not.
Available only if `sycl::is_property_of_v<propertyT, sycl::ext::oneapi::device_global>` is true.

// --- ROW BREAK ---
a|
[source,c++]
----
template<typename propertyT>
static constexpr auto get_property();
----
| Returns an object of the class used to represent the value of property `propertyT`.
Must produce a compiler diagnostic if `PropertyListT` does not contain a `propertyT` property.
Available only if `sycl::is_property_of_v<propertyT, sycl::ext::oneapi::device_global>` is true.

|===

=== Relax language restrictions for SYCL device functions

SYCL 2020 restrictions must be relaxed to allow `device_global` to be used within
device functions without being `const` or `constexpr` and without being zero-initialized
or constant-initialized.  This is achieved by adding `device_global` exceptions to the
following point in Section 5.4 "Language restrictions for device functions".  The modified restriction is:

* Variables with static storage duration that are odr-used inside a device function, must be
`const` or `constexpr` and zero-initialized or constant-initialized, except if the variable is
of type `device_global` in which case it can be odr-used inside a device function without being
`const`/`constexpr` or zero-/constant-initialized.
** Amongst other things, this restriction makes it illegal for a device function to access a
global variable that isn't `const` or `constexpr` unless the variable is of type `device_global`.


=== Add new copy and memcpy members to the queue class

Add the following functions to the `sycl::queue` interface described in Section 4.6.5.1 of
the SYCL 2020 specification.

[NOTE]
====
A pointer to the allocation within a `device_global` may not be obtained by the host program (can only be extracted in device functions because allocations are per device), so pointer arithmetic can therefore not be used in the host program to define `copy`/`memcpy` offsets into data.  `startIndex` and `offset` arguments are provided in these interfaces to allow offsetting without pointer arithmetic.
====

```c++
namespace sycl {
class queue {
public:
  // Copy to device_global
  template <typename T, typename PropertyListT>
  event copy(const std::remove_all_extents_t<T> *src,
    device_global<T, PropertyListT>& dest,
    size_t count = sizeof(T) / sizeof(std::remove_all_extents_t<T>),
    size_t startIndex = 0);
  
  template <typename T, typename PropertyListT>
  event copy(const std::remove_all_extents_t<T> *src,
    device_global<T, PropertyListT>& dest,
    size_t count, size_t startIndex, event depEvent);
  
  template <typename T, typename PropertyListT>
  event copy(const std::remove_all_extents_t<T> *src,
    device_global<T, PropertyListT>& dest,
    size_t count, size_t startIndex,
    const std::vector<event> &depEvents);

  // Copy from device_global
  template <typename T, typename PropertyListT>
  event copy(const device_global<T, PropertyListT>& src,
    std::remove_all_extents_t<T> *dest,
    size_t count = sizeof(T) / sizeof(std::remove_all_extents_t<T>),
    size_t startIndex = 0);

  template <typename T, typename PropertyListT>
  event copy(const device_global<T, PropertyListT>& src,
    std::remove_all_extents_t<T> *dest,
    size_t count, size_t startIndex, event depEvent);
  
  template <typename T, typename PropertyListT>
  event copy(const device_global<T, PropertyListT>& src,
    std::remove_all_extents_t<T> *dest,
    size_t count,size_t startIndex, const std::vector<event> &depEvents);

  // memcpy to device_global
  template <typename T, typename PropertyListT>
  event memcpy(device_global<T, PropertyListT>& dest, 
    const void *src, size_t numBytes = sizeof(T), size_t offset = 0);
  
  template <typename T, typename PropertyListT>
  event memcpy(device_global<T, PropertyListT>& dest,
    const void *src, size_t numBytes,
    size_t offset, event depEvent);
  
  template <typename T, typename PropertyListT>
  event memcpy(device_global<T, PropertyListT>& dest,
    const void *src, size_t numBytes,
    size_t offset, const std::vector<event> &depEvents);

  // memcpy from device_global
  template <typename T, typename PropertyListT>
  event memcpy(void *dest,
    const device_global<T, PropertyListT>& src,
    size_t numBytes = sizeof(T), size_t offset = 0);

  template <typename T, typename PropertyListT>
  event memcpy(void *dest, 
    const device_global<T, PropertyListT>& src, size_t numBytes,
    size_t offset, event depEvent);
  
  template <typename T, typename PropertyListT>
  event memcpy(void *dest,
    const device_global<T, PropertyListT>& src, size_t numBytes,
    size_t offset, const std::vector<event> &depEvents);
};
} // namespace sycl
```


Add the following function descriptions to the `sycl::queue` interface description table
in Section 4.6.5.1 of the SYCL 2020 specification.

--
[options="header"]
|====
| Function Definition | Function type
a| 
[source, c++]
----
template <typename T, typename PropertyListT>
event copy(const std::remove_all_extents_t<T> *src,
  device_global<T, PropertyListT>& dest,
  size_t count = sizeof(T) / sizeof(std::remove_all_extents_t<T>),
  size_t startIndex = 0);
----
| Explicit copy
  
a| 
[source, c++]
----
template <typename T, typename PropertyListT>
event copy(const std::remove_all_extents_t<T> *src,
  device_global<T, PropertyListT>& dest,
  size_t count, size_t startIndex, event depEvent);
----
| Explicit copy
  
a| 
[source, c++]
----
template <typename T, typename PropertyListT>
event copy(const std::remove_all_extents_t<T> *src,
  device_global<T, PropertyListT>& dest,
  size_t count, size_t startIndex, const std::vector<event> &depEvents);
----
| Explicit copy

a| 
[source, c++]
----
template <typename T, typename PropertyListT>
event copy(const device_global<T, PropertyListT>& src,
  std::remove_all_extents_t<T> *dest,
  size_t count = sizeof(T) / sizeof(std::remove_all_extents_t<T>),
  size_t startIndex = 0);
----
| Explicit copy

a| 
[source, c++]
----
template <typename T, typename PropertyListT>
event copy(const device_global<T, PropertyListT>& src,
  std::remove_all_extents_t<T> *dest,
  size_t count, size_t startIndex, event depEvent);
----
| Explicit copy
  
a| 
[source, c++]
----
template <typename T, typename PropertyListT>
event copy(const device_global<T, PropertyListT>& src,
  std::remove_all_extents_t<T> *dest,
  size_t count, size_t startIndex, const std::vector<event> &depEvents);
----
| Explicit copy

a| 
[source, c++]
----
template <typename T, typename PropertyListT>
event memcpy(device_global<T, PropertyListT>& dest,
  const void *src, size_t numBytes = sizeof(T), size_t offset = 0);
----
| Explicit copy
  
a| 
[source, c++]
----
template <typename T, typename PropertyListT>
event memcpy(device_global<T, PropertyListT>& dest,
  const void *src, size_t numBytes,
  size_t offset, event depEvent);
----
| Explicit copy
  
a| 
[source, c++]
----
template <typename T, typename PropertyListT>
event memcpy(device_global<T, PropertyListT>& dest,
  const void *src, size_t numBytes,
  size_t offset, const std::vector<event> &depEvents);
----
| Explicit copy

a| 
[source, c++]
----
template <typename T, typename PropertyListT>
event memcpy(void *dest,
  const device_global<T, PropertyListT>& src,
  size_t numBytes = sizeof(T), size_t offset = 0);
----
| Explicit copy

a| 
[source, c++]
----
template <typename T, typename PropertyListT>
event memcpy(void *dest,
  const device_global<T, PropertyListT>& src, size_t numBytes,
  size_t offset, event depEvent);
----
| Explicit copy
  
a| 
[source, c++]
----
template <typename T, typename PropertyListT>
event memcpy(void *dest,
  const device_global<T, PropertyListT>& src, size_t numBytes,
  size_t offset, const std::vector<event> &depEvents);
----
| Explicit copy
|====
--


=== Add new copy and memcpy members to the handler class

Add the following functions to the `sycl::handler` interface described in Section 4.9.4.3 of
the SYCL 2020 specification.

Add to Table 130, "Member functions of the handler class".

--
[options="header"]
|====
| Member Function | Description
a| 
[source, c++]
----
template <typename T, typename PropertyListT>
void copy(const std::remove_all_extents_t<T> *src,
  device_global<T, PropertyListT>& dest,
  size_t count = sizeof(T) / sizeof(std::remove_all_extents_t<T>),
  size_t startIndex = 0);
----
| `T` must be device copyable.

Copies _count_ elements of type `std::remove_all_extents_t<T>` from the pointer _src_ to the `device_global` _dest_, starting at _startIndex_ elements of _dest_. _src_ may be either a host or USM pointer.
a| 
[source, c++]
----
template <typename T, typename PropertyListT>
void copy(const device_global<T, PropertyListT>& src,
  std::remove_all_extents_t<T> *dest,
  size_t count = sizeof(T) / sizeof(std::remove_all_extents_t<T>),
  size_t startIndex = 0);
----
| `T` must be device copyable.

Copies _count_ elements of type `std::remove_all_extents_t<T>` from the `device_global` _src_ to the pointer _dest_, starting at _startIndex_ elements of _src_. _dest_ may be either a host or USM pointer.

a| 
[source, c++]
----
template <typename T, typename PropertyListT>
void memcpy(device_global<T, PropertyListT>& dest,
  const void *src, size_t numBytes = sizeof(T), size_t offset = 0);
----
|`T` must be device copyable.

Copies _count_ bytes from the pointer _src_ to the `device_global` _dest_, starting at _offset_ bytes. _src_ may be either a host or USM pointer.

a| 
[source, c++]
----
template <typename T, typename PropertyListT>
void memcpy(void *dest,
  const device_global<T, PropertyListT>& src,
  size_t numBytes = sizeof(T), size_t offset = 0);
----
|`T` must be device copyable.

Copies _count_ bytes from the `device_global` _src_ to the pointer _dest_, starting at _offset_ bytes. _dest_ may be either a host or USM pointer.
|====
--


== Non-normative: Future anticipated changes, not enabled within this version of the specification

In a future version of this extension, it is expected that when {cpp}20 support is available and enabled, the `consteval` keyword will be used to enable compile-time constant initialization of the device allocations backing `device_global`.  This will simplify some coding patterns, compared with the current zero-initialization requirement.

A sketch of the anticipated constructor interface is:

[source,c++]
----
namespace sycl::ext::oneapi {

template <typename T, typename PropertyListT = property_list<>>
class device_global {
public:
  using element_type = std::remove_extent_t<T>; 
  
  static_assert(std::is_trivially_destructible_v<T>,
      "Type T must be trivially destructible.");

  #ifdef __cpp_consteval
    device_global();

    // device_global initializes underlying T with the args argument
    template <typename... Args>
    consteval explicit device_global(Args&&... args);
  #else
    static_assert(std::is_trivially_default_constructible_v<T>,
                  "Type T must be trivially default constructable (until C++20 "
                  "consteval is supported and enabled)");

    device_global();
  #endif // __cpp_consteval

----

The example below creates two global namespace scope `device_global` objects named `dm1` and `dm2`. `dm1` is default constructed with external linkage, while `dm2` is initialized and has internal linkage.

[source,c++]
----
using namespace sycl;
using namespace sycl::ext::oneapi;

device_global<MyClass> dm1;
static device_global<int[4]> dm2{1, 3, 5, 7};  // Requires C++20 to be enabled

int main () {
  sycl::queue Q;
  Q.submit([&](sycl::handler& h) {
    h.single_task([=] {
      int x = 5;
      if (dm1.get().flag)
        x = dm2[0];
    });
  });
}
----

== Non-normative: Implementation hints

`device_global` prioritizes usability over simplicity of implementation, and therefore adds requirements such as (1) that contents and addresses of the allocation on each device remain stable across changes to specialization constant values, and (2) that the allocation be accessible across `device_image` on the same device.  These requirements mean that the semantics of `device_global` do not match the semantics of SPIR-V module scope variables, and therefore may not be implementable exclusively using the SPIR-V feature in existing SPIR-V consuming implementations.

Also note that there are no restrictions on passing (and subsequent dereferencing) of pointers obtained on a device from a `device_global`, between kernels on the same device, including through storage to memory.

== Issues

1) Can `sycl::atomic_ref` be used with `device_global`? +
*Resolved*: Yes, but only on the device side.  There is no visibility/communication across devices because each device receives a unique allocation of type _T_ underlying the `device_global`.  There is no way for an `atomic_ref` associated with the allocation to be created in host code because there is no way to extract a pointer or reference in host code (only copy/memcpy).

2) Should we restrict `device_global` to static storage duration, and if so how? +
*Resolved*: Yes, through similar language as `specialization_id`. Moreover restricted to namespace scope, because it is expensive to implement function scope statics. This could change if a compelling use case arises that needs function scope static support. 

3) Should the returned `multi_ptr` default to decorated or an undecorated? +
*Resolved*: No default - follow convention on this set by multi_ptr

4) Is a mechanism needed that can mark device accesses as read only, while allowing for host write access? +
*Resolved*: No known compelling use cases at this point.

5) Are there important use cases that require arbitrary destructors to be supported by `device_global`? +
*Resolved*: No important cases known at this time. May loosen restriction in the future.


== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2021-06-11|Artem Radzikhovskyy|*Initial review version*
|2|2021-08-01|Mike Kinsner|Restrict to trivial default constructors for first release, change from pointer to reference semantics, swap order of arguments in `copy` functions, update and clarify wording, remove factory functions.
|========================================
