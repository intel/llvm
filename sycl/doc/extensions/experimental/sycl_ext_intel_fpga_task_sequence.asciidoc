= sycl_ext_intel_fpga_task_sequence
:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

[float]

== Contributors

// spell-checker: disable
Jessica Davies, Intel +
Joe Garvey, Intel +
Robert Ho, Intel +
Tommy Hoffner, Intel +
Ajaykumar Kannan, Intel +
Michael Kinsner, Intel +
// spell-checker: enable

== Notice

Copyright (c) 2021 Intel Corporation

Intel Confidential

== Status

Working Draft

This is a preview extension specification, intended to provide early access to a feature for review and community feedback. When the feature matures, this specification may be released as a formal extension.

Because the interfaces defined by this specification are not final and are subject to change they are not intended to be used by shipping software products.

== Version

Built On: {docdate} +
Revision: C

== Dependencies

This extension is written against the SYCL 2020 specification, revision 3.

== Overview

Although SYCL supports task-level parallelism through device kernels, there is no specific mechanism to express parallelism at a sub-kernel level or to invoke additional kernels without involving the host program. In OpenCL 2.0 and beyond, kernel invocations can be initiated without host program interaction through device side enqueue. C++11 also introduced `std::async()` for task-level parallelism. However, neither of these approaches is a good fit for spatial compute platforms, which require a clear mapping of parallel constructs to spatial instances in the hardware.

Rather than significantly changing the semantics of existing solutions, this extension introduces a sub-kernel task-level parallelism interface to SYCL for use in device code. It provides the class +task_sequence+, which is an abstraction of an asynchronous sequence of invocations of a callable that can be executed asynchronously from the caller, and with which a clear mapping to spatial hardware instances can be reasoned about when developing applications.

== Definitions



== `task_sequence` class

[source,c++,linenums]
----
namespace sycl {
namespace ext {
namespace intel {
namespace experimental {

template<auto& f>
struct task_sequence{};

template <typename ReturnT, typename... ArgsT, ReturnT (&f)(ArgsT...),
          typename propertyListT = property_list<>>
class task_sequence<f, property_list> {

  typedef ReturnT (*f_t)(ArgsT...);

public:
  task_sequence(const task_sequence &) = delete;
  task_sequence &operator=(const task_sequence &) = delete;
  task_sequence(task_sequence &&) = delete;
  task_sequence &operator=(task_sequence &&) = delete;

  task_sequence();

  task_sequence(const propertyListT &);

  void async(ArgsT... args);

  ReturnT get();

  ~task_sequence();
};

} // namespace experimental
} // namespace intel
} // namespace ext
} // namespace sycl

----

`task_sequence` is a class template, parameterized by an `auto` reference to a +Callable+ `f`. The +Callable+ `f` defines the asynchronous task to be associated with the `task_sequence`, and requiring an auto reference ensures that each `f` be statically resolvable at compile time.  Static resolvability by the compiler is desirable when compiling for spatial architectures as it can enable the generation of more efficient hardware. Furthermore, the partial specialization `typename ReturnT, typename ... ArgsT, ReturnT(&f) (ArgsT...)` ensures that the return type `ReturnT` of `f` and the argument types `typename ... ArgsT` of `f` are resolvable and fixed for each definition of `task_sequence`. 

The `task_sequence` interface consists of two methods, `async` and `get`. The `async` method asynchronously invokes `f`, and stores the return value into a FIFO queue upon completion of `f`.  The `async` function call is non-blocking in that it returns before the asynchronous `f` invocation completes executing, and potentially before `f` even begins executing (return from the `async` provides no implicit information on the execution status of `f`). The `get` method retrieves the oldest result from this logical FIFO queue, and blocks (waits) until a result is available if none are available immediately upon the call to `get`. Both methods may only be invoked on the device on which a `task_sequence` object has been instantiated. Calling `async` or `get` on a different device results in undefined behavior.

[frame="topbot",options="header"]
|===
|Functions |Description
// --- ROW BREAK ---
a|
[source,c++]
----
task_sequence(const propertyListT &);

task_sequence();
----
|
Constructor for `task_sequence`. 

Accepts properties `balanced`, `invocation_capacity`, and `response_capacity` defined below
// --- ROW BREAK ---
a|
[source,c++]
----
void async(ArgsT... args);
----
|
Asynchronously calls +f+ with +args+. 

// --- ROW BREAK ---
a|
[source,c++]
----
ReturnT get();
----
|
Synchronously retrieves the result of an `async` call. 

Results are retrieved in FIFO order of their `async` invocations. 

// --- ROW BREAK ---
a|
[source,c++]
----
~task_sequence();
----
|
Destructor for `task_sequence`. 

Implicitly invokes `get` on all outstanding invocations launched through `async` unless this `task_sequence` object was instantiated with the `balanced` property defined below.
|===

=== `task_sequence` Scoping

To allow compilers targeting spatial compute architectures to efficiently reuse hardware, `task_sequence` objects must not have their lifetime extended beyond the scope in which they are declared, and it is undefined behavior if lifetime is otherwise extended. Both move and copy constructors for `task_sequence` are therefore deleted. Additionally, `task_sequence` objects should retire all outstanding `async` invocations before exiting scope - this is performed by the `task_sequence` destructor unless the `balanced` property was specified in which case it is the programmer's responsibility to ensure that `get` has been called for all invocations launched using `async`, before the lifetime of the `task_sequence` object ends.

In this example implementation below, a count of outstanding `async` invocations is kept by incrementing a private counter upon each `async`, and decrementing upon each `get`. The destructor calls `get` on all `outstanding` `async` invocations remaining, ensuring that no `async` invocations execute beyond the object's lifetime. 

Although retiring outstanding `async` s in the destructor is necessary to ensure that `async` s do not outlive their `task_sequence`, it is expected that many common coding patterns will guarantee that the number of `async` and `get` calls match (are balanced) before a `task_sequence` object is destroyed, meaning that a simple destructor will be sufficient in these cases. To provide more information to the compiler and to relax the requirement for `get` to be invoked implicitly in the `task_sequence` destructor, the property `balanced` may be specified on a `task_sequence` object, which guarantees that a user will not allow a destructor on that `task_sequence` object to be called when there are outstanding `async` invocations that have not been balanced by a matching `get` call. In the presence of this property, potentially expensive hardware implementing the destructor may be elided. It is undefined behavior to specify the `balanced` property on `task_sequence` and then to allow the `task_sequence` object to be destroyed while there are any `async` invocations for which `get` has not been called.

== `task_sequence` Properties

The following code and table describe the "balanced", "invocation_capacity", and "response_capacity" properties that can be provided when declaring a `task_sequence`.

[source,c++,linenums]
----
namespace sycl {
namespace ext {
namespace intel {
namespace experimental {

struct balanced {
  using value_t = property_value<balanced>;
};

struct invocation_capacity {
  template <uint32_t Size>
  using value_t = property_value<invocation_capacity, std::integral_constant<uint32_t, Size>>;
};

struct response_capacity {
  template <uint32_t Size>
  using value_t = property_value<response_capacity, std::integral_constant<uint32_t, Size>>;
};

inline constexpr balanced::value_t balanced_v;

template <uint32_t Size>
inline constexpr invocation_capacity::value_t<Size> invocation_capacity_v;

template <uint32_t Size>
inline constexpr response_capacity::value_t<Size> response_capacity_v;

} // namespace experimental
} // namespace intel
} // namespace ext
} // namespace sycl
----

--
[options="header"]
|===
| Property | Description
| balanced | The `balanced` property is a guarantee to the SYCL device compiler that the `task_sequence` object will call exactly the same number of `async` s and `get` s over the object's lifetime (i.e. before the `task_sequence` destructor is invoked). 

| invocation_capacity | The `invocation_capacity` property defines the minimum required number `Size` of `async` invocations that must be invokable without any `get` being called on that same set.  This number of `async` invocations without a `get` call is the minimum number that will be supported before the `async` member function blocks.

| response_capacity | The `response_capacity` property tells the compiler the required simultaneous capacity `Size` of get calls. The compiler must guarantee storage capacity for results of up to `Size` `async` calls.
|===
--

=== Compatibility with FPGA Kernel Interface Properties

The Callable `f` defining the asynchronous task associated with a `task_sequence` may be declared with the FPGA Kernel Interface `pipelined` property described in link:../proposed/sycl_ext_oneapi_kernel_properties.asciidoc[sycl_ext_oneapi_kernel_properties].


== Forward Progress Guarantees and Execution Model

C{plus}{plus} defines a framework for describing the http://eel.is/c++draft/intro.progress[forward progress] of individual threads with respect to one another in a multi-threaded program. 

Applying this framework to `task_sequence`, `async` tasks belonging to the same `task_sequence` object provide a http://eel.is/c++draft/intro.progress#11[weakly parallel forward progress guarantee]. That is, tasks belonging to a `task_sequence` object are not guaranteed to make forward progress with respect to each other. 

Tasks belonging to different `task_sequence` objects provide a http://eel.is/c++draft/intro.progress#9[parallel forward progress guarantee] with respect to each other. That is, tasks belonging to different `task_sequence` objects are guaranteed to make forward progress with respect to each other once they have been initiated.

Tasks belonging to a `task_sequence` object provide a http://eel.is/c++draft/intro.progress#9[parallel forward progress guarantee] with respect to their caller. That is, a `task_sequence`'s tasks are guaranteed to make forward progress with respect to their caller (that invoked `async`).

When invoked through any call(s) to `async`, callable `f` behaves as if it is a SYCL kernel invoked via `single_task` in execution and memory model terminology.  One consequence of this is that a global memory synchronization point exists on invocation completion equivalently to kernel completion.

== `task_sequence` Example Implementation 

In this section, we document a possible implementation of `task_sequence` that defines underlying intrinsic functions for constructor, destructor, `async`, and `get` calls, as well as a functional implementation of the destructor.

[source,c++,linenums]
----
template<auto &f>
struct task_sequence {};

template<typename ReturnT, typename ... ArgsT, ReturnT(&f) (ArgsT...), typename propertyListT = property_list<>>
class task_sequence<f, property_list> {

    unsigned outstanding = 0;
    size_t id;

    typedef ReturnT (*f_t)(ArgsT...);

public:
    task_sequence(const task_sequence&) =delete;
    task_sequence& operator=(const task_sequence&) =delete;
    task_sequence(task_sequence&&) =delete;
    task_sequence& operator=(task_sequence&&) =delete;
    task_sequence() {
      id = __create_task_sequence(this, &f);
    }
    task_sequence(const propertyListT &) {
      task_sequence();
    }
    template <typename property>
    void async(ArgsT... args, property P) {
      ++outstanding;
      constexpr auto capacity = property::get_property<invocation_capacity>().invocation_capacity_v;
      __async(this, &f, id, capacity, args...);
    }
    template <typename property>
    ReturnT get(property P) {
      --outstanding;
      constexpr auto capacity = property::get_property<response_capacity>().response_capacity_v;
      return __get(this, id, &f, capacity);
    }

    ~task_sequence() {
      for (unsigned i = 0; i < outstanding; ++i) __get(this, &f);
      __release_task_sequence(this);
    }
};
----
//. Title
//+
//--
//*RESOLUTION*: Description
//--


== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|A|2021-06-11|Robert Ho|*Initial revision*
|B|2021-10-25|Robert Ho|Added async_capacity and get_capacity properties. Added \__release_task_sequence intrinsic. Altered __create_task_sequence signature. Added this to all intrinsics.
|C|2022-06-23|Robert Ho|Added compatibility statement with FPGA Kernel Interface Properties
|========================================

//************************************************************************
//Other formatting suggestions:
//
//* Use *bold* text for host APIs, or [source] syntax highlighting.
//* Use +mono+ text for device APIs, or [source] syntax highlighting.
//* Use +mono+ text for extension names, types, or enum values.
//* Use _italics_ for parameters.
//************************************************************************
