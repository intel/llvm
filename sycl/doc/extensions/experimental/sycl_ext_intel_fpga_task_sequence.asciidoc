= sycl_ext_intel_fpga_task_sequence
:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

== Notice

[%hardbreaks]
Copyright (C) 2022-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.

== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues

== Contributors

// spell-checker: disable
Jessica Davies, Intel +
Joe Garvey, Intel +
Robert Ho, Intel +
Tommy Hoffner, Intel +
Ajaykumar Kannan, Intel +
Michael Kinsner, Intel +
Abhishek Tiwari, Intel
// spell-checker: enable

== Dependencies

This extension is written against the SYCL 2020 revision 6 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

This extension also depends on the link:./sycl_ext_oneapi_properties.asciidoc[
  sycl_ext_oneapi_properties] extension.

This extension interacts with but does not depend upon the
link:../sycl_ext_intel_fpga_kernel_interface_properties..asciidoc[
  sycl_ext_intel_fpga_kernel_interface_properties]
extension.

== Status

This is an experimental extension specification, intended to provide early
access to features and gather community feedback.  Interfaces defined in this
specification are implemented in {dpcpp}, but they are not finalized and may
change incompatibly in future versions of {dpcpp} without prior notice.
*Shipping software products should not rely on APIs defined in this
specification.*

== Backend support status

This extension is currently implemented in `icpx` only for FPGA devices and
only when using either the Level Zero backend or the Intel FPGA OpenCL backend.
Attempting to use this extension in kernels that run on other devices or
backends may result in undefined behavior.  Be aware that the compiler is not
able to issue a diagnostic to warn you if this happens.

== Overview

Although SYCL supports task-level parallelism through device kernels, there is
no specific mechanism to express parallelism at a sub-kernel level or to invoke
additional kernels without involving the host program. In OpenCL 2.0 and beyond,
kernel invocations can be initiated without host program interaction through
the `enqueue_kernel` API. C++11 also introduced `std::async()` for task-level
parallelism. However, neither of these approaches is a good fit for spatial
compute platforms, which require a clear mapping of parallel constructs to
spatial instances in the hardware.

Rather than significantly changing the semantics of existing solutions, this
extension introduces a sub-kernel task-level parallelism interface to SYCL for
use in device code. It provides the class
`sycl::ext::intel::experimental::task_sequence`, which is an
abstraction of an asynchronous sequence of invocations of a callable that can be
executed asynchronously from the caller. Â A single object of this class can map
naturally to a single hardware instance on spatial targets.

NOTE: In this document, we use `task_sequence` to indicate the proposed
`sycl::ext::intel::experimental::task_sequence`

=== Examples

Here's an example that shows how to define and call two task sequences.

```c++
using namespace sycl::ext::intel::experimental;

// Return the sum of elements in 'v', from index 's' to 's+sz'
int vectorSum(float *v, size_t s, size_t sz) {
  ...
}

{
  sycl::queue q{...};

  constexpr int kCount = ...;
  std::vector<float> in(kCount);
  float* out = ...;
  ...

  q.single_task([=] {
    task_sequence<vectorSum> firstHalf;
    task_sequence<vectorSum> secondHalf;
    constexpr int halfCount = kCount/2;
    firstHalf.async(in.data(), 0, halfCount);
    secondHalf.async(in.data(), halfCount, halfCount);
    *out = firstHalf.get() + secondHalf.get();
  }).wait();
  ...
}
```

== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.  An implementation supporting this extension must predefine the
macro `SYCL_EXT_INTEL_FPGA_TASK_SEQUENCE` to one of the values defined in the
table below.  Applications can test for the existence of this macro to determine
if the implementation supports this feature, or applications can test the
macro's value to determine which of the extension's features the implementation
supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===

== Definitions

== `task_sequence` class

[source,c++,linenums]
----
namespace sycl::ext::intel::experimental {

template<auto &f> struct task_sequence_checker : std::false_type {};

template<typename ReturnT, typename... ArgsT, ReturnT (&f)(ArgsT...)>
struct task_sequence_checker<f> : std::true_type {};

template<auto& f, class propertiesT =
  decltype(oneapi::experimental::properties{})>
class task_sequence{ static_assert(task_sequence_checker<f>::value); };

template <typename ReturnT, typename... ArgsT, ReturnT (&f)(ArgsT...),
          class propertiesT>
class task_sequence<f, propertiesT> {

public:
  task_sequence(const task_sequence &) = delete;
  task_sequence &operator=(const task_sequence &) = delete;
  task_sequence(task_sequence &&) = delete;
  task_sequence &operator=(task_sequence &&) = delete;

  task_sequence();

  task_sequence(const propertiesT &);

  void async(ArgsT... args);

  ReturnT get();

  template <typename propertyT>
  static constexpr bool has_property();

  template <typename propertyT>
  static constexpr auto get_property();

  ~task_sequence();
};

} // namespace experimental
} // namespace intel
} // namespace ext
} // namespace sycl

----

`task_sequence` is a class template, parameterized by an `auto` reference to a
+Callable+ `f` and by a list of properties `propertiesT`.
The +Callable+ `f` defines the asynchronous task to be
associated with the `task_sequence`, and requiring an auto reference ensures
that each `f` be statically resolvable at compile time.  Static resolvability by
the compiler is desirable when compiling for spatial architectures as it can
enable the generation of more efficient hardware. Furthermore, the partial
specialization `typename ReturnT, typename ... ArgsT, ReturnT(&f) (ArgsT...)`
helps make it easier to write the class member functions (eg: `get`).

The `task_sequence` interface consists of two member functions, `async` and
`get`. The `async` function asynchronously invokes `f`. By calling `async` on a
`task_sequence` more than once, the user implies that the invocations of `f` can
be run in parallel. The implementation is, however, not obligated to run these
invocations in parallel except in so far as is necessary to meet the forward
progress guarantees outlined in the section on Progress Guarantees.

The `async` function call is non-blocking in that it may return before the
asynchronous `f` invocation completes executing, and potentially before `f` even
begins executing (return from the `async` provides no implicit information on
the execution status of `f`).

The `get` member function retrieves results in the same order in which
`async` was invoked. The call blocks if there is no result to retrieve. Both
functions may only be invoked on the device on which a `task_sequence` object
has been instantiated. Calling `async` or `get` on a different device results in
undefined behavior.

[frame="topbot",options="header"]
|===
|Functions |Description
// --- ROW BREAK ---
a|
[source,c++]
----
task_sequence(const propertyListT &);

task_sequence();
----
|
Constructor for `task_sequence`.

// --- ROW BREAK ---
a|
[source,c++]
----
void async(ArgsT... args);
----
|
Asynchronously calls `f` with `args`.

// --- ROW BREAK ---
a|
[source,c++]
----
ReturnT get();
----
|
Synchronously retrieves the result of a previous `async` call to this `task_sequence` object.

Results are retrieved in the order in which the `async` calls were made.

// --- ROW BREAK ---
a|
[source,c++]
----
~task_sequence();
----
|
Destructor for `task_sequence`.

Implicitly invokes `get` on all outstanding invocations launched through `async`
unless this `task_sequence` object was instantiated with the `balanced` property
defined below.
|===

=== `task_sequence` Scoping

`task_sequence` objects should retire all outstanding `async` invocations before
exiting scope.  This is performed by the `task_sequence` destructor unless the
`balanced` property was specified in which case it is the programmer's
responsibility to ensure that `get` has been called for all invocations launched
using `async` before the lifetime of the `task_sequence` object ends.

It is expected that many common coding patterns will guarantee that the number
of `async` and `get` calls match (are balanced) before a `task_sequence` object
is destroyed. To provide more information to the compiler and to relax the
requirement for `get` to be invoked implicitly, the property `balanced` may be
specified on a `task_sequence` object, which guarantees that a user will not
allow a destructor on that `task_sequence` object to be called when there are
outstanding `async` invocations that have not been balanced by a matching `get`
call. On spatial architectures, in the presence of this property, potentially
expensive hardware may be elided. It is undefined behavior to specify the
`balanced` property on `task_sequence` and then to allow the `task_sequence`
object to be destroyed while there are any `async` invocations for which `get`
has not been called.

== `task_sequence` Properties

The following code and table describe the properties that can be provided when
declaring a `task_sequence` object.

[source,c++,linenums]
----
namespace sycl::ext::intel::experimental {
struct balanced_key {
  using value_t = property_value<balanced_key>;
};

struct invocation_capacity_key {
  template <uint32_t Size>
  using value_t = property_value<invocation_capacity_key,
    std::integral_constant<uint32_t, Size>>;
};

struct response_capacity_key {
  template <uint32_t Size>
  using value_t = property_value<response_capacity_key,
    std::integral_constant<uint32_t, Size>>;
};

inline constexpr balanced_key::value_t balanced;

template <> struct is_property_key<balanced_key> : std::true_type {};

// TODO: Not sure if the template here should just be
// template<auto &f, class propertiesT>
template <typename ReturnT, typename ... ArgsT, ReturnT(&f) (ArgsT...),
  class propertiesT>
struct is_property_key_of<balanced_key,
  task_sequence<f, propertiesT>> : std::true_type {};

template <uint32_t Size>
inline constexpr invocation_capacity_key::value_t<Size> invocation_capacity;

template <> struct is_property_key<invocation_capacity_key> : std::true_type {};

template <typename ReturnT, typename ... ArgsT, ReturnT(&f) (ArgsT...),
  class propertiesT>
struct is_property_key_of<invocation_capacity_key,
  task_sequence<f, propertiesT>> : std::true_type {};

template <uint32_t Size>
inline constexpr response_capacity_key::value_t<Size> response_capacity;

template <> struct is_property_key<response_capacity_key> : std::true_type {};

template <typename ReturnT, typename ... ArgsT, ReturnT(&f) (ArgsT...),
  class propertiesT>
struct is_property_key_of<response_capacity_key,
  task_sequence<f, propertiesT>> : std::true_type {};

} // namespace experimental
} // namespace intel
} // namespace ext
} // namespace sycl
----

--
[options="header"]
|===
| Property | Description
| balanced | The `balanced` property is a guarantee to the SYCL device compiler
that the `task_sequence` object will call exactly the same number of `async` s
and `get` s over the object's lifetime (i.e. before the `task_sequence`
destructor is invoked).

| invocation_capacity | The `async` invocations are guaranteed to not block
as long as the number of outstanding invocations are less than or equal to
`invocation_capacity`. An outstanding invocation is a call to `async` whose
corresponding result has not yet been retrieved by a call to `get`.

| response_capacity | Given a response capacity of `N`, the user is guaranteed
that at least one outstanding `async` call will make progress as long as the
number of outstanding invocations is less than or equal to `N`.
|===
--

=== Compatibility with FPGA Kernel Interface Properties

A `task_sequence` may be declared with the following FPGA Kernel Interface
properties:

 - `pipelined`
 - `use_stall_enable_clusters`

These are described in the link:../sycl_ext_oneapi_kernel_properties.asciidoc[
sycl_ext_intel_fpga_kernel_interface_properties] document.

Normally these properties are applicable only to kernels however this extension
supports applying the properties to task sequences.

== Forward Progress Guarantees and Execution Model

C{plus}{plus} defines a framework for describing the
http://eel.is/c++draft/intro.progress[forward progress] of individual threads
with respect to one another in a multi-threaded program.

Applying this framework to `task_sequence`, `async` tasks belonging to the same
`task_sequence` object provide a http://eel.is/c++draft/intro.progress#11[
weakly parallel forward progress guarantee]. That is, tasks belonging to a
`task_sequence` object are not guaranteed to make forward progress with respect
to each other.

Tasks belonging to different `task_sequence` objects provide a
http://eel.is/c++draft/intro.progress#9[parallel forward progress guarantee]
with respect to each other. That is, tasks belonging to different
`task_sequence` objects are guaranteed to make forward progress with respect to
each other once they have been initiated.

Tasks belonging to a `task_sequence` object provide a
http://eel.is/c++draft/intro.progress#9[parallel forward progress guarantee]
with respect to their caller. That is, a task sequence's tasks are guaranteed
to make forward progress with respect to their caller (that invoked `async`).

The task sequence property `response_capacity` guarantees the user that at least
one outstanding invocation of `async` will make forward progress as long as the
number of outstanding invocations of `async` is less than or equal to
`response_capacity`.
An outstanding invocation of `async` is one whose corresponding `get` has not
been invoked. Note that if there are more than `response_capacity` number of
outstanding invocations, none of them are guaranteed to make progress until at
least one more `get` is called. This is analogous to the concept of blocking
with forward progress guarantee delegation used by parallel algorithms in the
C++ standard library:

If a thread offers weakly parallel forward progress guarantee, it does not
guarantee to eventually make progress, regardless of whether other threads make
progress or not. Such threads can still be guaranteed to make progress by
blocking with forward progress guarantee delegation: if a thread P blocks in
this manner on the completion of a set of threads S, then at least one thread in
S will offer a forward progress guarantee that is same or stronger than P. Once
that thread completes, another thread in S will be similarly strengthened. Once
the set is empty, P will unblock.

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|A|2021-06-11|Robert Ho|*Initial revision*
|B|2021-10-25|Robert Ho|Added async_capacity and get_capacity properties. Added
\__release_task_sequence intrinsic. Altered __create_task_sequence signature.
Added this to all intrinsics.
|C|2022-06-23|Robert Ho|Added compatibility statement with FPGA Kernel Interface
Properties
|D|2023-01-25|Abhishek Tiwari|Format corrections, add examples, add properties
type traits.
|========================================

//************************************************************************
//Other formatting suggestions:
//
//* Use *bold* text for host APIs, or [source] syntax highlighting.
//* Use +mono+ text for device APIs, or [source] syntax highlighting.
//* Use +mono+ text for extension names, types, or enum values.
//* Use _italics_ for parameters.
//************************************************************************
