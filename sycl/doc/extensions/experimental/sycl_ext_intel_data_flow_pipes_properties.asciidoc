= sycl_ext_intel_data_flow_pipes_properties

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]
:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

// This is necessary for asciidoc, but not for asciidoctor
:cpp: C++

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.

NOTE: This document is better viewed when rendered as html with asciidoctor.
GitHub does not render image icons.

This document describes an extension that adds compile-time constant properties
to pipes.

== Notice

Copyright (c) 2022-2024 Intel Corporation.  All rights reserved.

== Status

This is an experimental extension specification, intended to provide early
access to features and gather community feedback.  Interfaces defined in this
specification are implemented in {dpcpp}, but they are not finalized and may
change incompatibly in future versions of {dpcpp} without prior notice.
*Shipping software products should not rely on APIs defined in this
specification.*

== Version

Built On: {docdate} +
Revision: A

== Contact

Robert Ho, Intel (robert 'dot' ho 'at' intel 'dot' com)

== Contributors

Bo Lei, Intel +
Marco Jacques, Intel +
Joe Garvey, Intel +
Aditi Kumaraswamy, Intel +
Robert Ho, Intel +
Sherry Yuan, Intel +
Peter Colberg, Intel +
Zibai Wang, Intel +
Justin Rosner, Intel

== Dependencies

This extension is written against the SYCL 2020 specification, Revision 6 and
the following extensions:

- link:../supported/sycl_ext_intel_dataflow_pipes.asciidoc[SYCL_INTEL_data_flow_pipes]
- link:../experimental/sycl_ext_oneapi_properties.asciidoc[sycl_ext_oneapi_properties]

== Overview

This extension introduces properties that establish differences in the
implementation of `sycl::ext::intel::experimental::pipe`. These properties are FPGA specific. An example
of the syntax can be seen below. 

[source,c++]
----
using pipe = pipe<class some_pipe, int, min_capacity, decltype(properties{uses_valid<true>})>;
----

== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification section 6.3.3 "Feature test macros". Therefore, an implementation
supporting this extension must predefine the macro
`SYCL_EXT_INTEL_FPGA_PIPE_PROPERTIES` to one of the values defined in the table
below. Applications can test for the existence of this macro to determine if
the implementation supports this feature, or applications can test the macro's
value to determine which of the extension's APIs the implementation supports.

[%header,cols="1,5"]
|===
|Value |Description
|1     |Initial extension version.  Base features are supported.
|===

=== Pipe properties

Below is a list of compile-time-constant properties which `pipe` supports. This includes properties that can be placed on the read/write calls, or on the pipe type itself.

```c++
namespace sycl {
namespace ext {
namespace intel {
namespace experimental {

struct ready_latency_key {
  template <uint32_t Latency>
  using value_t = oneapi::experimental::property_value<
      ready_latency_key, std::integral_constant<int, Latency>>;
};

struct bits_per_symbol_key {
  template <uint32_t Bits>
  using value_t =
      oneapi::experimental::property_value<bits_per_symbol_key,
                                           std::integral_constant<int, Bits>>;
};

struct uses_valid_key {
  template <bool Valid>
  using value_t =
      oneapi::experimental::property_value<uses_valid_key,
                                           std::bool_constant<Valid>>;
};

struct uses_ready_key {
  template <bool Valid>
  using value_t =
      oneapi::experimental::property_value<uses_ready_key,
                                           std::bool_constant<Valid>>;
};

struct first_symbol_in_high_order_bits_key {
  template <bool HighOrder>
  using value_t =
      oneapi::experimental::property_value<first_symbol_in_high_order_bits_key,
                                           std::bool_constant<HighOrder>>;
};

enum class protocol_name : /* unspecified */ {
  avalon_streaming = 0,
  avalon_mm = 1,
  axi_streaming = 2
};

struct protocol_key {
  template <protocol_name Protocol>
  using value_t = oneapi::experimental::property_value<
      protocol_key, std::integral_constant<protocol_name, Protocol>>;
};

enum class latency_control_type {
  none, //default
  exact,
  max,
  min
};

struct latency_anchor_id_key {
  template <int Anchor>
  using value_t =
      oneapi::experimental::property_value<latency_anchor_id_key,
                                           std::integral_constant<int, Anchor>>;
};

struct latency_constraint_key {
  template <int Target, latency_control_type Type, int Cycle>
  using value_t = oneapi::experimental::property_value<
      latency_constraint_key, std::integral_constant<int, Target>,
      std::integral_constant<latency_control_type, Type>,
      std::integral_constant<int, Cycle>>;
};

template <uint32_t Latency>
inline constexpr ready_latency_key::value_t<Latency> ready_latency;

template <uint32_t Bits>
inline constexpr bits_per_symbol_key::value_t<Bits> bits_per_symbol;

template <bool Valid>
inline constexpr uses_valid_key::value_t<Valid> uses_valid;

template <bool Ready>
inline constexpr uses_ready_key::value_t<Ready> uses_ready;

template <bool HighOrder>
inline constexpr first_symbol_in_high_order_bits_key::value_t<HighOrder>
    first_symbol_in_high_order_bits;

template <protocol_name Protocol>
inline constexpr protocol_key::value_t<Protocol> protocol;

template <int Anchor>
inline constexpr latency_anchor_id_key::value_t<Anchor> latency_anchor_id;

template <int Target, latency_control_type Type, int Cycle>
inline constexpr latency_constraint_key::value_t<Target, Type, Cycle>
    latency_constraint;

template <class Name, class DataT, int32_t MinCapacity = 0,
          class PropertiesT = decltype(oneapi::experimental::properties{})>

namespace avalon-st {
  using sycl::ext::intel::experimental::bits_per_symbol;
  using sycl::ext::intel::experimental::bits_per_symbol_key;
  using sycl::ext::intel::experimental::first_symbol_in_high_order_bits;
  using sycl::ext::intel::experimental::first_symbol_in_high_order_bits_key;
  using sycl::ext::intel::experimental::ready_latency;
  using sycl::ext::intel::experimental::ready_latency_key;
  using sycl::ext::intel::experimental::uses_ready;
  using sycl::ext::intel::experimental::uses_ready_key;
  using sycl::ext::intel::experimental::uses_valid;
  using sycl::ext::intel::experimental::uses_valid_key;
} // namespace avalon-st

} // namespace experimental
} // namespace intel
} // namespace ext
} // namespace sycl

```

--

The following is a table of properties that can be applied to the pipe type.

[options="header"]
|====
| Property | Description

|`ready_latency`
| Valid values: Non-negative integer value.

Default value: 0

The number of cycles between when the ready signal is deasserted and when the
pipe can no longer accept new inputs.

This property only applies to the externally visible end of the pipe.

This property is only valid when the `protocol` property is *avalon_streaming*.

|`bits_per_symbol`
| Valid values: A positive integer value that evenly divides the data type size. 

Default value: 8

Describes how the data is broken into symbols on the data bus.

Data is broken down according to how you set the `first_symbol_in_high_order_bits`
property. By default, data is broken down in little endian order.

This property only applies to the externally visible end of the pipe. 

This property is only valid when the `protocol` property is *avalon_streaming*.

|`uses_valid`
| Valid values: `true` or `false`

Default value: `true`

Controls whether a valid signal is present on the pipe interface. If `false`, the
upstream source must provide valid data on every cycle that ready is asserted.

This is equivalent to changing the pipe read calls to a non-blocking call and assuming that
success is always true.

This property only applies to the externally visible end of the pipe, and only valid when
the valid signal is driven externally from the kernel, i.e., on a host-to-kernel or IO-to-kernel pipe.

This property is only valid when the `protocol` property is *avalon_streaming*
or *avalon_mm*.

|`uses_ready`
| Ready values: `true` or `false`

Default value: `true`

Controls whether a ready signal is present on the pipe interface. If `false`, the
downstream sink cannot backpressure the pipe.

This is equivalent to changing the pipe write calls to a non-blocking call and assuming that
success is always true.

This property only applies to the externally visible end of the pipe, and only valid when
the ready signal is driven externally from the kernel, i.e., on a kernel-to-host or IO-to-host pipe.

This property is only valid when the `protocol` property is *avalon_streaming*.

|`first_symbol_in_high_order_bits`
| Valid values: true or false

Default value: false

Specifies whether the data symbols in the pipe are in big-endian
order.

This property only applies to the externally visible end of the pipe.

This property is only valid when the `protocol` property is *avalon_streaming*
or *avalon_mm*.

|`protocol`
| Specifies the protocol for the pipe interface. Currently, the protocols supported
are: *avalon_streaming*, *avalon_mm*, and *axi_streaming*.
*avalon_streaming*

Provide an Avalon streaming interface as described in https://www.intel.com/content/www/us/en/docs/programmable/683091/22-3/introduction-to-the-interface-specifications.html[Intel® Avalon Interface Specifications].

*avalon_mm*

Provide an Avalon memory mapped interface as described in https://www.intel.com/content/www/us/en/docs/programmable/683091/22-3/introduction-to-the-interface-specifications.html[Intel® Avalon Interface Specifications].

*axi_streaming*

Provide an AXI4-Stream interface as described in https://documentation-service.arm.com/static/642583d7314e245d086bc8c9[AMBA 4 AXI4-Stream Protocol Specification].

The default protocol is *avalon_streaming*

|====
--

The following is a table of properties that can be applied on the read/write calls to the pipe.

[options="header"]
|====
| Property | Description

|`latency_anchor_id<N>`
| Valid values: Non-negative integer values of N

This property associated an ID with the current read/write function call, which can then be referenced by other `latency_constraint` properties elsewhere in the program to define relative latency constraints. The ID must be unique within the application, and a diagnostic is required if that condition is not met.

This property is only valid when passed as a function argument of a device side read/write method as a properties object.

|`latency_constraint<A, B, C>`
| Valid values: `A` and `C` are non-negative integer values, while `B` is a enum value from latency_control_type.

This property is a tuple of three values which cause the current read/write function call to act as an endpoint of a latency constraint relative to a specified `latency_anchor_id` defined by a different instruction.

`A` is the ID of the target anchor defined on a different instruction through a `latency_anchor_id` property.
 
`B` is an enum value: The type of control from the set {`latency_control_type::exact`, `latency_control_type::max`, `latency_control_type::min`}.

`C` is the relative clock cycle difference between the target anchor and the current function call that the constraint should infer subject to the type of the control (exact, min, max).

This property is only valud when passed as a function argument of a device side read/write method as a properties object.

|====

== Latency Control Example

[source,c++]
----
#include <sycl/ext/intel/fpga_extensions.hpp>
...
using Pipe1 = ext::intel::experimental::pipe<class PipeClass1, int, 8>;
using Pipe2 = ext::intel::experimental::pipe<class PipeClass2, int, 8>;
using Pipe3 = ext::intel::experimental::pipe<class PipeClass2, int, 8>;

myQueue.submit([&](handler &cgh) {
  cgh.single_task<class foo>([=] {
    // The following Pipe1::read is anchor 0
    int value = Pipe1::read(
        ext::oneapi::experimental::properties(latency_anchor_id<0>));

    // The following Pipe2::write is anchor 1
    // The following Pipe2::write occurs exactly 2 cycles after anchor 0
    Pipe2::write(value,
                 ext::oneapi::experimental::properties(
                     latency_anchor_id<1>,
                     latency_constraint<0, latency_control_type::exact, 2>));

    // The following Pipe3::write occurs at least 2 cycles after anchor 1
    Pipe3::write(value,
                 ext::oneapi::experimental::properties(
                     latency_constraint<1, latency_control_type::min, 2>));
  });
});
----

=== Device side pipe read/write

[source,c++]
----
namespace sycl::ext::intel::experimental {
enum class latency_control_type {
  none, // default
  exact,
  max,
  min
};

struct latency_anchor_id_key {
  template <int Anchor>
  using value_t =
      oneapi::experimental::property_value<latency_anchor_id_key,
                                           std::integral_constant<int, Anchor>>;
};

struct latency_constraint_key {
  template <int Target, latency_control_type Type, int Cycle>
  using value_t = oneapi::experimental::property_value<
      latency_constraint_key, std::integral_constant<int, Target>,
      std::integral_constant<latency_control_type, Type>,
      std::integral_constant<int, Cycle>>;
};

template <int Anchor>
inline constexpr latency_anchor_id_key::value_t<Anchor> latency_anchor_id;

template <int Target, latency_control_type Type, int Cycle>
inline constexpr latency_constraint_key::value_t<Target, Type, Cycle>
    latency_constraint;

template <class Name, class DataT, int32_t MinCapacity = 0,
          class PropertiesT = decltype(oneapi::experimental::properties{})>
class pipe {
  // Blocking
  static DataT read();

  template <typename PropertiesT>
  static DataT read( PropertiesT Properties );

  static void write( const DataT &Data);

  template <typename PropertiesT>
  static void write( const DataT &Data, PropertiesT Properties );

  // Non-blocking
  static DataT read( bool &Success );

  template <typename PropertiesT>
  static DataT read( bool &Success, PropertiesT Properties );

  static void write( const DataT &Data, bool &Success );

  template <typename PropertiesT>
  static void write( const DataT &Data, bool &Success, PropertiesT Properties );
}
} // namespace sycl::ext::intel::experimental
----

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2022-03-18|Peter Colberg|*Initial public working draft*
|2|2023-04-06|Robert Ho|Removal of unused properties, update protocols
|3|2023-08-30|Robert Ho|Add axi_streaming protocol
|4|2024-06-24|Justin Rosner|Add latency controls and update avalon_mm description
|========================================

//************************************************************************
//Other formatting suggestions:
//
//* Use *bold* text for host APIs, or [source] syntax highlighting.
//* Use +mono+ text for device APIs, or [source] syntax highlighting.
//* Use +mono+ text for extension names, types, or enum values.
//* Use _italics_ for parameters.
//************************************************************************
