= sycl_ext_oneapi_backend_level_zero_immediate_command_lists

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2023-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 6 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:../supported/sycl_ext_oneapi_backend_level_zero.md[
  sycl_ext_oneapi_backend_level_zero.md]


== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*


== Backend support status

This extension is currently implemented in {dpcpp} only for GPU devices and
only when using the Level Zero backend.  Attempting to use this extension in
kernels that run on other devices or backends may result in undefined
behavior.  Be aware that the compiler is not able to issue a diagnostic to
warn you if this happens.

== Overview

The Level Zero backend now supports low-latency submissions using
a feature known as immediate commndlists. SYCL queues may be constructed
to use either command queues or command lists. A new API
`make_queue_standard_or_immediate` allows selecting the type of SYCL queue
to construct. The companion API `get_native_standard_or_immediate`
is added to obtain the native handle being used by a SYCL queue.

== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.  An implementation supporting this extension must predefine the
macro `SYCL_EXT_ONEAPI_BACKEND_LEVEL_ZERO` to the value defined in the table
below.  Applications can test the macro's value to determine if this extension
is supported.

[%header,cols="1,5"]
|===
|Value
|Description

|4
|The APIs of this experimental extension are supported.
|===

=== New Types and Functions

This extensions adds a new input type for SYCL queue construction
and a return type for obtaining a native handle from a SYCL queue.

```c++
typedef std::variant<ze_command_queue_handle_t, ze_command_list_handle_t>
  _ze_queue_or_cmdlist;
typedef _ze_queue_or_cmdlist *NativeHandleEnhanced_t;

using backend_input_t2<backend::ext_oneapi_level_zero, queue> =
  struct {
    NativeHandleEnhanced_t NativeHandle;
    device Device;
    ext::oneapi::level_zero::ownership Ownership{
       ext::oneapi::level_zero::ownership::transfer};
  };

using backend_return_t2<backend::ext_oneapi_level_zero, queue> =
  _ze_queue_or_cmdlist;

ext::oneapi::level_zero::experimental::
make_queue_standard_or_immediate<backend::ext_oneapi_level_zero>(
    const backend_input_t2<backend::ext_oneapi_level_zero, queue> &,
    const context &)

backend_return_t2<backend::ext_oneapi_level_zero, queue>
ext::oneapi::level_zero::experimental::
get_native_standard_or_immediate<backend::ext_oneapi_level_zero, queue>
    (const queue &)
```


== Example
Here is an example of usage of these APIs:

```c++

// Level-Zero objects needed for queue creation and query
ze_command_list_handle_t ZeCommand_list = ...;
context InteropContext = ...;
device InteropDevice = ...;

// Construct input from command list
_ze_queue_or_cmdlist NativeHandle2{ZeCommand_list};
backend_input_t2<backend::ext_oneapi_level_zero, queue> InteropQueueInput{
  &NativeHandle2, InteropDevice,
  ext::oneapi::level_zero::ownership::keep
};

// Make a SYCL queue using an immediate command list
queue Queue = ext::oneapi::level_zero::experimental::
  make_queue_standard_or_immediate<backend::ext_oneapi_level_zero>
    (InteropQueueInput, InteropContext);

// Get a native handle from a SYCL queue
auto QueueNativeHandle =
  ext::oneapi::level_zero::experimental::
    get_native_standard_or_immediate<backend::ext_oneapi_level_zero, queue>
      (Queue);

// Test the type of native handle obtained
if (std::holds_alternative<ze_command_list_handle_t>(QueueNativeHandle)) {
  // It is an immediate command list; extract it
  auto List = std::get_if<ze_command_list_handle_t>(&QueueNativeHandle);
}
```
