= sycl_ext_oneapi_fpga_mem

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2023-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 7 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.


This extension also depends on the following other SYCL extensions:

* link:../supported/sycl_ext_oneapi_accessor_properties.asciidoc[
  sycl_ext_oneapi_accessor_properties.asciidoc]


== Status
Experimental

This is an experimental extension specification, intended to provide early
access to features and gather community feedback.  Interfaces defined in this
specification are implemented in {dpcpp}, but they are not finalized and may
change incompatibly in future versions of {dpcpp} without prior notice.
*Shipping software products should not rely on APIs defined in this
specification.*

== Backend support status

This extension is currently implemented in {dpcpp} only for FPGA devices. 
Attempting to use this extension in
kernels that run on other devices or backends may result in undefined
behavior. Be aware that the compiler is not able to issue a diagnostic to
warn you if this happens.

== Overview

[NOTE]
====
In this document, we use `fpga_mem` to indicate the proposed `sycl::ext::oneapi::experimental::fpga_mem`.
====

The purpose of this document is to clearly describe and specify `fpga_mem` and 
related concepts, types, and mechanisms, and to give examples and context for their usage.

=== Motivation
`fpga_mem` is a wrapper around user variables that asserts the variable should be implemented in FPGA memory resources and enables attaching compile-time hints which configure the memory resource and may impact the performance of the design.

=== Example
[source,c++]
----
struct MyClass {
  bool x;
};

using namespace sycl::ext::oneapi::experimental;

sycl::queue q;
q.single_task([=] {
  fpga_mem<int[4], decltype(properties(resource<mlab>))> fm1 {1, 3, 5, 7};
  fpga_mem<MyClass, decltype(properties(resource<mlab>))> fm2;
  fm2.get().x = fm1[0];
});
----

Above we see an example that declares `fpga_mem` variables `fm1`, `fm2`, and accesses them. 
`fm1` creates an allocation on the device that is private to the kernel and contains an array of four `int` that is initialized to {1, 3, 5, 7}. `fm2` creates an allocation on the device that is private to the kernel and contains an object of type `MyClass` that is default-initialized. Both of variables will be implemented using the MLAB hardware resource. For more details on supported properties see a section below.

`fpga_mem` has reference wrapper-like semantics, and is implicitly convertible to the wrapped type. Of note,
because {cpp} doesn't allow for overloading of the "dot operator", a `get()`
member of `fpga_mem` allows a reference to be extracted, to which the usual
dot operator may be applied.

== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification. An implementation supporting this extension must predefine the
macro `SYCL_EXT_ONEAPI_FPGA_MEM` to one of the values defined in the table
below. Applications can test for the existence of this macro to determine if
the implementation supports this feature, or applications can test the macro's
value to determine which of the extension's features the implementation
supports.


[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===

=== Representation of FPGA memory

[source,c++]
----
namespace sycl::ext::oneapi::experimental {
template <typename T, typename PropListT = sycl::ext::oneapi::property_list<>>
class fpga_mem {
  ...
----

`fpga_mem` is a class template, parameterized by the type of the underlying
allocation _T_, and a list of properties _PropListT_. The type of the
allocation _T_ also encodes the size of the allocation.

`fpga_mem` initializes the underlying object `T` with the values passed into it's constructor.

Properties may be specified for a `fpga_mem` to provide semantic
modification or optimization hint information to the compiler. See the section
below for a list of the properties that are allowed.

[NOTE]
====

`fpga_mem` has similar semantics to a reference wrapper.  The dot operator
(`operator.`) cannot be overloaded, so a `get()` member is provided to allow a
reference to be extracted directly when needed. Note that other operators can be overloaded by specific `T` as free functions,
which will be selected through implicit conversion to `T` in device functions.
====

=== FPGA Memory Interface

The section below and the table following describe the constructors, member functions for `fpga_mem`.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

template <typename T, typename PropertyListT = properties<>>
class fpga_mem {
public:
  template<typename ... S>
  constexpr fpga_mem_base(S ... args);

  template <access::decorated IsDecorated>
  multi_ptr<T, access::address_space::private_space, IsDecorated>
    get_multi_ptr() noexcept;

  template <access::decorated IsDecorated>
  multi_ptr<const T, access::address_space::private_space, IsDecorated>
    get_multi_ptr() const noexcept;

  // Access the underlying data
  operator T&() noexcept;
  operator const T&() const noexcept;
 
  T& get() noexcept;
  const T& get() const noexcept;

  // Enable assignments from underlying type
  fpga_mem& operator=(const T&) noexcept;

  // Note that there is no need for "fpga_mem" to define member functions for
  // operators like "++", "[]", "->", comparison, etc. Instead, the type "T" 
  // need only define these operators as non-member functions.  Because there 
  // is an implicit conversion from "fpga_mem" to "T&", the operations can be 
  // applied to objects of type "fpga_mem<T>"

  template<typename propertyT>
  static constexpr bool has_property();

  // The return type is an unspecified internal class used to represent 
  // instances of propertyT
  template<typename propertyT>
  static constexpr /*unspecified*/ get_property();
};

} // namespace sycl::ext::oneapi::experimental
----

[frame="topbot",options="header"]
|===
|Functions |Description

// --- ROW BREAK ---
a|
[source,c++]
----
template<typename ... S>
constexpr fpga_mem_base(S ... args);
----
|
Constructs a `fpga_mem` object, and implicit storage for `T`.

// --- ROW BREAK ---
a|
[source,c++]
----
template <access::decorated IsDecorated>
multi_ptr<T, access::address_space::private_space, IsDecorated>
  get_multi_ptr() noexcept;

template <access::decorated IsDecorated>
multi_ptr<T, access::address_space::private_space, IsDecorated>
  get_multi_ptr() const noexcept;

----
|
Returns a `multi_ptr` to the underlying `T` on the device.

// --- ROW BREAK ---
a|
[source,c++]
----
operator T&() noexcept;
operator const T&() const noexcept;
----
|
Implicit conversion to a reference to the underlying `T`.

// --- ROW BREAK ---
a|
[source,c++]
----
T& get() noexcept;
const T& get() const noexcept;
----
|
Returns a reference to the underlying `T`.

// --- ROW BREAK ---
a|
[source,c++]
----
template<typename propertyT>
static constexpr bool has_property();
----
| Returns true if the `PropertyListT` contains the property specified by `propertyT`. Returns false if it does not.
Available only if `sycl::is_property_key_of_v<propertyT, sycl::ext::oneapi::experimental::fpga_mem>` is true.

// --- ROW BREAK ---
a|
[source,c++]
----
template<typename propertyT>
static constexpr auto get_property();
----
| Returns an object of the class used to represent the value of property `propertyT`.
Must produce a compiler diagnostic if `PropertyListT` does not contain a `propertyT` property.
Available only if `sycl::is_property_key_of_v<propertyT, sycl::ext::oneapi::experimental::fpga_mem>` is true.

|===

=== Restrictions on creating fpga_mem objects

There are restrictions on how the application can create objects of type
`fpga_mem`. Applications that violate these restrictions are ill-formed.

* The `fpga_mem` variable must not itself be wrapped in a `fpga_mem` class
* The `fpga_mem` variable must not have dynamic storage duration

=== Properties for fpga memory 

The `fpga_mem` class supports several compile-time-constant properties. If
specified, these properties are included in the `PropListT` template parameter
as shown in this example:

[source,c++]
----
using namespace sycl::ext::intel;
using namespace sycl::ext::oneapi::experimental;

fpga_mem<MyClass, decltype(properties(resource<mlab>)> dm1;
----

The following code synopsis shows the set of supported properties, and the
following table describes their effect.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

enum class resource_enum : std::uint16_t { mlab, block_ram };

struct resource {
  template <resource_enum Resource>
  using value_t =
      property_value<resource,
                     std::integral_constant<resource_enum, Resource>>;
};

struct num_banks {
  template <size_t elements>
  using value_t = property_value<num_banks, std::integral_constant<elements>>;
};

struct stride_size {
  template <size_t elements>
  using value_t = property_value<stride_size, std::integral_constant<elements>>;
};

struct word_size {
  template <size_t elements>
  using value_t = property_value<word_size, std::integral_constant<elements>>;
};

enum class port_direction_enum : std::uint16_t { uni, bi };

struct port_direction {
  template <port_direction_enum Port_direction>
  using value_t =
      property_value<port_direction,
                     std::integral_constant<port_direction_enum, 
                     Port_direction>>;
};

struct clock_2x {
  template <bool Enable>
  using value_t = property_value<clock_2x, std::bool_constant<Enable>>;
};

enum class ram_stritching_enum : std::uint16_t { min_ram, max_fmax };

struct ram_stritching {
  template <ram_stritching_enum Ram_stritching>
  using value_t =
      property_value<ram_stritching,
                     std::integral_constant<ram_stritching_enum, 
                     Ram_stritching>>;
};

struct private_copies {
  template <size_t n>
  using value_t = property_value<private_copies, std::integral_constant<n>>;
};

struct num_replicates {
  template <size_t n>
  using value_t = property_value<num_replicates, std::integral_constant<n>>;
};

template<resource_enum r>
inline constexpr resource::value_t<r> resource_v;

template<size_t e>
inline constexpr num_banks::value_t<e> num_banks_v;

template<size_t e>
inline constexpr stride_size::value_t<e> stride_size_v;

template<size_t e>
inline constexpr word_size::value_t<e> word_size_v;

template<port_direction_enum d>
inline constexpr port_direction::value_t<d> port_direction_v;

template<bool b>
inline constexpr clock_2x::value_t<b> clock_2x_v;

template<ram_stitching_enum d>
inline constexpr ram_stitching::value_t<d> ram_stitching_v;

template<size_t n>
inline constexpr private_copies::value_t<n> private_copies_v;

template<size_t n>
inline constexpr num_replicates::value_t<n> num_replicates_v;

} // namespace sycl::ext:intel:
----

[frame="topbot",options="header"]
|===
|Property |Description

a|
[source,c++]
----
resource
----
a|
Specifies which FPGA memory resources to use to implement the variable.

The following values are supported:

* `mlab`: data is stored in special ALMs called memory-logic array blocks 
* `block_ram`: data is stored in memory blocks, ie. M20Ks

// --- ROW BREAK ---
a|
[source,c++]
----
num_banks
----
a|
Number of banks that the array is divided into. If `stride_size` property is not specified in conjunction with `num_banks` property, memory will be divided using cyclic partitioning strategy, where consecutive words will be placed in different banks.

Must be greater than zero and less than number of array elements.

// --- ROW BREAK ---
a|
[source,c++]
----
stride_size
----
a|
Number of consecutive elements in an array that will be part of the same bank. If `num_banks` property is not specified in conjunction with `stride_size` property, memory will be divided using block partitioning strategy, where consecutive words will be placed in the same bank until `stride_size` worth of elements is reached, at which point further words will be added to a new bank.

Must be greater than zero and less than number of array elements.

If `word_size`property is specified, `stride_size` must be a multiple of `word_size`. 

// --- ROW BREAK ---
a|
[source,c++]
----
word_size
----
a|
Size in elements of a single memory transaction.

Must be a factor of number of array elements.

// --- ROW BREAK ---
a|
[source,c++]
----
port_direction
----
a|
The following values are supported:

* `uni`: Specifies that a port to the memory can only service read or write requests, but not both.
* `bi`: Specifies that a port to the memory can service both read and write requests.

// --- ROW BREAK ---
a|
[source,c++]
----
clock_2x
----
a|
The following values are supported:

* `false`: Specifies that the memory implementing the variable must operate at the same clock frequency as the kernel accessing it.
* `true`: Specifies that the memory implementing the variable must be clocked at twice the rate as the kernel accessing it. This allows for twice as many memory accesses per kernel clock cycle but may reduce the maximum kernel clock frequency.

// --- ROW BREAK ---
a|
[source,c++]
----
ram_stitching
----
a|
If the size of the data is too big for a single RAM to hold it, multiple RAMs  are need to be stitched together. The following values are supported:

* `min_ram`: Specifies that the widths and depths of the individual RAMs may be different to minimize the number of RAMs needed to hold the data. This may result in more complicated logic being implement to index into the RAMs, reducing the fmax.
* `max_fmax`: Specifies that the RAMs should be of uniform width and depth, which allows for simple indexing logic to be generated. This may result in more RAMs being used than strictly necessary. 

// --- ROW BREAK ---
a|
[source,c++]
----
private_copies
----
a|
Specifies that the memory has a defined number of copies to allow simultaneous iterations of a loop at any given time. 

// --- ROW BREAK ---
a|
[source,c++]
----
max_replicates
----
a|
Specifies that the memory has no more than the specified number of replicates to enable simultaneous reads from the datapath. 

|===

