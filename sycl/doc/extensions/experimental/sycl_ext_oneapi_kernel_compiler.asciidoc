= sycl_ext_oneapi_kernel_compiler

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]
:endnote: &#8212;{nbsp}end{nbsp}note

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2023-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.
OpenCL(TM) is a trademark of Apple Inc. used by permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 8 specification.
All references below to the "core SYCL specification" or to section numbers in
the SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:../experimental/sycl_ext_oneapi_properties.asciidoc[
  sycl_ext_oneapi_properties]
* link:../proposed/sycl_ext_oneapi_free_function_kernels.asciidoc[
  sycl_ext_oneapi_free_function_kernels]


== Status

This is an experimental extension specification, intended to provide early 
access to features and gather community feedback. Interfaces defined in 
this specification are implemented in DPC++, but they are not finalized 
and may change incompatibly in future versions of DPC++ without prior notice. 
*Shipping software products should not rely on APIs defined in 
this specification.*


== Overview

This extension adds APIs that allow the application to dynamically generate the
source code for a kernel, which it can then compile and enqueue to a device.
This extension provides support for kernels written in SYCL according to the
"free function kernel" syntax defined in
link:../proposed/sycl_ext_oneapi_free_function_kernels.asciidoc[
sycl_ext_oneapi_free_function_kernels].
However, other extensions could provide support for writing kernels in other
languages.

The new APIs added by this extension are an expansion of the existing
`kernel_bundle` capabilities.
Thus, an application can create a kernel bundle from a source string and then
build the bundle into "executable" bundle state.
Once the application obtains a `kernel` object, it can use existing APIs from
the core SYCL specification to set the value of kernel arguments and enqueue
the kernel to a device.


== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.
An implementation supporting this extension must predefine the macro
`SYCL_EXT_ONEAPI_KERNEL_COMPILER`
to one of the values defined in the table below.
Applications can test for the existence of this macro to determine if
the implementation supports this feature, or applications can test the macro's
value to determine which of the extension's features the implementation
supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===

=== New kernel bundle state

This extension adds the `ext_oneapi_source` enumerator to `sycl::bundle_state`
to identify a kernel bundle that is represented as a source code string.

```
namespace sycl {

enum class bundle_state : /*unspecified*/ {
  // ...
  ext_oneapi_source
};

} // namespace sycl
```

=== New enumerator of kernel source languages

This extension adds the `source_language` enumeration, which identifies
possible languages for a kernel bundle that is in `ext_oneapi_source` state:

```
namespace sycl::ext::oneapi::experimental {

enum class source_language : /*unspecified*/ {
  sycl
};

} // namespace sycl::ext::oneapi::experimental
```

The only enumerator defined by this extension is `sycl`, which indicates that
the kernel is written in SYCL using the "free function kernel" syntax defined
in link:../proposed/sycl_ext_oneapi_free_function_kernels.asciidoc[
sycl_ext_oneapi_free_function_kernels].
Other extensions may provide other enumerators that correspond to other
languages.

=== New member functions for the device class

This extension adds the following new member functions to the `device` class:

|====
a|
[frame=all,grid=none]
!====
a!
[source]
----
class device {

bool ext_oneapi_can_compile(ext::oneapi::experimental::source_language lang);

};
----
!====

_Returns:_ The value `true` only if the device supports kernel bundles written
in the source language `lang`.
|====

=== New free functions to create and build kernel bundles

This extension adds the following new free functions to create and build a
kernel bundle in `ext_oneapi_source` state.

|====
a|
[frame=all,grid=none]
!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

template<typename PropertyListT = empty_properties_t>
kernel_bundle<bundle_state::ext_oneapi_source> create_kernel_bundle_from_source(
  const context& ctxt,
  source_language lang,
  const std::string& source,
  PropertyListT props = {})

kernel_bundle<bundle_state::ext_oneapi_source> create_kernel_bundle_from_source(
  const context& ctxt,
  source_language lang,
  const std::vector<std::byte>& bytes)

} // namespace sycl::ext::oneapi::experimental
----
!====

_Constraints:_ Available only when `PropertyListT` is an instance of
`sycl::ext::oneapi::experimental::properties` which contains no properties
other than those listed below in the section "New properties for the
`create_kernel_bundle_from_source` function".

_Preconditions:_ There are two overloads of this function: one that reads the
source code of the kernel from an `std::string`, and one that reads the source
code of the kernel from an `std::vector` of `std::byte`.
Each source language `lang` specifies whether the language is text format or
binary format, and the application must use the overload that corresponds to
that format.

_Effects:_ Creates a new kernel bundle that represents a kernel written in the
source language `lang`, where the source code is contained either by `source`
(if the source language is a text format) or by `bytes` (if the source language
is binary format).
The bundle is associated with the context `ctxt`, and kernels from this bundle
may only be submitted to a queue that shares the same context.
The bundle's set of associated devices is the set of devices contained in
`ctxt`.

_Returns:_ The newly created kernel bundle, which has `ext_oneapi_source`
state.

_Throws:_

* An `exception` with the `errc::invalid` error code if the source language
  `lang` is not supported by any device contained by the context `ctxt`.

[_Note:_ Calling this function does not attempt to compile the source code.
As a result, syntactic errors in the source code string are not diagnosed by
this function.

This function succeeds even if some devices in `ctxt` do not support the source
language `lang`.
However, the `build` function fails unless _all_ of its devices support `lang`.
Therefore, applications should take care to omit devices that do not support
`lang` when calling `build`.
_{endnote}_]

a|
[frame=all,grid=none]
!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

template<typename PropertyListT = empty_properties_t>                 (1)
kernel_bundle<bundle_state::executable> build(
  const kernel_bundle<bundle_state::ext_oneapi_source>& sourceBundle,
  const std::vector<device> &devs,
  PropertyListT props = {})

template<typename PropertyListT = empty_properties_t>                 (2)
kernel_bundle<bundle_state::executable> build(
  const kernel_bundle<bundle_state::ext_oneapi_source>& sourceBundle,
  PropertyListT props = {})

} // namespace sycl::ext::oneapi::experimental
----
!====

_Constraints:_ Available only when `PropertyListT` is an instance of
`sycl::ext::oneapi::experimental::properties` which contains no properties
other than those listed below in the section "New properties for the `build`
function".

_Effects (1):_ The source code from `sourceBundle` is translated into one or more
device images of state `bundle_state::executable`, and a new kernel bundle is
created to contain these device images.
The new bundle represents all of the kernels in `sourceBundle` that are
compatible with at least one of the devices in `devs`.
Any remaining kernels (those that are not compatible with any of the devices in
`devs`) are not represented in the new kernel bundle.

The new bundle has the same associated context as `sourceBundle`, and the new
bundle's set of associated devices is `devs` (with duplicate devices removed).

_Effects (2)_: Equivalent to `build(sourceBundle, ctxt.get_devices(), props)`.

_Returns:_ The newly created kernel bundle, which has `executable` state.

_Throws:_

* An `exception` with the `errc::invalid` error code if any of the devices in
  `devs` is not contained by the context associated with `sourceBundle`.

* An `exception` with the `errc::invalid` error code if any of the devices in
  `devs` does not support compilation of kernels in the source language of
  `sourceBundle`.

* An `exception` with the `errc::invalid` error code if `props` contains an
  `options` property that specifies an invalid option.

* An `exception` with the `errc::build` error code if the compilation or
  linking operations fail.
  In this case, the exception `what` string provides a full build log,
  including descriptions of any errors, warning messages, and other
  diagnostics.
  This string is intended for human consumption, and the format may not be
  stable across implementations of this extension.

[_Note:_ An uncaught `errc::build` exception may result in some or all of the
source code used to create the kernel bundle being printed to the terminal.
In situations where this is undesirable, developers must ensure that the
exception is caught and handled appropriately.
_{endnote}_]
|====

=== New properties for the `create_kernel_bundle_from_source` function

This extension adds the following properties, which can be used in conjunction
with the `create_kernel_bundle_from_source` function that is defined above:

|====
a|
[frame=all,grid=none]
!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

struct include_files {
  std::vector<std::string> names;
  std::vector<std::string> contents;
  include_files(const std::string &name, const std::string &content);  (1)
  include_files(const std::vector<std::string> &names,                 (2)
                const std::vector<std::string> &contents);
};
using include_files_key = include_files;

template<>
struct is_property_key<include_files_key> : std::true_type {};

} // namespace sycl::ext::oneapi::experimental
----
!====

This property provides the name and content of include files that can be
referenced from the source code in the `source` parameter to
`create_kernel_bundle_from_source`.
The property conceptually contains a collection of (_Name_, _Content_) pairs,
where both _Name_ and _Content_ are strings.
The _Name_ is the name of an include file and the _Content_ is the content of
that include file.

When the source language is `source_language::sycl`, the source code can have
`#include` statements where the name and content of the include file is
defined by this property.
For example, if the source code has `#include "foo.h"`, the compilation process
will look at the `include_files` property to see if there is an entry whose
_Name_ is `foo.h`.
If such an entry is found, the compiler uses the associated _Content_ as the
content of the include file.

When the source language is `source_language::sycl`, the following header files
are implicitly available.
Therefore, the source string may `#include` these even without defining their
content via the `include_files` property:

* `<sycl/sycl.hpp>`;
* The {cpp} standard library headers;
* The SYCL backend headers `"sycl/backend/<backend_name>.hpp"` for any backends
  that the implementation supports; and
* Any SYCL extension headers in "sycl/ext" for extensions that the
  implementation supports.

The include files defined via the `include_files` property are searched first,
before these implicitly available headers.

_Effects (1):_ Constructs an `include_files` property with a single (_Name_,
_Content_) pair.

_Effects (2):_ Constructs an `include_files` property with a collection of
(_Name_, _Content_) pairs.
The `names` vector provides the _Name_ strings, and the `contents` vector
provides the _Content_ strings.
|====

=== New properties for the `build` function

This extension adds the following properties, which can be used in conjunction
with the `build` function that is defined above:

|====
a|
[frame=all,grid=none]
!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

struct build_options {
  std::vector<std::string> opts;
  build_options(const std::string &opt);                (1)
  build_options(const std::vector<std::string> &opts);  (2)
};
using build_options_key = build_options;

template<>
struct is_property_key<build_options_key> : std::true_type {};

} // namespace sycl::ext::oneapi::experimental
----
!====

This property provides build options that may affect the compilation or linking
of the kernel, where each build option is a string.
There are no standard build options that are common across all source
languages.
Instead, each source language specification defines its own set of build
options.
The `source_language::sycl` language does not define any standard build
options, but an implementation may support implementation-defined options.

_Effects (1):_ Constructs a `build_options` property with a single build
option.

_Effects (2):_ Constructs a `build_options` property from a vector of build
options.

a|
[frame=all,grid=none]
!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

struct save_log {
  std::string *log;
  save_log(std::string *to);  (1)
};
using save_log_key = save_log;

template<>
struct is_property_key<save_log_key> : std::true_type {};

} // namespace sycl::ext::oneapi::experimental
----
!====

This property allows the caller to request a log to be created with additional
information about the compilation and linking operations.
Use of this property is not required in order to get information about a failed
build.
When a build fails, an `exception` is thrown and the exception's `what` string
provides a description of the error.

Instead, the `save_log` property provides information about a build operation
that succeeds.
This might include warning messages or other diagnostics.
Each source language specification can define specific information that is
provided in the log.
The `source_language::sycl` language does not define any specific information
that is provided in the log, so implementations are free to provide any
information they choose here.
In general, the log information is intended for human consumption, and the
format may not be stable across implementations of this extension.

_Effects (1):_ Constructs a `save_log` property with a pointer to a `std::string`.
When the `build` function completes successfully, this string will contain the
log.

a|
[frame=all,grid=none]
!====
a!
[source]
----
namespace sycl::ext::oneapi::experimental {

struct registered_kernel_names {
  std::vector<std::string> names;
  registered_kernel_names(const std::string &name);                (1)
  registered_kernel_names(const std::vector<std::string> &names);  (2)
};
using registered_kernel_names_key = registered_kernel_names;

template<>
struct is_property_key<registered_kernel_names_key> : std::true_type {};

} // namespace sycl::ext::oneapi::experimental
----
!====

This property is useful when the source language represents kernel names
differently in the source code and the generated code.
For example, {cpp} function names in the generated code are "mangled" in an
implementation-defined way.
The precise meaning of this property is defined by each source language, but in
general it allows the application to supply a list of kernel names as they
appear in the source code.
The application can then get the corresponding raw (i.e. mangled) names after
the code is compiled.
See the section below "Obtaining a kernel when the language is ``sycl``" for a
description of how this property is used with the `source_language::sycl`
language.

_Effects (1):_ Constructs a `registered_kernel_names` property with a single
kernel name.

_Effects (2):_ Constructs a `registered_kernel_names` property from a vector of
kernel names.
|====

=== New constraint for kernel bundle member functions

This extension adds the following constraint to some of the `kernel_bundle`
member functions from the core SYCL specification:

> _Constraints:_ This function is not available when `State` is
> `bundle_state::ext_oneapi_source`.

This new constraint applies to the following member functions:

* `empty`;
* All overloads and function templates of `has_kernel`;
* `get_kernel_ids`;
* `contains_specialization_constants`;
* `native_specialization_constant`;
* `has_specialization_constant`;
* `get_specialization_constant`;
* `begin`; and
* `end`.

As a result, the only `kernel_bundle` member functions from the core SYCL
specification that are available for bundles in `ext_oneapi_source` state are
`get_backend`, `get_context`, and `get_devices`.

=== Interaction with existing kernel bundle member functions

Kernels created from online compilation of source code do not have any
associated `kernel_id`.
Therefore, the function `kernel_bundle::get_kernel_ids` returns an empty vector
of `kernel_id` objects if the kernel bundle was created from a bundle of state
`bundle_state::ext_oneapi_source`.

=== New kernel bundle member functions

This extensions adds the following new `kernel_bundle` member functions:

```
namespace sycl {

template <bundle_state State>
class kernel_bundle {
  // ...

  bool ext_oneapi_has_kernel(const std::string &name);
  kernel ext_oneapi_get_kernel(const std::string &name);
  std::string ext_oneapi_get_raw_kernel_name(const std::string &name);
};

} // namespace sycl
```

|====
a|
[frame=all,grid=none]
!====
a!
[source]
----
bool ext_oneapi_has_kernel(const std::string &name)
----
!====

_Constraints:_ This function is not available when `State` is
`bundle_state::ext_oneapi_source`.

_Returns:_ The value `true` only if the kernel bundle was created from a bundle
of state `bundle_state::ext_oneapi_source` and if it defines a kernel whose
name is `name`.
The extension specification for each source language tells how the `name`
string is correlated to kernels defined in that source language.

a|
[frame=all,grid=none]
!====
a!
[source]
----
kernel ext_oneapi_get_kernel(const std::string &name)
----
!====

_Constraints:_ This function is available only when `State` is
`bundle_state::executable`.

_Returns:_ A `kernel` object representing the kernel in this bundle whose name
is `name`.

_Throws:_

* An `exception` with the `errc::invalid` error code if
  `ext_oneapi_has_kernel(name)` returns `false`.

a|
[frame=all,grid=none]
!====
a!
[source]
----
std::string ext_oneapi_get_raw_kernel_name(const std::string &name)
----
!====

_Constraints:_ This function is not available when `State` is
`bundle_state::ext_oneapi_source`.

_Returns:_ If the kernel bundle was created from a bundle of state
`bundle_state::ext_oneapi_source` and `name` was registered via
`registered_kernel_names`, returns the compiler-generated (e.g. mangled) name
for this kernel function.
If the kernel bundle was created from a bundle of state
`bundle_state::ext_oneapi_source` and `name` is the same as a
compiler-generated name for a kernel defined in that bundle, that same
`name` is returned.

_Throws:_

* An `exception` with the `errc::invalid` error code if
  `ext_oneapi_has_kernel(name)` returns `false`.
|====

=== Obtaining a kernel when the language is `sycl`

When the kernel is defined in the language `source_language::sycl`, the host
code may query for the kernel or obtain the `kernel` object using either the
kernel's name as it is generated by the compiler (i.e. the C++ mangled name) or
by using the `registered_kernel_names` property.

==== Using the compiler-generated name

If the kernel is declared as `extern "C"`, the compiler generates the kernel
name exactly as it appears in the source code (i.e. there is no name mangling).
Therefore, it is easy to query for the kernel by using the compiler-generated
name.
For example, if the kernel is defined like this in the source code string:

```
std::string source = R"""(
  extern "C"
  SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
  void foo(int *in, int *out) {/*...*/}
)""";
```

Then the application's host code can query for the kernel like this:

```
sycl::kernel_bundle<sycl::bundle_state::executable> kb = /*...*/;
sycl::kernel k = kb.ext_oneapi_get_kernel("foo");
```

==== Using the `registered_kernel_names` property

When the kernel is not declared as `extern "C"`, the compiler generates a
mangled name, so it is more convenient to use the `registered_kernel_names`
property.
Each string in the property must be the C++ expression for a pointer to a
kernel function.
These expression strings are conceptually compiled at the bottom of source
code.
To illustrate, consider source code that defines a kernel like this:

```
std::string source = R"""(
  namespace mykernels {

  SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
  void bar(int *in, int *out) {/*...*/}

  } // namespace mykernels
)""";
```

The host code can compile this and get the kernel's `kernel` object like so:

```
sycl::kernel_bundle<sycl::bundle_state::ext_oneapi_source> kb_src = /*...*/;

sycl::kernel_bundle<sycl::bundle_state::executable> kb = syclex::build(kb_src,
  syclex::properties{syclex::registered_kernel_names{"mykernels::bar"}});

sycl::kernel k = kb.ext_oneapi_get_kernel("mykernels::bar");
```

The C++ expression `"mykernels::bar"` computes the address of the kernel
function `bar`.
The host code then passes the same string (`"mykernels::bar"`) to
`ext_oneapi_get_kernel` in order to get the `kernel` object.
The string must have exactly the same content as the string that was used to
construct the property, without even any whitespace differences.

The application can also obtain the compiler-generated (i.e. mangled) name for
the kernel by calling `ext_oneapi_get_raw_kernel_name` like this:

```
sycl::kernel_bundle<sycl::bundle_state::ext_oneapi_source> kb_src = /*...*/;

sycl::kernel_bundle<sycl::bundle_state::executable> kb = syclex::build(kb_src,
  syclex::properties{syclex::registered_kernel_names{"mykernels::bar"}});

std::string mangled_name = kb.ext_oneapi_get_raw_kernel_name("mykernels::bar");
```

Again, the string passed to `ext_oneapi_get_raw_kernel_name` must have exactly
the same content as the string that was used to construct the
`registered_kernel_names` property.
The application may also pass this compiler-generated (i.e. mangled) name to
`ext_oneapi_get_kernel` in order to get the `kernel` object.

==== Instantiating templated kernel functions

The `registered_kernel_names` property can also be used to instantiate a
kernel that is defined as a function template.
For example, consider source code that defines a kernel function template like
this:

```
std::string source = R"""(
  template<typename T>
  SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
  void bartmpl(T *in, T *out) {/*...*/}
)""";
```

The application can use the `registered_kernel_names` property to instantiate
the template for specific template arguments.
For example, this host code instantiates the template twice and gets a `kernel`
object for each instantiation:

```
sycl::kernel_bundle<sycl::bundle_state::ext_oneapi_source> kb_src = /*...*/;

sycl::kernel_bundle<sycl::bundle_state::executable> kb = syclex::build(kb_src,
  syclex::properties{syclex::registered_kernel_names{{"bartmpl<float>", "bartmpl<int>"}});

sycl::kernel k_float = kb.ext_oneapi_get_kernel("bartmpl<float>");
sycl::kernel k_int = kb.ext_oneapi_get_kernel("bartmpl<int>");
```


== Examples

=== Simple example

The following example demonstrates how a SYCL application can define a kernel
as a string and then compile and launch it.

```
#include <sycl/sycl.hpp>
namespace syclex = sycl::ext::oneapi::experimental;
static constexpr size_t NUM = 1024;

int main() {
  sycl::queue q;

  // The source code for a kernel, defined as a SYCL "free function kernel".
  std::string source = R"""(
    extern "C"
    SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
    void iota(float start, float *ptr) {
      size_t id = syclex::this_kernel::get_id();
      ptr[id] = start + static_cast<float>(id);
    }
  )""";

  // Create a kernel bundle in "source" state.
  sycl::kernel_bundle<sycl::bundle_state::ext_oneapi_source> kb_src =
    syclex::create_kernel_bundle_from_source(
      q.get_context(),
      syclex::source_language::sycl,
      source);

  // Compile the kernel.  There is no need to use the "registered_kernel_names"
  // property because the kernel is declared extern "C".
  sycl::kernel_bundle<sycl::bundle_state::executable> kb_exe =
    syclex::build(kb_src);

  // Get the kernel via its compiler-generated name.
  sycl::kernel iota = kb_exe.ext_oneapi_get_kernel("iota");

  float *ptr = sycl::malloc_shared<float>(NUM, q);
  q.submit([&](sycl::handler &cgh) {
    // Set the values of the kernel arguments.
    cgh.set_args(3.14f, ptr);

    // Launch the kernel according to its type, in this case a simple
    // "range" kernel.
    cgh.parallel_for({NUM}, iota);
  }).wait();
}
```

=== Disambiguating overloaded kernel functions

This example demonstrates how to use the `registered_kernel_names` property to
disambiguate a kernel function that has several overloads.

```
#include <sycl/sycl.hpp>
namespace syclex = sycl::ext::oneapi::experimental;
static constexpr size_t NUM = 1024;

int main() {
  sycl::queue q;

  // The source code for two kernels defined as overloaded functions.
  std::string source = R"""(
    SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
    void iota(float start, float *ptr) {
      size_t id = syclex::this_kernel::get_id();
      ptr[id] = start + static_cast<float>(id);
    }

    SYCL_EXT_ONEAPI_RANGE_KERNEL(1)
    void iota(int start, int *ptr) {
      size_t id = syclex::this_kernel::get_id();
      ptr[id] = start + static_cast<int>(id);
    }
  )""";

  // Create a kernel bundle in "source" state.
  sycl::kernel_bundle<sycl::bundle_state::ext_oneapi_source> kb_src =
    syclex::create_kernel_bundle_from_source(
      q.get_context(),
      syclex::source_language::sycl,
      source);

  // Compile the kernel.  Because there are two overloads of "iota", we need to
  // use a C++ cast to disambiguate between them.  Here, we are selecting the
  // "int" overload.
  std::string iota_name{"(void(*)(int, int*))iota"};
  sycl::kernel_bundle<sycl::bundle_state::executable> kb_exe = syclex::build(kb_src,
    syclex::properties{syclex::registered_kernel_names{iota_name}});

  // Get the kernel by passing the same string we used to construct the
  // "registered_kernel_names" property.
  sycl::kernel iota = kb_exe.ext_oneapi_get_kernel(iota_name);

  int *ptr = sycl::malloc_shared<int>(NUM, q);
  q.submit([&](sycl::handler &cgh) {
    // Set the values of the kernel arguments.
    cgh.set_args(3, ptr);

    // Launch the kernel according to its type, in this case a simple
    // "range" kernel.
    cgh.parallel_for({NUM}, iota);
  }).wait();
}
```


== Issues

* Do we want to add an API similar to `nvrtcGetTypeName`?
  This does seem useful in some advanced cases, and it is not specific to CUDA.
  The implementation is fairly straightforward.
  You use `typeid` to get an `std::type_info`.
  You can then call `type_info::name` to get an implementation-defined name for
  the type.
  For clang on Linux, this returns the type's mangled name.
  You can then call `+abi::__cxa_demangle+` to get an unmangled name for the
  type.
  I'm not sure about the details on Windows hosts, though.
  If `type_info::name` returns a mangled name on Windows too, then maybe we can
  still use `+abi::__cxa_demangle+` to get an unmangled name, but this needs to
  be checked.
+
Another option might be to provide this functionality as a utility library.
There is no inherent reason why this functionality needs to be built into
{dpcpp}.
However, we don't yet have a utility library where this would go, and it may be
hard for customers to discover this functionality if it is defined outside of
this extension.
