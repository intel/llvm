# sycl_ext_oneapi_bindless_images

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

## Notice

[%hardbreaks]
Copyright (C) Codeplay Software Limited. All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc. OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.

## Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues

## Dependencies

This extension is written against the SYCL 2020 revision 6 specification. All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

## Status

This is an experimental extension specification, intended to provide early
access to features and gather community feedback.  Interfaces defined in this
specification are implemented in {dpcpp}, but they are not finalized and may
change incompatibly in future versions of {dpcpp} without prior notice.
*Shipping software products should not rely on APIs defined in this
specification.*

## Backend support status

This extension is currently implemented in DPC++ only when using the CUDA backend.
Attempting to use this extension in kernels
that run on other devices or backends may result in undefined behavior.
Be aware that the compiler is not able to issue a diagnostic to warn you if this happens.
Work is ongoing to support other backends.

## Overview

Images in SYCL 1.2.1 were designed to work with OpenCL.
SYCL 2020 tried to make them work with other backends as well
by splitting the image type into sampled and unsampled images.
However, SYCL 2020 images still didn't quite meet user expectations.
There was feedback about various use cases where the current model falls short
(see examples at the end of this document for some of the use cases).

The main issue is requesting access to each individual image.
There are many use cases where there's a large number of images,
potentially a number that's not known at compile time,
which is very difficult or even impossible to do with the current model.

That's why we propose in this document a new extension for SYCL 2020 images.
Per the proposal, users would be able to separate memory allocation for the image
from the actual image creation.
An image is represented  by an opaque handle that can be passed directly into a kernel
without requesting access.
In many ways this model resembles more the USM model when accessing data on the device,
but it's specialized for dealing with images.

The proposed model does not replace SYCL 2020 images,
it is instead meant as building blocks for implementing SYCL 2020 images on top of it.

## Specification

### Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification. An implementation supporting this extension must predefine the
macro `SYCL_EXT_ONEAPI_BINDLESS_IMAGES` to one of the values defined in the
table below. Applications can test for the existence of this macro to
determine if the implementation supports this feature, or applications can test
the macro's value to determine which of the extension's features the
implementation supports.

[%header,cols="10,90"]
|===
| Value | Description
| 202302 | The APIs of this experimental extension are not versioned, so the feature-test macro always has this value.
|===

### Image descriptor

```cpp
namespace sycl::ext::oneapi {

struct image_descriptor {
  unsigned int width;
  unsigned int height;
  unsigned int depth;
  image_channel_type channel_type;
  image_channel_order channel_order;
  unsigned int row_pitch;
};

}
```

The image descriptor represents the image dimensions, channel type, channel order, and row pitch.

Note that `image_channel_type` and `image_channel_order` existed in SYCL 1.2.1,
but were removed in SYCL 2020 in favor of a single, unified enum class.
We propose separating them again to enable better flexibility
and to avoid combinatorial complexity.

### Allocating image memory

```cpp
namespace sycl::ext::oneapi {

void* allocate_image(const context& syclContext, image_descriptor desc);

void free_image(const context& syclContext, void* memory_handle);

}
```

The process of creating an image is two-fold:
allocate an image, then create an image handle from the allocation.

The first step is to allocate memory for an image.
`allocate_image` can be used for this,
as it allocates memory based on the requirements outlined by the image descriptor.
The function returns a pointer to the newly allocated memory.
Note that the image is an opaque type, so the pointer cannot be dereferenced on the host.

After we're done with the image, we need to cleanup the memory using `free_image`.


[NOTE]
====
In the DPC++ CUDA backend, this will allocate a `CUarray` type.
====

An alternative is to allocate memory using device USM allocations.
In addition to the existing USM allocation functions, a new USM pitched allocation function is proposed:

```cpp
namespace sycl::ext::oneapi {

void* pitched_alloc_device(size_t* ret_pitch, size_t width_in_bytes, size_t height
                           unsigned int element_size_bytes, const queue& queue);

}
```

This function will allocate a memory region aimed to be used for two-dimensional images.
It places appropriate padding at the end of image rows and returns the pitch value used.

For one-dimensional images, existing USM allocation functions are sufficient.

Three-dimensional images do not support USM.

The next step, creating the image, is the same regardless of how the memory was allocated.

### Obtaining a handle to the image

```cpp
namespace sycl::ext::oneapi {

using unsampled_image_handle = /* Implementation defined */;
using sampled_image_handle = /* Implementation defined */;

unsampled_image_handle create_image(const context& syclContext, void* devPtr);
sampled_image_handle create_image(const context& syclContext, void* devPtr,
                          sampler& sampler);

void destroy_image_handle(const context& syclContext,
                          sampled_image_handle& imageHandle);
void destroy_image_handle(const context& syclContext,
                          unsampled_image_handle& imageHandle);

}
```

Once we have allocated memory, we can pass it into the `create_image` function
to obtain a `sampled_image_handle` or `unsampled_image_handle`.
These objects are opaque types that represent an image object.
They can be captured by value into a SYCL kernel,
or they can be passed in a buffer as a dynamic array of images
(see examples below).

We can either provide a sampler or not when creating the image.

[NOTE]
====
In the DPC++ CUDA backend a sampled image will correspond to a CUDA texture.
An unsampled image will usually correspond to a CUDA surface, unless the memory the
texture is created from is USM, then it will correspond to a CUDA texture.
====

After we're done with the image, we need to destroy the handle using `destroy_image_handle`.

### Explicit copies

```cpp
namespace sycl::ext::oneapi {

enum image_copy_flags : unsigned int {
  HtoD = 0, // Host to device
  DtoH = 1, // Device to host
  DtoD = 2, // Device to device
};

void copy_image(const sycl::queue& syclQueue, void* dst_ptr, void* src_ptr,
                image_descriptor desc, image_copy_flags flags);

}
```

`copy_image` can be used to copy data between host and device,
or alternatively between two devices.
`dst_ptr` and `src_ptr` can represent host or device pointers, depending on the value
of `image_copy_flags`.
The direction of the copy is determined by passing in a value of `image_copy_flags`.
The image descriptor is used to determine the dimensions of the image, and the image
row pitch, when copying the data.


[NOTE]
====
The copy operation should be made a method on the queue in the future,
and the copy flags might be made redundant as we should be able to determine
whether given pointers are device, host, or USM pointers
====

### Reading and writing inside the kernel

```cpp
namespace sycl::ext::oneapi {

template <typename DataT, typename CoordT>
DataT read_image(const image_handle &imageHandle, const CoordT &coords);

template <typename DataT, typename CoordT>
void write_image(const image_handle &imageHandle, const CoordT &Coords,
                 const DataT &Color);

}
```

Inside a kernel it's possible to read an image using `read_image` via the image handle,
which returns a value of the user specified type `DataT`.
Similarly, it's possible to write to an image via a handle using `write_image`.

`write_image` is not available for sampled images, or images created from USM memory.

`DataT` must correspond to the type specified in the `image_descriptor`
when the image was created.

The coordinates are specified as an `int` for 1D images, `int2` for 2D images,
and `int4` for 3D images (not `int3`).


[NOTE]
====
Sampling will likely require passing a sampler handle to the `read_image` function.
The current proposal does not require this, as CUDA ties samplers and textures at time of creation.
====

## Examples

### 1D image read/write

```cpp
queue q;
auto ctxt = q.get_context();

constexpr size_t N = 512;
std::vector<float4> dataIn(N);
float exp = 512;
for (int i = 0; i < N; i++) {
  dataIn[i] = float4(i, i, i, i);
}

// Image descriptor - can use the same for both images
ext::oneapi::image_descriptor desc({N, 0, 0}, image_channel_order::rgba,
                                   image_channel_type::fp32);

// Extension: returns the device pointer to the allocated memory
auto imgMemoryIn = ext::oneapi::allocate_image(ctxt, desc);
auto imgMemoryOut = ext::oneapi::allocate_image(ctxt, desc);

// Extension: copy over data to device
ext::oneapi::copy_image(q, imgMemoryIn, dataIn.data(), desc,
                              ext::oneapi::image_copy_flags::HtoD);

// Extension: create the image and return the handle
ext::oneapi::image_handle imgIn =
    ext::oneapi::create_image(ctxt, imgMemoryIn);
ext::oneapi::image_handle imgOut =
    ext::oneapi::create_image(ctxt, imgMemoryOut);

q.submit([&](handler &cgh) {
  // No need to request access, handles captured by value

  cgh.parallel_for(N, [=](id<1> id) {
    // Extension: read image data from handle
    float4 px1 =
        ext::oneapi::read_image<float4>(imgIn, int(id[0]));

    // Extension: write to image data using handle
    sycl::ext::oneapi::write_image<float4>(imgOut, int(id[0]), px1);
  });
});

// Using image handles requires manual synchronization
q.wait_and_throw();

// Cleanup
ext::oneapi::destroy_image_handle(ctxt, imgIn);
ext::oneapi::destroy_image_handle(ctxt, imgOut);
ext::oneapi::free_image(ctxt, imgMemoryIn);
ext::oneapi::free_image(ctxt, imgMemoryOut);
```

### Reading from a dynamically sized array of 2D images

```cpp
device dev;
queue q(dev);
auto ctxt = q.get_context();

// declare image data
size_t numImages = 5;
size_t width = 7;
size_t height = 3;
size_t N = width * height;
std::vector<float> out(N);
std::vector<float> expected(N);
std::vector<float4> dataIn(N);
for (int i = 0; i < width; i++) {
  for (int j = 0; j < height; j++) {
    expected[j + (height * i)] = (j + (height * i)) * numImages;
    dataIn[j + (height * i)] = {j + (height * i), 0, 0, 0};
  }
}

// Image descriptor - can use the same for all images
sycl::ext::oneapi::image_descriptor desc(
  {width, height}, image_channel_order::rgba, image_channel_type::fp32);

// Allocate each image and save the device ptrs
std::vector<void *> imgAllocations;
for (int i = 0; i < numImages; i++) {
// Extension: returns the device pointer to the allocated memory
auto device_ptr = sycl::ext::oneapi::allocate_image(ctxt, desc);
if (device_ptr == nullptr) {
  std::cout << "Error allocating image!" << std::endl;
  return 1;
}
imgAllocations.push_back(device_ptr);
}

// Copy over data to device for each image
for (int i = 0; i < numImages; i++) {
// Extension: copy over data to device
sycl::ext::oneapi::copy_image(q, imgAllocations[i], dataIn.data(), desc,
                              sycl::ext::oneapi::image_copy_flags::HtoD);
}

// Create the images and return the handles
std::vector<sycl::ext::oneapi::unsampled_image_handle> imgHandles;
for (int i = 0; i < numImages; i++) {
// Extension: create the image and return the handle
sycl::ext::oneapi::unsampled_image_handle imgHandle =
    sycl::ext::oneapi::create_image(ctxt, imgAllocations[i]);
imgHandles.push_back(imgHandle);
}

// Cuda stores data in column-major fashion
// SYCL deals with indexing in row-major fashion
// Reverse output buffer dimensions and access to convert
// the cuda column-major data back to row-major
buffer<float, 2> buf((float *)out.data(), range<2>{height, width});
buffer<sycl::ext::oneapi::unsampled_image_handle, 1> imgHandlesBuf(
    imgHandles.data(), range<1>{numImages});
q.submit([&](handler &cgh) {
  auto outAcc =
      buf.get_access<access_mode::write>(cgh, range<2>{height, width});

  auto imgHandleAcc =
      imgHandlesBuf.get_access<access_mode::read>(cgh, range<1>{numImages});

  cgh.parallel_for<image_addition>(
      nd_range<2>{{width, height}, {width, height}}, [=](nd_item<2> it) {
        size_t dim0 = it.get_local_id(0);
        size_t dim1 = it.get_local_id(1);

        // Sum each image by reading their handle
        float sum = 0;
        for (int i = 0; i < numImages; i++) {
          // Extension: read image data from handle
          sum += (sycl::ext::oneapi::read_image<float4>(
              imgHandleAcc[i], int2(dim0, dim1)))[0];
        }
        outAcc[id<2>{dim1, dim0}] = sum;
      });
});

// Using image handles requires manual synchronization
q.wait_and_throw();

// Cleanup
for (int i = 0; i < numImages; i++) {
  sycl::ext::oneapi::destroy_image_handle(ctxt, imgHandles[i]);
  sycl::ext::oneapi::free_image(ctxt, imgAllocations[i]);
}
```

## Implementation notes

The current DPC++ prototype only implements the proposal for the CUDA backend,
however we are actively exploring Level Zero with SPIR-V.
We are looking at other backend as well in order to ensure the extension can work across different backends.

## Issues

### No dependency tracking

Because this extension allows images to work in a USM-like model,
there are similar limitations to using USM for non-images,
mainly the lack of dependency tracking and the need for users to manually synchronize operations.

### Limitations when using USM as image memory

When USM is used as the image memory, these are the general limitations:

* Not possible to write images, just read.

Then there are dimension specific limitations:

* 1D - Linear interpolation not possible in the CUDA backend.
  A workaround is to allocate 2D pitched memory with a height of 1.
* 2D - Only works with `pitched_alloc_device`.
* 3D - No support at the moment.

### Not supported yet

These features still need to be handled:

* Level Zero and SPIR-V support
* Mipmapping
* Interop with various backends
* etc.

## Revision History

[%header,cols="10,15,75"]
|===
| Rev | Date | Changes
| 1 | 2023-02-03 | Initial draft
|===
