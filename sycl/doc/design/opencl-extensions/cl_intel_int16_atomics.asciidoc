:data-uri:
:sectanchors:
:icons: font
:source-highlighter: coderay

ifdef::backend-html5[]
:CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL: pass:q[`CL_DEVICE_<wbr>BF16_<wbr>ATOMIC_<wbr>CAPABILITIES_<wbr>INTEL`]
:CL_DEVICE_INT16_ATOMIC_CAPABILITIES_INTEL: pass:q[`CL_DEVICE_<wbr>INT16_<wbr>ATOMIC_<wbr>CAPABILITIES_<wbr>INTEL`]
:cl_device_fp_atomic_capabilities_ext_TYPE: pass:q[`cl_device_<wbr>fp_<wbr>atomic_<wbr>capabilities_<wbr>ext`]
:cl_device_atomic_operations_intel_TYPE: pass:q[`cl_device_<wbr>atomic_<wbr>operations_<wbr>intel`]
:CL_DEVICE_GLOBAL_ATOMIC_LOAD_STORE_INTEL: pass:q[`CL_DEVICE_<wbr>GLOBAL_<wbr>ATOMIC_<wbr>LOAD_<wbr>STORE_<wbr>INTEL`]
:CL_DEVICE_GLOBAL_ATOMIC_ADD_INTEL: pass:q[`CL_DEVICE_<wbr>GLOBAL_<wbr>ATOMIC_<wbr>ADD_<wbr>INTEL`]
:CL_DEVICE_GLOBAL_ATOMIC_MIN_MAX_INTEL: pass:q[`CL_DEVICE_<wbr>GLOBAL_<wbr>ATOMIC_<wbr>MIN_<wbr>MAX_<wbr>INTEL`]
:CL_DEVICE_GLOBAL_ATOMIC_CMPXCHG_INTEL: pass:q[`CL_DEVICE_<wbr>GLOBAL_<wbr>ATOMIC_<wbr>CMPXCHG_<wbr>INTEL`]
:CL_DEVICE_GLOBAL_ATOMIC_AND_OR_XOR_INTEL: pass:q[`CL_DEVICE_<wbr>GLOBAL_<wbr>ATOMIC_<wbr>AND_<wbr>OR_<wbr>XOR_<wbr>INTEL`]
:CL_DEVICE_LOCAL_ATOMIC_LOAD_STORE_INTEL: pass:q[`CL_DEVICE_<wbr>LOCAL_<wbr>ATOMIC_<wbr>LOAD_<wbr>STORE_<wbr>INTEL`]
:CL_DEVICE_LOCAL_ATOMIC_ADD_INTEL: pass:q[`CL_DEVICE_<wbr>LOCAL_<wbr>ATOMIC_<wbr>ADD_<wbr>INTEL`]
:CL_DEVICE_LOCAL_ATOMIC_MIN_MAX_INTEL: pass:q[`CL_DEVICE_<wbr>LOCAL_<wbr>ATOMIC_<wbr>MIN_<wbr>MAX_<wbr>INTEL`]
:CL_DEVICE_LOCAL_ATOMIC_CMPXCHG_INTEL: pass:q[`CL_DEVICE_<wbr>LOCAL_<wbr>ATOMIC_<wbr>CMPXCHG_<wbr>INTEL`]
:CL_DEVICE_LOCAL_ATOMIC_AND_OR_XOR_INTEL: pass:q[`CL_DEVICE_<wbr>LOCAL_<wbr>ATOMIC_<wbr>AND_<wbr>OR_<wbr>XOR_<wbr>INTEL`]
:CL_DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE_EXT: pass:q[`CL_DEVICE_<wbr>GLOBAL_<wbr>FP_<wbr>ATOMIC_<wbr>LOAD_<wbr>STORE_<wbr>EXT`]
:CL_DEVICE_GLOBAL_FP_ATOMIC_ADD_EXT: pass:q[`CL_<wbr>DEVICE_<wbr>GLOBAL_<wbr>FP_<wbr>ATOMIC_<wbr>ADD_<wbr>EXT`]
:CL_DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX_EXT: pass:q[`CL_DEVICE_<wbr>GLOBAL_<wbr>FP_<wbr>ATOMIC_<wbr>MIN_<wbr>MAX_<wbr>EXT`]
:CL_DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE_EXT: pass:q[`CL_DEVICE_<wbr>LOCAL_<wbr>FP_<wbr>ATOMIC_<wbr>LOAD_<wbr>STORE_<wbr>EXT`]
:CL_DEVICE_LOCAL_FP_ATOMIC_ADD_EXT: pass:q[`CL_DEVICE_<wbr>LOCAL_<wbr>FP_<wbr>ATOMIC_<wbr>ADD_<wbr>EXT`]
:CL_DEVICE_LOCAL_FP_ATOMIC_MIN_MAX_EXT: pass:q[`CL_DEVICE_<wbr>LOCAL_<wbr>FP_<wbr>ATOMIC_<wbr>MIN_<wbr>MAX_<wbr>EXT`]
endif::[]
ifndef::backend-html5[]
:CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL: pass:q[`CL_DEVICE_&#8203;BF16_&#8203;ATOMIC_&#8203;CAPABILITIES_&#8203;INTEL`]
:CL_DEVICE_INT16_ATOMIC_CAPABILITIES_INTEL: pass:q[`CL_DEVICE_&#8203;INT16_&#8203;ATOMIC_&#8203;CAPABILITIES_&#8203;INTEL`]
:cl_device_fp_atomic_capabilities_ext_TYPE: pass:q[`cl_device_&#8203;fp_&#8203;atomic_&#8203;capabilities_&#8203;ext`]
:cl_device_atomic_operations_intel_TYPE: pass:q[`cl_device_&#8203;atomic_&#8203;operations_&#8203;intel`]
:CL_DEVICE_GLOBAL_ATOMIC_LOAD_STORE_INTEL: pass:q[`CL_DEVICE_&#8203;GLOBAL_&#8203;ATOMIC_&#8203;LOAD_&#8203;STORE_&#8203;INTEL`]
:CL_DEVICE_GLOBAL_ATOMIC_ADD_INTEL: pass:q[`CL_DEVICE_&#8203;GLOBAL_&#8203;ATOMIC_&#8203;ADD_&#8203;INTEL`]
:CL_DEVICE_GLOBAL_ATOMIC_MIN_MAX_INTEL: pass:q[`CL_DEVICE_&#8203;GLOBAL_&#8203;ATOMIC_&#8203;MIN_&#8203;MAX_&#8203;INTEL`]
:CL_DEVICE_GLOBAL_ATOMIC_CMPXCHG_INTEL: pass:q[`CL_DEVICE_&#8203;GLOBAL_&#8203;ATOMIC_&#8203;CMPXCHG_&#8203;INTEL`]
:CL_DEVICE_GLOBAL_ATOMIC_AND_OR_XOR_INTEL: pass:q[`CL_DEVICE_&#8203;GLOBAL_&#8203;ATOMIC_&#8203;AND_&#8203;OR_&#8203;XOR_&#8203;INTEL`]
:CL_DEVICE_LOCAL_ATOMIC_LOAD_STORE_INTEL: pass:q[`CL_DEVICE_&#8203;LOCAL_&#8203;ATOMIC_&#8203;LOAD_&#8203;STORE_&#8203;INTEL`]
:CL_DEVICE_LOCAL_ATOMIC_ADD_INTEL: pass:q[`CL_DEVICE_&#8203;LOCAL_&#8203;ATOMIC_&#8203;ADD_&#8203;INTEL`]
:CL_DEVICE_LOCAL_ATOMIC_MIN_MAX_INTEL: pass:q[`CL_DEVICE_&#8203;LOCAL_&#8203;ATOMIC_&#8203;MIN_&#8203;MAX_&#8203;INTEL`]
:CL_DEVICE_LOCAL_ATOMIC_CMPXCHG_INTEL: pass:q[`CL_DEVICE_&#8203;LOCAL_&#8203;ATOMIC_&#8203;CMPXCHG_&#8203;INTEL`]
:CL_DEVICE_LOCAL_ATOMIC_AND_OR_XOR_INTEL: pass:q[`CL_DEVICE_&#8203;LOCAL_&#8203;ATOMIC_&#8203;AND_&#8203;OR_&#8203;XOR_&#8203;INTEL`]
:CL_DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE_EXT: pass:q[`CL_DEVICE_&#8203;GLOBAL_&#8203;FP_&#8203;ATOMIC_&#8203;LOAD_&#8203;STORE_&#8203;EXT`]
:CL_DEVICE_GLOBAL_FP_ATOMIC_ADD_EXT: pass:q[`CL_&#8203;DEVICE_&#8203;GLOBAL_&#8203;FP_&#8203;ATOMIC_&#8203;ADD_&#8203;EXT`]
:CL_DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX_EXT: pass:q[`CL_DEVICE_&#8203;GLOBAL_&#8203;FP_&#8203;ATOMIC_&#8203;MIN_&#8203;MAX_&#8203;EXT`]
:CL_DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE_EXT: pass:q[`CL_DEVICE_&#8203;LOCAL_&#8203;FP_&#8203;ATOMIC_&#8203;LOAD_&#8203;STORE_&#8203;EXT`]
:CL_DEVICE_LOCAL_FP_ATOMIC_ADD_EXT: pass:q[`CL_DEVICE_&#8203;LOCAL_&#8203;FP_&#8203;ATOMIC_&#8203;ADD_&#8203;EXT`]
:CL_DEVICE_LOCAL_FP_ATOMIC_MIN_MAX_EXT: pass:q[`CL_DEVICE_&#8203;LOCAL_&#8203;FP_&#8203;ATOMIC_&#8203;MIN_&#8203;MAX_&#8203;EXT`]
endif::[]

= cl_intel_int16_atomics

== Name Strings

`cl_intel_int16_atomics`

== Contact

Ben Ashbaugh, Intel (ben 'dot' ashbaugh 'at' intel 'dot' com)

== Contributors

// spell-checker: disable
Ben Ashbaugh, Intel +// spell-checker: enable

== Notice

Copyright (c) 2025 Intel Corporation.  All rights reserved.

== Status

* Working Draft

This is a preview extension specification, intended to provide early access to a feature for review and community feedback. When the feature matures, this specification may be released as a formal extension.

Because the interfaces defined by this specification are not final and are subject to change they are not intended to be used by shipping software products. If you are interested in using this feature in your software product, please let us know!

== Version

Built On: {docdate} +
Revision: 0.9.0

== Dependencies

This extension is written against the OpenCL API Specification, OpenCL C Specification, and OpenCL SPIR-V Environment Specification Versions 3.0.19.

This extension reuses the `cl_device_fp_atomic_capabilities_ext` bitfield type and related bits from the `cl_ext_float_atomics` extension to describe the floating-point atomic capabilities for the 16-bit `bfloat16` type supported by this extension.

This extension depends on the SPIR-V `SPV_INTEL_16bit_atomics` extension.

== Overview

This extension enables programmers to perform atomic operations on 16-bit numbers in memory.
An OpenCL device supporting this extension may support atomic operations on 16-bit integer values (`int16`) or 16-bit `bfloat16` floating-point values (`bf16`).
For these types, an OpenCL device may support basic atomic operations (load, store, and exchange), atomic compare-and-exchange, atomic addition and subtraction, atomic min and max, and bitwise atomic operations (and, or, and xor).
The numbers may be in global or local memory.

The initial version of this extension only supports the additional atomic operations through SPIR-V.
Subsequent versions of this extension may extend the OpenCL C programming language to support the additional atomic operations, also.

== New API Functions

None.

== New API Enums

Accepted value for the _param_name_ parameter to *clGetDeviceInfo* to query the floating-point atomic capabilities of an OpenCL device:

[source]
----
#define CL_DEVICE_INT16_ATOMIC_CAPABILITIES_INTEL   0xXXXX
#define CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL    0xXXXX
----

Bitfield type describing atomic operations that are supported by of an OpenCL device.
Subsequent versions of this extension may add additional supported atomic operations:

[source]
----
typedef cl_bitfield         cl_device_atomic_operations_intel;

#define CL_DEVICE_GLOBAL_ATOMIC_LOAD_STORE_INTEL        (1 << 0)
#define CL_DEVICE_GLOBAL_ATOMIC_ADD_INTEL               (1 << 1)
#define CL_DEVICE_GLOBAL_ATOMIC_MIN_MAX_INTEL           (1 << 2)
#define CL_DEVICE_GLOBAL_ATOMIC_CMPXCHG_INTEL           (1 << 3)
#define CL_DEVICE_GLOBAL_ATOMIC_AND_OR_XOR_INTEL        (1 << 4)

/* bits 5 - 15 are currently unused */

#define CL_DEVICE_LOCAL_ATOMIC_LOAD_STORE_INTEL         (1 << 16)
#define CL_DEVICE_LOCAL_ATOMIC_ADD_INTEL                (1 << 17)
#define CL_DEVICE_LOCAL_ATOMIC_MIN_MAX_INTEL            (1 << 18)
#define CL_DEVICE_LOCAL_ATOMIC_CMPXCHG_INTEL            (1 << 19)
#define CL_DEVICE_LOCAL_ATOMIC_AND_OR_XOR_INTEL         (1 << 20)

/* bits 21 and beyond are currently unused */
----

== New OpenCL C Feature Names

None.

== New OpenCL C Types

None.

== New OpenCL C Functions

None.

== Modifications to the OpenCL API Specification

Add to Table 5 - OpenCL Device Queries in Section 4.2 - Querying Devices: ::
+
--
[caption="Table 5. "]
.List of supported param_names by clGetDeviceInfo
[width="100%",cols="4,3,5",options="header"]
|====
| Device Info | Return Type | Description
| {CL_DEVICE_INT16_ATOMIC_CAPABILITIES_INTEL}
  | {cl_device_atomic_operations_intel_TYPE}
      | Describes the 16-bit integer atomic operations supported by the device.
        This is a bit-field that describes a combination of the following values:

        {CL_DEVICE_GLOBAL_ATOMIC_LOAD_STORE_INTEL} - Can perform load, store, and exchange atomic operations in global memory. +
        {CL_DEVICE_GLOBAL_ATOMIC_ADD_INTEL} - Can perform addition and subtraction atomic operations in global memory. +
        {CL_DEVICE_GLOBAL_ATOMIC_MIN_MAX_INTEL} - Can perform min and max atomic operations in global memory. +
        {CL_DEVICE_GLOBAL_ATOMIC_CMPXCHG_INTEL} - Can perform bitwise compare-and-exchange atomic operations in global memory. +
        {CL_DEVICE_GLOBAL_ATOMIC_AND_OR_XOR_INTEL} - Can perform bitwise and, or, and xor operations in global memory. +

        {CL_DEVICE_LOCAL_ATOMIC_LOAD_STORE_INTEL} - Can perform floating-point load, store, and exchange atomic operations in local memory. +
        {CL_DEVICE_LOCAL_ATOMIC_ADD_INTEL} - Can perform floating-point addition and subtraction atomic operations in local memory. +
        {CL_DEVICE_LOCAL_ATOMIC_MIN_MAX_INTEL} - Can perform floating-point min and max atomic operations in local memory. +
        {CL_DEVICE_LOCAL_ATOMIC_CMPXCHG_INTEL} - Can perform bitwise compare-and-exchange atomic operations in local memory. +
        {CL_DEVICE_LOCAL_ATOMIC_AND_OR_XOR_INTEL} - Can perform bitwise and, or, and xor operations in local memory. +
        
        There is no mandated minimum capability.
| {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL}
  | {cl_device_fp_atomic_capabilities_ext_TYPE}
      | Describes the 16-bit `bfloat16` floating-point atomic operations supported by the device.
        This is a bit-field that describes a combination of the following values:

        {CL_DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE_EXT} - Can perform floating-point load, store, and exchange atomic operations in global memory. +
        {CL_DEVICE_GLOBAL_FP_ATOMIC_ADD_EXT} - Can perform floating-point addition and subtraction atomic operations in global memory. +
        {CL_DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX_EXT} - Can perform floating-point min and max atomic operations in global memory. +

        {CL_DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE_EXT} - Can perform floating-point load, store, and exchange atomic operations in local memory. +
        {CL_DEVICE_LOCAL_FP_ATOMIC_ADD_EXT} - Can perform floating-point addition and subtraction atomic operations in local memory. +
        {CL_DEVICE_LOCAL_FP_ATOMIC_MIN_MAX_EXT} - Can perform floating-point min and max atomic operations in local memory. +
        
        There is no mandated minimum capability.
|====
--

== Modifications to the OpenCL SPIR-V Environment Specification

(Add a new section 5.2.X - `cl_intel_int16_atomics`) ::
+
--
If the OpenCL environment supports the extension `cl_intel_int16_atomics` and the {CL_DEVICE_INT16_ATOMIC_CAPABILITIES_INTEL} bitfield includes {CL_DEVICE_GLOBAL_ATOMIC_LOAD_STORE_INTEL}, {CL_DEVICE_GLOBAL_ATOMIC_CMPXCHG_INTEL}, {CL_DEVICE_LOCAL_ATOMIC_LOAD_STORE_INTEL}, or {CL_DEVICE_LOCAL_ATOMIC_CMPXCHG_INTEL}, then the environment must accept modules that declare use of the extension `SPV_INTEL_16bit_atomics` and that declare the SPIR-V capability *AtomicInt16CompareExchangeINTEL*.
For the instructions enabled by these capabilities:

  * When {CL_DEVICE_INT16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_GLOBAL_ATOMIC_LOAD_STORE_INTEL} or {CL_DEVICE_GLOBAL_ATOMIC_CMPXCHG_INTEL}, then the _Pointer_ operand may be a pointer to the *CrossWorkGroup* _Storage Class_.
  * When {CL_DEVICE_INT16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_LOCAL_ATOMIC_LOAD_STORE_INTEL} or {CL_DEVICE_LOCAL_ATOMIC_CMPXCHG_INTEL}, then the _Pointer_ operand may be a pointer to the *Workgroup* _Storage Class_.
  * When {CL_DEVICE_INT16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_GLOBAL_ATOMIC_LOAD_STORE_INTEL} and {CL_DEVICE_LOCAL_ATOMIC_LOAD_STORE_INTEL}, or {CL_DEVICE_GLOBAL_ATOMIC_CMPXCHG_INTEL} and {CL_DEVICE_LOCAL_ATOMIC_CMPXCHG_INTEL}, and the *GenericPointer* capability is supported and declared, then the _Pointer_ operand may be a pointer to the *Generic* _Storage Class_.

If the OpenCL environment supports the extension `cl_intel_int16_atomics` and the {CL_DEVICE_INT16_ATOMIC_CAPABILITIES_INTEL} bitfield includes {CL_DEVICE_GLOBAL_ATOMIC_ADD_INTEL}, {CL_DEVICE_GLOBAL_ATOMIC_MIN_MAX_INTEL}, {CL_DEVICE_GLOBAL_ATOMIC_AND_OR_XOR_INTEL}, {CL_DEVICE_LOCAL_ATOMIC_ADD_INTEL}, {CL_DEVICE_LOCAL_ATOMIC_MIN_MAX_INTEL}, or {CL_DEVICE_LOCAL_ATOMIC_AND_OR_XOR_INTEL},  then the environment must accept modules that declare use of the extension `SPV_INTEL_16bit_atomics` and that declare the SPIR-V capability *Int16AtomicsINTEL*.
For the instructions enabled by these capabilities:

  * When {CL_DEVICE_INT16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_GLOBAL_ATOMIC_ADD_INTEL}, {CL_DEVICE_GLOBAL_ATOMIC_MIN_MAX_INTEL}, or {CL_DEVICE_GLOBAL_ATOMIC_AND_OR_XOR_INTEL}, then the _Pointer_ operand may be a pointer to the *CrossWorkGroup* _Storage Class_.
  * When {CL_DEVICE_INT16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_LOCAL_ATOMIC_ADD_INTEL}, {CL_DEVICE_LOCAL_ATOMIC_MIN_MAX_INTEL}, or {CL_DEVICE_LOCAL_ATOMIC_AND_OR_XOR_INTEL}, then the _Pointer_ operand may be a pointer to the *Workgroup* _Storage Class_.
  * When {CL_DEVICE_INT16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_GLOBAL_ATOMIC_ADD_INTEL} and {CL_DEVICE_LOCAL_ATOMIC_ADD_INTEL}, or {CL_DEVICE_GLOBAL_ATOMIC_MIN_MAX_INTEL} and {CL_DEVICE_LOCAL_ATOMIC_MIN_MAX_INTEL}, or {CL_DEVICE_GLOBAL_ATOMIC_AND_OR_XOR_INTEL} and {CL_DEVICE_LOCAL_ATOMIC_AND_OR_XOR_INTEL}, and the *GenericPointer* capability is supported and declared, then the _Pointer_ operand may be a pointer to the *Generic* _Storage Class_.

If the OpenCL environment supports the extension `cl_intel_int16_atomics` and the {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL} bitfield includes {CL_DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE_EXT} or {CL_DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE_EXT}, then the environment must accept modules that declare use of the extension `SPV_INTEL_16bit_atomics` and that declare the SPIR-V capability *AtomicBFloat16LoadStoreINTEL*.
For the instructions enabled by these capabilities:

  * When {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE_EXT}, then the _Pointer_ operand may be a pointer to the *CrossWorkGroup* _Storage Class_.
  * When {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE_EXT}, then the _Pointer_ operand may be a pointer to the *Workgroup* _Storage Class_.
  * When {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE_EXT} and {CL_DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE_EXT}, and the *GenericPointer* capability is supported and declared, then the _Pointer_ operand may be a pointer to the *Generic* _Storage Class_.

If the OpenCL environment supports the extension `cl_intel_int16_atomics` and the {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL} bitfield includes {CL_DEVICE_GLOBAL_FP_ATOMIC_ADD_EXT} or {CL_DEVICE_LOCAL_FP_ATOMIC_ADD_EXT}, then the environment must accept modules that declare use of the extension `SPV_INTEL_16bit_atomics` and that declare the SPIR-V capability *AtomicBFloat16AddINTEL*.
For the instructions enabled by these capabilities:

  * When {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_GLOBAL_FP_ATOMIC_ADD_EXT}, then the _Pointer_ operand may be a pointer to the *CrossWorkGroup* _Storage Class_.
  * When {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_LOCAL_FP_ATOMIC_ADD_EXT}, then the _Pointer_ operand may be a pointer to the *Workgroup* _Storage Class_.
  * When {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_GLOBAL_FP_ATOMIC_ADD_EXT} and {CL_DEVICE_LOCAL_FP_ATOMIC_ADD_EXT}, and the *GenericPointer* capability is supported and declared, then the _Pointer_ operand may be a pointer to the *Generic* _Storage Class_.

If the OpenCL environment supports the extension `cl_intel_int16_atomics` and the {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL} bitfield includes {CL_DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX_EXT} or {CL_DEVICE_LOCAL_FP_ATOMIC_MIN_MAX_EXT}, then the environment must accept modules that declare use of the extension `SPV_INTEL_16bit_atomics` and that declare the SPIR-V capability *AtomicBFloat16MinMaxINTEL*.
For the instructions enabled by these capabilities:

  * When {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX_EXT}, then the _Pointer_ operand may be a pointer to the *CrossWorkGroup* _Storage Class_.
  * When {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_LOCAL_FP_ATOMIC_MIN_MAX_EXT}, then the _Pointer_ operand may be a pointer to the *Workgroup* _Storage Class_.
  * When {CL_DEVICE_BF16_ATOMIC_CAPABILITIES_INTEL} includes {CL_DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX_EXT} and {CL_DEVICE_LOCAL_FP_ATOMIC_MIN_MAX_EXT}, and the *GenericPointer* capability is supported and declared, then the _Pointer_ operand may be a pointer to the *Generic* _Storage Class_.
--

== Issues

. Do we need to support the legacy OpenCL C 1.x atomic syntax, or is it sufficient to only support the newer OpenCL C 2.0 atomic syntax?
+
--
`RESOLVED`: We will only support the newer OpenCL 2.0 atomic syntax in the initial version of this extension.
--

. Do we need to document any special floating-point behavior for floating-point atomic add?
+
--
`RESOLVED`: Floating-point atomic add may be affected by compiler options affecting floating-point behavior, such as `-cl-no-signed-zeros`, `-cl-denorms-are-zero`, and `-cl-finite-math-only`, otherwise there is no special behavior.
--

. Do we need to document any special floating-point behavior for floating-point atomic min and max?
+
--
`RESOLVED`: This spec inherits all of the special-case NaN behavior from the SPIR-V atomic min and max spec.
Additionally, floating-point atomic min and max may be affected by compiler options affecting floating-point behavior, such as `-cl-no-signed-zeros`, `-cl-denorms-are-zero`, and `-cl-finite-math-only`.
Otherwise, there is no special behavior.
--


== Revision History

[cols="5,15,15,65"]
[grid="rows"]
[options="header"]
|========================================
|Version|Date|Author|Changes
|1.0.0|2020-08-12|Ben Ashbaugh|*Final draft.*
|========================================

//************************************************************************
//Other formatting suggestions:
//
//* Use *bold* text for host APIs, or [source] syntax highlighting.
//* Use `mono` text for device APIs, or [source] syntax highlighting.
//* Use `mono` text for extension names, types, or enum values.
//* Use _italics_ for parameters.
//************************************************************************
