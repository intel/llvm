# SYCL 1-Pass Compilation Model

Currently the DPC++ compiler utilizes a scheme which needs multiple invocations of the compiler.  Specifically, it invokes the cc1 compiler once for each device compilation and one more time for the host compilation.  This document describes design changes necessary (in the various components of the DPC++ Toolchain) to switch to a single invocation of the cc1 compiler for each Translation Unit (TU).

## Compiler Front End (FE) Changes

This design reuqires some changes from the FE.  In particular, it needs to emit code via the normal/standard C++ rules, and in addition, needs to emit functions that are required for Kernel code, which may not have been emitted via the normal C++ rules.

### Generation and dispatch to the OpenCL Kernel

The FE will generate the OpenCL Kernel which creates the Functor object that it will call into.  FE then replaces the [[sycl_kernel]] function with one that dispatches to the OpenCL Kernel.  New APIs from the SYCL Runtime Library (RTL) are needed to accomplish this task.

The [[sycl_kernel]] function is actually code-gen'ed twice.  The code in "EmitFunctionDecl" for the [[sycl_kernel]] functions is replaced with 2 separate functions:

the one on the host-side, which generates the decomposition of the function object, does the calls into the RTL to move this data over to the device, and calls the OpenCL kernel.

the one on the device-side, which is just the OpenCL kernel, is similar to what we already generate for the device side.  But this now needs to happen at the IR level instead of the AST/Sema level.

### Elimination of generation of the integration header file

Since there is no longer separate device and host compilation invocations, communication between them via the integration header file is no longer necessary, in the one-pass model.  Instead the FE can pass the information previously generated in the header file directly to the RTL via new APIs.

However we may need to retain the code that previously emitted the integration header and footer files if we still need a two-pass model.

### Elimination of generation of the integration footer file
Similarly, an integration footer file too is no longer necessary in the one-pass model, but specialization constants need to still be handled.

### Intrinsics and builtins
There will need to be some kind of collection of all intrinsics that we support over all devices into one table.  If intrinsics are spelled the same but have differing signatures, they will need to be renamed to be unique across the affected devices.

### Function attributes and instruction extensions
TODO

### Deferred device diagnostics
A vast majority of our diagnostics will be converted to be exclusively deferred- diagnostics when possible.  FE will add an end-of-TU checker to emit deferred device diagnostics.

## Optimizer Changes
The main change here will be to enable the ability to have multiple versions of LLVM IR running at once, as well as multiple separate invocations of the Code Generator.  A split-pass which creates a host LLVM-IR and device LLVM-IRs is added here; this in turn needs reachability analysis to figure out which is needed for device(s).  Optimizations specific to host or device occur on the respective IRs after this pass.  For ease of implementation, this document does not suggest adding optimizations common to both host and device(s) to occur prior to the split.  They may be added later when need arises.

## RTL Changes
New APIs are needed to assist the FE in generating the dispatch to the OpenCL Kernel.

## Tools Changes
A new tool (device-code-extractor) will be added before the llvm-link step to split host and device code. Remaining post-compile and linker flow will stay same. 
sycl-post-link changes may be needed based on the changes in the IR emitted by the FE.

## Header files and library changes
Since the host and devices are not compiled separately anymore, using macros to separate code that executes on one side or the other, is no longer a viable option.

Some general areas that will need to be addressed include:

* Some SYCL API implementation uses the macro to choose between a call to a SPIR-V built-in or host-side implementation (e.g. atomics)
* Some SYCL classes have different layout on host and device (e.g. accessor, half)
* Libdevice currently uses the macros to leave functions undefined on the host side & choose between different implementations based on target

To enable executing code specifically on the device or on the host, the following two proposals are expected to be adopted - [if_device][1] and [if_device_has][2].
 
[1]:<https://github.com/intel/llvm/pull/8917>
[2]:<https://github.com/intel/llvm/pull/9127>

## Driver changes
To enable the set of changes, the Driver will need to invoke the Compiler just once; it no longer needs to invoke the compilers multiple times for the devices and once for the host.  Also, integration header and footer are no longer generated by the Compiler invocation.  Invoking the device-code-extractor will be a new step, but no further changes are anticipated in the post-link phase.

Optionally, the Driver may need to support both the current 2-pass model as well as the new 1-pass model for a couple of releases of the compiler.   When the 1-pass model is being developed and initially field-tested, the 2-pass model will continue to be the default with a command-line option enabling the 1-pass model.  Once it is determined to be tested enough, the 1-pass model will become the default and a negated spelling of the above option will need to be specified to explicitly request the 2-pass model, which will be deprecated.
