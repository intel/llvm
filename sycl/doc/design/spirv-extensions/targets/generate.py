import io
import json
from pathlib import Path

SOURCE_JSON = "core.json"
HEADER_NAME = Path("registry.h")
TARGETS_ASCIIDOC_NAME = Path("targets.asciidoc")
ARCH_ASCIIDOC_NAME = Path("architectures.asciidoc")

# some unique identifier:
HEADER_PREFIX = "FnVar"
HEADER_PREFIX_UPPER = "FNVAR"
HEADER_MAXVAL = 2**31 - 1

ASCIIDOC_COLS_W = {
    "name": "8",
    "value": "3",
    "desc": "10",
}

### C header


def _name(name: str) -> str:
    return "".join([part.capitalize() for part in name.replace(".", "_").split("_")])


def write_header_init(data: dict, outfile: io.TextIOWrapper):
    outfile.write("// This header is automatically generated by generate.py.\n\n")
    outfile.write(f"#define {HEADER_PREFIX_UPPER}_VERSION ({data['version']})\n")


def write_header_targets(data: dict, outfile: io.TextIOWrapper):
    targets = data["targets"]
    prefix = f"{HEADER_PREFIX}Target"

    outfile.write(f"typedef enum {prefix}_ {{\n")

    for target in targets:
        outfile.write(
            f"    {prefix}_{_name(target['name'])} = {target['value']}, //"
            f" {target['desc']}\n"
        )

    outfile.write(f"    {prefix}_Max = {HEADER_MAXVAL:#08x},\n")
    outfile.write(f"}} {prefix};\n")


def write_header_features(data: dict, outfile: io.TextIOWrapper):
    at_least_one = False

    for target, features in data["features"].items():
        if at_least_one:
            outfile.write("\n")
        at_least_one = True

        prefix = f"{HEADER_PREFIX}Feature_{_name(target)}"

        outfile.write(f"typedef enum {prefix}_ {{\n")

        for feature in features:
            outfile.write(
                f"    {prefix}_{_name(feature['name'])} = {feature['value']}, //"
                f" {feature['desc']}\n".replace(".", "_")
            )

        outfile.write(f"    {prefix}_Max = {HEADER_MAXVAL:#08x},\n")
        outfile.write(f"}} {prefix};\n")


def write_header_architecture_categories(data: dict, outfile: io.TextIOWrapper):
    arch_cats = data["architecture_categories"]
    prefix = f"{HEADER_PREFIX}ArchCategory"

    outfile.write(f"typedef enum {prefix}_ {{\n")

    for arch_cat in arch_cats:
        outfile.write(
            f"    {prefix}_{_name(arch_cat['name'])} = {arch_cat['value']}, //"
            f" {arch_cat['desc']}\n"
        )

    outfile.write(f"    {prefix}_Max = {HEADER_MAXVAL:#08x},\n")
    outfile.write(f"}} {prefix};\n")


def write_header_architecture_families(data: dict, outfile: io.TextIOWrapper):
    at_least_one = False

    for arch_cat, arch_fams in data["architecture_families"].items():
        if at_least_one:
            outfile.write("\n")
        at_least_one = True

        prefix = f"{HEADER_PREFIX}ArchFamily_{_name(arch_cat)}"

        outfile.write(f"typedef enum {prefix}_ {{\n")

        for arch_fam in arch_fams:
            outfile.write(
                f"    {prefix}_{_name(arch_fam['name'])} = {arch_fam['value']}, //"
                f" {arch_fam['desc']}\n".replace(".", "_")
            )

        outfile.write(f"    {prefix}_Max = {HEADER_MAXVAL:#08x},\n")
        outfile.write(f"}} {prefix};\n")


def write_header_architectures(data: dict, outfile: io.TextIOWrapper):
    at_least_one = False

    for arch_cat, arch_fams in data["architectures"].items():
        for arch_fam, archs in arch_fams.items():
            if at_least_one:
                outfile.write("\n")
            at_least_one = True

            prefix = f"{HEADER_PREFIX}Arch_{_name(arch_cat)}_{_name(arch_fam)}"

            outfile.write(f"typedef enum {prefix}_ {{\n")

            for arch in archs:
                outfile.write(
                    f"    {prefix}_{_name(arch['name'])} = {arch['value']}, //"
                    f" {arch['desc']}\n"
                )

            outfile.write(f"    {prefix}_Max = {HEADER_MAXVAL:#08x},\n")
            outfile.write(f"}} {prefix};\n")


### asciidoc tables


def _write_entries_with_aliases(
    entries: list, outfile: io.TextIOWrapper, extras: list = []
):
    seen_aliases = []
    for i, entry in enumerate(entries):
        if entry["name"] in seen_aliases:
            continue
        aliases = []
        if i < len(entries) - 1:
            for entry2 in entries[i + 1 :]:
                if entry["value"] == entry2["value"]:
                    aliases.append(entry2["name"])
        seen_aliases.extend(aliases)

        outfile.write("\n")
        outfile.write("a|\n")
        outfile.write("[source]\n")
        outfile.write("----\n")
        outfile.write(f'{entry["name"]}\n')
        for alias in aliases:
            outfile.write(f'{alias} = {entry["name"]}\n')
        outfile.write("----\n")
        for val in extras:
            outfile.write(f"| {val}\n")
        outfile.write(f'| {entry["value"]}\n')
        outfile.write(f'| {entry["desc"]}\n')


def _value_of_name(name: str, entries: list, in_what: str) -> int:
    value = None
    for entry in entries:
        if name == entry["name"]:
            value = entry["value"]
            break

    if value is None:
        raise ValueError(f"{name} not found in {in_what}.")

    return value


def write_asciidoc_targets(data: dict, outfile: io.TextIOWrapper):
    targets = data["targets"]

    cols_w = [
        ASCIIDOC_COLS_W["name"],
        ASCIIDOC_COLS_W["value"],
        ASCIIDOC_COLS_W["desc"],
    ]
    cols_w_str = ",".join(cols_w)

    outfile.write(f'[%header,cols="{cols_w_str}"]\n')
    outfile.write("|===\n")
    outfile.write("|Name\n")
    outfile.write("|Value\n")
    outfile.write("|Description\n")

    _write_entries_with_aliases(targets, outfile)

    outfile.write("|===\n")


def write_asciidoc_features(data: dict, outfile: io.TextIOWrapper):
    features = data["features"]
    targets = data["targets"]

    cols_w = [
        ASCIIDOC_COLS_W["name"],
        ASCIIDOC_COLS_W["value"],
        ASCIIDOC_COLS_W["value"],
        ASCIIDOC_COLS_W["desc"],
    ]
    cols_w_str = ",".join(cols_w)

    outfile.write(f'[%header,cols="{cols_w_str}"]\n')
    outfile.write("|===\n")
    outfile.write("|Name\n")
    outfile.write("|Target\n")
    outfile.write("|Value\n")
    outfile.write("|Description\n")

    seen_targets = {}
    for target, features in features.items():
        target_value = _value_of_name(target, targets, "targets")
        target_aliases = [
            tgt["name"] for tgt in targets if tgt["value"] == target_value
        ]
        if target_value in seen_targets:
            raise ValueError(
                f"Target '{target}' with value {target_value} is an alias of"
                f" '{seen_targets[target_value]}' and thus cannot have its own"
                " features."
            )
        seen_targets[target_value] = target

        outfile.write(
            f"\n{len(cols_w)}+^|*Target:"
            f" {', '.join(target_aliases)} ({target_value})*\n"
        )
        _write_entries_with_aliases(features, outfile, extras=[target_value])

    outfile.write("|===\n")


def write_asciidoc_architecture_categories(data: dict, outfile: io.TextIOWrapper):
    categories = data["architecture_categories"]

    cols_w = [
        ASCIIDOC_COLS_W["name"],
        ASCIIDOC_COLS_W["value"],
        ASCIIDOC_COLS_W["desc"],
    ]
    cols_w_str = ",".join(cols_w)

    outfile.write(f'[%header,cols="{cols_w_str}"]\n')
    outfile.write("|===\n")
    outfile.write("|Name\n")
    outfile.write("|Value\n")
    outfile.write("|Description\n")

    _write_entries_with_aliases(categories, outfile)

    outfile.write("|===\n")


def write_asciidoc_architecture_families(data: dict, outfile: io.TextIOWrapper):
    families = data["architecture_families"]
    categories = data["architecture_categories"]

    cols_w = [
        ASCIIDOC_COLS_W["name"],
        ASCIIDOC_COLS_W["value"],
        ASCIIDOC_COLS_W["value"],
        ASCIIDOC_COLS_W["desc"],
    ]
    cols_w_str = ",".join(cols_w)

    outfile.write(f'[%header,cols="{cols_w_str}"]\n')
    outfile.write("|===\n")
    outfile.write("|Name\n")
    outfile.write("|Category\n")
    outfile.write("|Value\n")
    outfile.write("|Description\n")

    seen_categories = {}
    for category, families in families.items():
        category_value = _value_of_name(category, categories, "categories")
        category_aliases = [
            cat["name"] for cat in categories if cat["value"] == category_value
        ]
        if category_value in seen_categories:
            raise ValueError(
                f"Category '{category}' with value {category_value} is an alias of"
                f" '{seen_categories[category_value]}' and thus cannot have its own"
                " families."
            )
        seen_categories[category_value] = category

        outfile.write(
            f"\n{len(cols_w)}+^|*Category:"
            f" {', '.join(category_aliases)} ({category_value})*\n"
        )
        _write_entries_with_aliases(families, outfile, extras=[category_value])

    outfile.write("|===\n")


def write_asciidoc_architectures(data: dict, outfile: io.TextIOWrapper):
    categories = data["architecture_categories"]
    families = data["architecture_families"]
    architectures = data["architectures"]

    cols_w = [
        ASCIIDOC_COLS_W["name"],
        ASCIIDOC_COLS_W["value"],
        ASCIIDOC_COLS_W["value"],
        ASCIIDOC_COLS_W["value"],
        ASCIIDOC_COLS_W["desc"],
    ]
    cols_w_str = ",".join(cols_w)

    outfile.write(f'[%header,cols="{cols_w_str}"]\n')
    outfile.write("|===\n")
    outfile.write("|Name\n")
    outfile.write("|Category\n")
    outfile.write("|Family\n")
    outfile.write("|Value\n")
    outfile.write("|Description\n")

    seen_categories = {}
    for arch_category, arch_families in architectures.items():
        category_value = _value_of_name(arch_category, categories, "categories")
        category_aliases = [
            cat["name"] for cat in categories if cat["value"] == category_value
        ]
        if category_value in seen_categories:
            raise ValueError(
                f"Category '{arch_category}' with value {category_value} is an alias of"
                f" '{seen_categories[category_value]}' and thus cannot have its own"
                " families or architectures."
            )
        seen_categories[category_value] = arch_category

        seen_families = {}
        for arch_family, arch_architectures in arch_families.items():
            family_value = _value_of_name(
                arch_family,
                families[arch_category],
                f"families of {arch_category} category",
            )
            family_aliases = [
                fam["name"]
                for fam in families[arch_category]
                if fam["value"] == family_value
            ]
            if family_value in seen_families:
                raise ValueError(
                    f"Family '{arch_family}' with value {family_value} is an alias of"
                    f" '{seen_families[family_value]}' and thus cannot have its own"
                    " architectures."
                )
            seen_families[family_value] = arch_family

            outfile.write(
                f"\n{len(cols_w)}+^|*Category:"
                f" {', '.join(category_aliases)} ({category_value}), Family:"
                f" {', '.join(family_aliases)} ({family_value})*\n"
            )
            _write_entries_with_aliases(
                arch_architectures, outfile, extras=[category_value, family_value]
            )

    outfile.write("|===\n")


def main():
    with open(SOURCE_JSON) as rf:
        data = json.load(rf)

    print(f"Writing {HEADER_NAME}")
    with open(HEADER_NAME, "w") as wf:
        write_header_init(data, wf)

        wf.write("\n// Targets\n\n")
        write_header_targets(data, wf)

        wf.write("\n// Features\n\n")
        write_header_features(data, wf)

        wf.write("\n// Architecture Categories\n\n")
        write_header_architecture_categories(data, wf)

        wf.write("\n// Architecture Families\n\n")
        write_header_architecture_families(data, wf)

        wf.write("\n// Architectures\n\n")
        write_header_architectures(data, wf)

    print(f"Writing {TARGETS_ASCIIDOC_NAME}")
    with open(TARGETS_ASCIIDOC_NAME, "w") as wf:
        wf.write("\n== Targets\n\n")
        write_asciidoc_targets(data, wf)
        wf.write("\n== Features\n\n")
        write_asciidoc_features(data, wf)

    print(f"Writing {ARCH_ASCIIDOC_NAME}")
    with open(ARCH_ASCIIDOC_NAME, "w") as wf:
        wf.write("\n== Architecture Categories\n\n")
        write_asciidoc_architecture_categories(data, wf)
        wf.write("\n== Architecture Families\n\n")
        write_asciidoc_architecture_families(data, wf)
        wf.write("\n== Architectures\n\n")
        write_asciidoc_architectures(data, wf)


if __name__ == "__main__":
    main()
