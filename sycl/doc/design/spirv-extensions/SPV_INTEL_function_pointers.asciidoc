:OpConstantFunctionPointerINTEL_token: 5600
:OpFunctionPointerCallINTEL_token: 5601
:ReferencedIndirectlyINTEL_token: 5602
:FunctionPointersINTEL_token: 5603
:IndirectReferencesINTEL_token: 5604
:CodeSectionINTEL_token: 5605
:ArgumentAttributeINTEL_token: 6409

= SPV_INTEL_function_pointers

== Name Strings

SPV_INTEL_function_pointers

== Contact

To report problems or to provide input on this extension, please open a new issue at:

https://github.com/intel/llvm/issues

== Contributors

- Alexey Sachkov, Intel
- Mariusz Merecki, Intel
- Ben Ashbaugh, Intel
- Pawel Jurek, Intel
- Thomas Raoux, Intel
- Nikita Kornev, Intel
- Dmitry Sidorov, Intel
- Alex Bezzubikov, Intel

== Notice

Copyright (c) 2019-2023 Intel Corporation. All rights reserved.

== Status

Working Draft

This is a preview extension specification, intended to provide early access to a feature for review and community feedback.
When the feature matures, this specification may be released as a formal extension.

Because the interfaces defined by this specification are not final and are subject to change they are not intended to be used by shipping software products.
If you are interested in using this feature in your software product, please let us know!

== Version

[width="40%",cols="25,25"]
|==================================
| Last Modified Date | {docdate}
| Revision           | J
|==================================

== Dependencies

This extension is written against the SPIR-V Specification, Version 1.6
Revision 2, Unified.

This extension requires SPIR-V 1.0.

== Overview

The goal of this extension is to allow representation of function pointers in
SPIR-V.

This is done by adding two new instructions: one which correspond to
"address of" operator and another which allows to perform an indirect call.
They both are added under *FunctionPointersINTEL* capability.

On top of that, a couple more things are being added by the extension:
- One new decoration added under *IndirectReferencesINTEL* to support functions
  which are not referenced directly in the module. The idea is to extract
  pointer to a function from the module and pass it as argument into one of
  entry points where it will be used.
- One new decoration added under *FunctionPointersINTEL* to preserve argument
  attributes of *OpFunctionPointerCall*.

== Extension Name

To use this extension within a SPIR-V module, the appropriate *OpExtension*
must be present in the module:

----
OpExtension "SPV_INTEL_function_pointers"
----

== Modifications to the SPIR-V Specification, Version 1.6

=== Terms

Modify Section 2.2.2, Types, add the following at the end of the section: ::

[[FunctionPointer]]'Function Pointer': A pointer that points to a function, i.e.
a value of *OpTypePointer* whose _Type_ argument is an id of an
*OpTypeFunction*.

Modify Section 2.9, Function Calling, add the following after the first sentence: ::

Functions can be called indirectly using function pointers: to do so, use
*OpFunctionPointerCallINTEL* with an operand that is the _<id>_ obtained using
*OpConstantFunctionPointerINTEL* of the *OpFunction* to call, and the _<id>s_ of
the arguments to pass. All arguments are passed by value into the called
function. This includes pointers, through which a callee object could be
modified.

=== Validation Rules

Modify section 2.16.1, Universal Validation Rules by adding new rules: ::

- It is illegal to use <<FunctionPointer, Function Pointer>> as 'Pointer' argument
of *OpLoad* and *OpStore* instructions.

- It is illegal to use <<FunctionPointer, Function Pointer>> as 'Pointer' and
'Source' arguments of *OpCopyMemory*, *OpCopyMemorySized* instructions.

=== Storage Classes

Modify Section 3.7, Storage Class, adding to the end of the list of storage classes: ::

[cols="1,4,4",options="header",width="100%"]
|====
2+| Storage Class| <<Capability,Enabling Capabilities>> |
{CodeSectionINTEL_token} | *CodeSectionINTEL* +
This storage represents function pointers. Visible across all functions of
all invocations of all work groups.
| *FunctionPointersINTEL*
|====

Modify Section 3.7, Storage Class, modifying description of *Generic* Storage Class: ::

[cols="1,4,4",options="header",width="100%"]
|====
2+| Storage Class| <<Capability,Enabling Capabilities>> |
8 | *Generic* +
For generic pointers, which overload the *Function*, *Workgroup*,
*CrossWorkgroup* and *CodeSectionINTEL* Storage Classes.
| *GenericPointer*
|====

=== Decorations

Modify Section 3.20, Decorations, adding to the end of the list of decorations: ::

[cols="1,6,1,1,6",options="header",width="100%"]
|====
2+^.^| Decoration 2+<.^| Extra Operands
| <<Capability,Enabling Capabilities>> |
{ReferencedIndirectlyINTEL_token} | *ReferencedIndirectlyINTEL* +
Indicates that a function might not have direct uses within the module,
but its address can be obtained and passed into an Entry Point and called
using *OpFunctionPointerCallINTEL*. This function must not be optimized
out based on call graph/reachability analysis 2+||
*IndirectReferencesINTEL*|
{ArgumentAttributeINTEL_token} | *ArgumentAttributeINTEL* +
Indicates an attribute of argument of an indirect function call. Apply to an
*OpFunctionPointerCallINTEL*. +
_Index_ is an unsigned 32-bit integer indicating the argument number _N_.
The attribute is applied to _Argument N_ of *OpFunctionPointerCallINTEL*.
_Argument Attribute_ specifies which attribute is applied, it should be a value
which is valid to be used with *FuncParamAttr* Decoration.
 |
_<<Literal, Literal>> +
Index_
|
_<<Argument Attribute, Argument Attribute>> +
Argument Attribute_ |
*FunctionPointersINTEL*|
|====

=== Capabilities

Modify Section 3.31, Capabilities, adding to the end of the list of capabilities: ::


[cols="1,10,8,8",options="header",width="80%"]
|====
2+^.^| Capability | Implicitly Declares | Enabled by Extension

| {FunctionPointersINTEL_token}
| *FunctionPointersINTEL*
| *Addresses* | *SPV_INTEL_function_pointers*
| {IndirectReferencesINTEL_token}
| *IndirectReferencesINTEL*
| *Addresses* | *SPV_INTEL_function_pointers*

|====


=== Instructions

Modify Section 3.42.7, Constant-Creation Instructions, adding to the end of the list of instructions: ::

[cols="2*1,3*3",width="100%"]
|=====
4+|[[OpConstantFunctionPointerINTEL]]*OpConstantFunctionPointerINTEL* +
 +
Obtains constant address of the specified function. +
 +
Result value can be used immediately in *OpFunctionPointerCallINTEL*, inserted
into a composite constant or stored somewhere for further usage in
*OpFunctionPointerCallINTEL*. +
 +
_Result Type_ must be an *OpTypePointer*. Its _Type_ operand must be the same
*OpTypeFunction* which was used as _Function Type_ operand of the _Function_
operand. Its _Storage Class_ operand must be *CodeSectionINTEL*
| <<Capability,Capability>>: +
*FunctionPointersINTEL*
| 4 | {OpConstantFunctionPointerINTEL_token} | '<id>' 'Result Type' | '<id> Result ' | '<id>' 'Function'
|=====

Modify Section 3.42.9, Function Instructions, adding to the end of the list of instructions: ::

[cols="2*1,4*3",width="100%"]
|=====
5+|[[OpFunctionPointerCallINTEL]]*OpFunctionPointerCallINTEL* +
 +
Call a function via function pointer. +
 +
_Result Type_ is the type of the return value of the function. +
 +
_Function Pointer_ is <<FunctionPointer, Function Pointer>>. +
 +
_Argument N_ is the object to copy to parameter _N_. +
 +
*Note:* _Result Type_ must match the _Return Type_ of the *OpTypeFunction* which
was used as _Type_ operand of _Function Pointer_ argument and the calling
argument types must match the formal parameter types.
| <<Capability,Capability>>: +
*FunctionPointersINTEL*
| 4 + variable | {OpFunctionPointerCallINTEL_token}
 | '<id>' 'Result Type' | <<ResultId,'Result <id>' >> | '<id>' +
'Function Pointer' |
'<id>, <id>, ..., <id>' 'Argument 0', 'Argument 1', ..., 'Argument N'
|=====

== Issues

. It is unclear which <<Storage_Class,Storage Class>> should function pointers
point to? Do we need new one or *CrossWorkgroup* is enough? How to represent
new storage class/address space in LLVM IR if we need such? How to represent
new storage class/address space in source language?
+
--
*RESOLVED*

Based on cl_intel_function_pointers specification, it is not guaranteed that
`sizeof(void(*)(void) == sizeof(void *)` - to allow consumers use this fact, we
cannot say that function pointer belongs to the same storage class as data
pointers. That is why new storage class was invented.
New storage class can be represented in LLVM IR as-is: any function pointer
implicitly belongs to corresponding storage class in SPIR-V.
Question about source language is out of scope of this spec.
--

. Should we add new *ReferencedIndirectlyINTEL* declaration or we should modify
reserve bit in *FunctionControl* mask? Do we need any special declaration/
function control bit at all? Can we use existing *Linkage Type* functionality?
+
--
*UNRESOLVED*
--

. Do we need to support *OpPtrDiff* for function pointers? Looks like it cannot
be used for ones out of the box and we don't have much use-cases for it.
+
--
*UNRESOLVED*
--

. Should we prohibit heterogenous composites with function pointers? Maybe we should
distinct <<FunctionPointer, Function Pointer>> and Constant Function Pointer?
+
--
*RESOLVED*

In general, we should not since this extension is aimed to support the whole C++ function
pointers functionality in SPIR-V.
--

. Should we distinct const and non-const function pointers in rules for *OpCompositeInsert*?
We can only use a result of *OpConstantFunctionPointerINTEL* (which is a quite specific case of
<<FunctionPointer, Function Pointer>>, so we can't use the whole term in the rule)
in *OpConstantComposite*, but how should we specify that in this spec?
+
--
*RESOLVED*

Removed *OpFunctionPointerINTEL* instruction.
--

//. Issue.
//+
//--
//*RESOLVED*: Resolution.
//--

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|A|2019-02-05|Alexey Sachkov|*Initial revision*
|B|2019-02-27|Alexey Sachkov|Updated description of
*OpFunctionPointerCallINTEL*: added information about type-checking. Added
*ReferencedIndirectly* decoration
|C|2019-01-03|Alexey Sachkov|Added missed `INTEL` suffix
|D|2019-06-03|Alexey Sachkov|Added *FunctionPointersINTEL* and
*IndirectReferencesINTEL* capabilities
|E|2019-06-04|Alexey Sachkov|Applied comments from Mariusz and Pawel: +
- OpFunctionType -> OpTypeFunction +
- Added definition of Function Pointer into Terms section +
- New capabilities implicitly requires Addresses capability +
- Small updates in descriptions of new instructions
|F|2019-06-21|Alexey Sachkov|Added new storage class dedicated for function
pointers. Updated validation rules. Misc updates.
|G|2019-07-19|Ben Ashbaugh|Assigned SPIR-V enums, added preview extension disclaimer text.
|H|2021-11-15|Nikita Kornev|Added new *ArgumentAttributeINTEL* decoration.
|I|2022-10-08|Dmitry Sidorov, Alex Bezzubikov, Alexey Sachkov|Replaced *OpFunctionPointerINTEL* with
*OpConstantFunctionPointerINTEL*
|J|2022-12-13|Alexey Sachkov|Uplift to SPIR-V 1.6 spec, refactor validation +
rules section, remove listing of new instructions at the beginning
|========================================
