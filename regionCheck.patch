diff --git a/sycl/include/sycl/ext/intel/esimd/detail/intrin.hpp b/sycl/include/sycl/ext/intel/esimd/detail/intrin.hpp
index 9cae8695d78c..02054d24be48 100644
--- a/sycl/include/sycl/ext/intel/esimd/detail/intrin.hpp
+++ b/sycl/include/sycl/ext/intel/esimd/detail/intrin.hpp
@@ -64,8 +64,11 @@
 //
 template <typename T, int N, int M, int VStride, int Width, int Stride,
           int ParentWidth = 0>
-__ESIMD_INTRIN __ESIMD_INTRIN std::enable_if_t<M % Width == 0 && (Width > 0),
-                                               __ESIMD_DNS::vector_type_t<T, M>>
+__ESIMD_INTRIN __ESIMD_INTRIN std::enable_if_t<
+    (M % Width) == 0 && (Width > 0) && (Stride <= Width) &&
+        (VStride <= (M / Width)) &&
+        ((((M / Width) - 1) * VStride + (Width - 1) * Stride) < N),
+    __ESIMD_DNS::vector_type_t<T, M>>
 __esimd_rdregion(__ESIMD_DNS::vector_type_t<T, N> Input, uint16_t Offset);
 
 template <typename T, int N, int M, int ParentWidth = 0>
@@ -122,8 +125,11 @@ __esimd_rdindirect(__ESIMD_DNS::vector_type_t<T, N> Input,
 //
 template <typename T, int N, int M, int VStride, int Width, int Stride,
           int ParentWidth = 0>
-__ESIMD_INTRIN std::enable_if_t<M <= N && M % Width == 0 && (Width > 0),
-                                __ESIMD_DNS::vector_type_t<T, N>>
+__ESIMD_INTRIN std::enable_if_t<
+    (M <= N) && (M % Width) == 0 && (Width > 0) && (Stride <= Width) &&
+        (VStride <= (M / Width)) &&
+        ((((M / Width) - 1) * VStride + (Width - 1) * Stride) < N),
+    __ESIMD_DNS::vector_type_t<T, N>>
 __esimd_wrregion(__ESIMD_DNS::vector_type_t<T, N> OldVal,
                  __ESIMD_DNS::vector_type_t<T, M> NewVal, uint16_t Offset,
                  __ESIMD_DNS::simd_mask_storage_t<M> Mask = 1);
@@ -264,8 +270,11 @@ __ESIMD_INTRIN uint16_t __esimd_all(__ESIMD_DNS::vector_type_t<T, N> src)
 // Implementations of ESIMD intrinsics for the SYCL host device
 template <typename T, int N, int M, int VStride, int Width, int Stride,
           int ParentWidth>
-__ESIMD_INTRIN __ESIMD_INTRIN std::enable_if_t<M % Width == 0 && (Width > 0),
-                                               __ESIMD_DNS::vector_type_t<T, M>>
+__ESIMD_INTRIN __ESIMD_INTRIN std::enable_if_t<
+    (M % Width) == 0 && (Width > 0) && (Stride <= Width) &&
+        (VStride <= (M / Width)) &&
+        ((((M / Width) - 1) * VStride + (Width - 1) * Stride) < N),
+    __ESIMD_DNS::vector_type_t<T, M>>
 __esimd_rdregion(__ESIMD_DNS::vector_type_t<T, N> Input, uint16_t Offset) {
   uint16_t EltOffset = Offset / sizeof(T);
   assert(Offset % sizeof(T) == 0);
@@ -299,8 +308,11 @@ __esimd_rdindirect(__ESIMD_DNS::vector_type_t<T, N> Input,
 
 template <typename T, int N, int M, int VStride, int Width, int Stride,
           int ParentWidth>
-__ESIMD_INTRIN std::enable_if_t<M <= N && M % Width == 0 && (Width > 0),
-                                __ESIMD_DNS::vector_type_t<T, N>>
+__ESIMD_INTRIN std::enable_if_t<
+    (M <= N) && (M % Width) == 0 && (Width > 0) && (Stride <= Width) &&
+        (VStride <= (M / Width)) &&
+        ((((M / Width) - 1) * VStride + (Width - 1) * Stride) < N),
+    __ESIMD_DNS::vector_type_t<T, N>>
 __esimd_wrregion(__ESIMD_DNS::vector_type_t<T, N> OldVal,
                  __ESIMD_DNS::vector_type_t<T, M> NewVal, uint16_t Offset,
                  __ESIMD_DNS::simd_mask_storage_t<M> Mask) {
diff --git a/sycl/include/sycl/ext/intel/experimental/esimd/detail/math_intrin.hpp b/sycl/include/sycl/ext/intel/experimental/esimd/detail/math_intrin.hpp
index ec5d33918869..f8a61334d0c8 100644
--- a/sycl/include/sycl/ext/intel/experimental/esimd/detail/math_intrin.hpp
+++ b/sycl/include/sycl/ext/intel/experimental/esimd/detail/math_intrin.hpp
@@ -723,14 +723,10 @@ __esimd_addc(__ESIMD_DNS::vector_type_t<T, N> src0,
     ;
 #else  // !__SYCL_DEVICE_ONLY__
 {
-  __ESIMD_NS::simd<uint64_t, N> Result64 = __ESIMD_NS::simd<T, N>(src0);
-  Result64 += __ESIMD_NS::simd<T, N>(src1);
-  auto Result32 = Result64.template bit_cast_view<T>();
-  __ESIMD_NS::simd<uint32_t, N> CarryV = Result32.template select<N, 2>(1);
-  __ESIMD_NS::simd<uint32_t, N> ResV = Result32.template select<N, 2>(0);
-  std::pair<__ESIMD_DNS::vector_type_t<T, N>, __ESIMD_DNS::vector_type_t<T, N>>
-      ReturnValue = std::make_pair(CarryV.data(), ResV.data());
-  return ReturnValue;
+  __ESIMD_UNSUPPORTED_ON_HOST;
+
+  return std::pair<__ESIMD_DNS::vector_type_t<T, N>,
+                   __ESIMD_DNS::vector_type_t<T, N>>();
 }
 #endif // !__SYCL_DEVICE_ONLY__
 
@@ -743,15 +739,10 @@ __esimd_subb(__ESIMD_DNS::vector_type_t<T, N> src0,
     ;
 #else  // !__SYCL_DEVICE_ONLY__
 {
-  __ESIMD_NS::simd<uint64_t, N> Result64 = __ESIMD_NS::simd<T, N>(src0);
-  Result64 -= __ESIMD_NS::simd<T, N>(src1);
-  auto Result32 = Result64.template bit_cast_view<T>();
-  __ESIMD_NS::simd<uint32_t, N> BorrowV =
-      __ESIMD_NS::simd<T, N>(src0) < __ESIMD_NS::simd<T, N>(src1);
-  __ESIMD_NS::simd<uint32_t, N> ResV = Result32.template select<N, 2>(0);
-  std::pair<__ESIMD_DNS::vector_type_t<T, N>, __ESIMD_DNS::vector_type_t<T, N>>
-      ReturnValue = std::make_pair(BorrowV.data(), ResV.data());
-  return ReturnValue;
+  __ESIMD_UNSUPPORTED_ON_HOST;
+
+  return std::pair<__ESIMD_DNS::vector_type_t<T, N>,
+                   __ESIMD_DNS::vector_type_t<T, N>>();
 }
 #endif // !__SYCL_DEVICE_ONLY__
 
