// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -fsycl-is-device -internal-isystem %S/Inputs -triple spir64-unknown-unknown -disable-llvm-passes -emit-llvm %s -o - | FileCheck %s

#include "sycl.hpp"

sycl::queue myQueue;

using namespace sycl;

// CHECK: %struct.__wrapper_class = type { [2 x i32] }
// CHECK: %class.anon = type { [2 x i32] }
// CHECK: %struct.__wrapper_class.0 = type { [2 x ptr addrspace(1)] }
// CHECK: %class.anon.1 = type { [2 x ptr addrspace(4)] }

int main() {
  int Array[2];
  myQueue.submit([&](sycl::handler &h) {
    h.single_task<class IntArray>(
        [=] {
          int local = Array[1];
        });
  });

// CHECK-LABEL: @{{.*}}IntArray(ptr {{.*}}byval(%struct.__wrapper_class)
// CHECK:   %__SYCLKernel = alloca %class.anon, align 4
// CHECK:   %__SYCLKernel.ascast = addrspacecast ptr %__SYCLKernel to ptr addrspace(4)
// CHECK:   %_arg_Array.ascast = addrspacecast ptr %_arg_Array to ptr addrspace(4)
// CHECK:   %Array = getelementptr inbounds nuw %class.anon, ptr addrspace(4) %__SYCLKernel.ascast, i32 0, i32 0
// CHECK:   %0 = getelementptr inbounds nuw %struct.__wrapper_class, ptr addrspace(4) %_arg_Array.ascast, i32 0, i32 0
// CHECK:   %arrayinit.begin = getelementptr inbounds [2 x i32], ptr addrspace(4) %Array, i64 0, i64 0
// CHECK:   br label %arrayinit.body
// CHECK: arrayinit.body:                                   ; preds = %arrayinit.body, %entry
// CHECK:   %arrayinit.index = phi i64 [ 0, %entry ], [ %arrayinit.next, %arrayinit.body ]
// CHECK:   %1 = getelementptr inbounds i32, ptr addrspace(4) %arrayinit.begin, i64 %arrayinit.index
// CHECK:   %arrayidx = getelementptr inbounds nuw [2 x i32], ptr addrspace(4) %0, i64 0, i64 %arrayinit.index
// CHECK:   %2 = load i32, ptr addrspace(4) %arrayidx, align 4
// CHECK:   store i32 %2, ptr addrspace(4) %1, align 4
// CHECK:   %arrayinit.next = add nuw i64 %arrayinit.index, 1
// CHECK:   %arrayinit.done = icmp eq i64 %arrayinit.next, 2
// CHECK:   br i1 %arrayinit.done, label %arrayinit.end, label %arrayinit.body
// CHECK: arrayinit.end:                                    ; preds = %arrayinit.body

  int *ArrayOfPointers[2];
  myQueue.submit([&](sycl::handler &h) {
    h.single_task<class PtrArray>(
        [=] {
          int local = *ArrayOfPointers[1];
        });
  });
// CHECK-LABEL: @{{.*}}PtrArray(ptr {{.*}}byval(%struct.__wrapper_class.0)
// CHECK:   %__SYCLKernel = alloca %class.anon.1, align 8
// CHECK:   %__SYCLKernel.ascast = addrspacecast ptr %__SYCLKernel to ptr addrspace(4)
// CHECK:   %_arg_ArrayOfPointers.ascast = addrspacecast ptr %_arg_ArrayOfPointers to ptr addrspace(4)
// CHECK:   %ArrayOfPointers = getelementptr inbounds nuw %class.anon.1, ptr addrspace(4) %__SYCLKernel.ascast, i32 0, i32 0
// CHECK:   %0 = getelementptr inbounds nuw %struct.__wrapper_class.0, ptr addrspace(4) %_arg_ArrayOfPointers.ascast, i32 0, i32 0
// CHECK:   %arrayidx = getelementptr inbounds nuw [2 x ptr addrspace(1)], ptr addrspace(4) %0, i64 0, i64 0
// CHECK:   %1 = load ptr addrspace(1), ptr addrspace(4) %arrayidx, align 8
// CHECK:   %2 = addrspacecast ptr addrspace(1) %1 to ptr addrspace(4)
// CHECK:   store ptr addrspace(4) %2, ptr addrspace(4) %ArrayOfPointers, align 8
// CHECK:   %arrayinit.element = getelementptr inbounds ptr addrspace(4), ptr addrspace(4) %ArrayOfPointers, i64 1
// CHECK:   %3 = getelementptr inbounds nuw %struct.__wrapper_class.0, ptr addrspace(4) %_arg_ArrayOfPointers.ascast, i32 0, i32 0
// CHECK:   %arrayidx1 = getelementptr inbounds nuw [2 x ptr addrspace(1)], ptr addrspace(4) %3, i64 0, i64 1
// CHECK:   %4 = load ptr addrspace(1), ptr addrspace(4) %arrayidx1, align 8
// CHECK:   %5 = addrspacecast ptr addrspace(1) %4 to ptr addrspace(4)
// CHECK:   store ptr addrspace(4) %5, ptr addrspace(4) %arrayinit.element, align 8
}
