  // RUN: cgeist %s --function=* -S | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.

#include <complex>

using namespace std;

// CHECK-LABEL:   func.func @_Z12init_complexv() -> !llvm.struct<(struct<(f32, f32)>)> 
// CHECK-NEXT:      %[[VAL_0:.*]] = arith.constant 1.500000e+00 : f32
// CHECK-NEXT:      %[[VAL_1:.*]] = arith.constant 4.500000e+00 : f32
// CHECK-NEXT:      %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      call @_ZNSt7complexIfEC1Eff(%[[VAL_3]], %[[VAL_1]], %[[VAL_0]]) : (!llvm.ptr, f32, f32) -> ()
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.load %[[VAL_3]] : !llvm.ptr -> !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      return %[[VAL_4]] : !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:    }

// CHECK-LABEL:   func.func @_ZNSt7complexIfEC1Eff(
// CHECK-SAME:                                     %[[VAL_0:.*]]: !llvm.ptr,
// CHECK-SAME:                                     %[[VAL_1:.*]]: f32,
// CHECK-SAME:                                     %[[VAL_2:.*]]: f32) 
  // CHECK-NEXT:      %[[VAL_3:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.alloca %[[VAL_3]] x !llvm.struct<(f32, f32)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      %[[VAL_5:.*]] = llvm.getelementptr inbounds %[[VAL_4]][0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(f32, f32)>
// CHECK-NEXT:      llvm.store %[[VAL_1]], %[[VAL_5]] : f32, !llvm.ptr
// CHECK-NEXT:      %[[VAL_6:.*]] = llvm.getelementptr inbounds %[[VAL_4]][0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(f32, f32)>
// CHECK-NEXT:      llvm.store %[[VAL_2]], %[[VAL_6]] : f32, !llvm.ptr
// CHECK-NEXT:      %[[VAL_7:.*]] = llvm.getelementptr inbounds %[[VAL_0]][0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      %[[VAL_8:.*]] = llvm.load %[[VAL_4]] : !llvm.ptr -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      llvm.store %[[VAL_8]], %[[VAL_7]] : !llvm.struct<(f32, f32)>, !llvm.ptr
// CHECK-NEXT:      return
// CHECK-NEXT:    }

complex<float> init_complex(){
  return complex<float>{4.5f, 1.5f};
}

// CHECK-LABEL:   func.func @_Z9init_realv() -> !llvm.struct<(struct<(f32, f32)>)> 
// CHECK-NEXT:      %[[SIZE:.*]] = arith.constant 8 : i64
// CHECK-NEXT:      %[[VAL_0:.*]] = arith.constant 1.500000e+00 : f32
// CHECK-NEXT:      %[[VAL_1:.*]] = arith.constant 0.000000e+00 : f32
// CHECK-NEXT:      %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      call @_ZNSt7complexIfEC1Eff(%[[VAL_4]], %[[VAL_1]], %[[VAL_1]]) : (!llvm.ptr, f32, f32) -> ()
// CHECK-NEXT:      %[[VAL_5:.*]] = call @_ZNSt7complexIfEaSEf(%[[VAL_4]], %[[VAL_0]]) : (!llvm.ptr, f32) -> !llvm.ptr
// CHECK-NEXT:      "llvm.intr.memcpy"(%[[VAL_3]], %[[VAL_4]], %[[SIZE]]) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
// CHECK-NEXT:      %[[VAL_6:.*]] = llvm.load %[[VAL_3]] : !llvm.ptr -> !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      return %[[VAL_6]] : !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:    }

// CHECK-LABEL:   func.func @_ZNSt7complexIfEaSEf(
// CHECK-SAME:                                    %[[VAL_0:.*]]: !llvm.ptr,
// CHECK-SAME:                                    %[[VAL_1:.*]]: f32) -> !llvm.ptr 
// CHECK-NEXT:      %[[VAL_2:.*]] = llvm.mlir.constant(1 : i64) : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = llvm.mlir.constant(0.000000e+00 : f32) : f32
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(f32, f32)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_1]], %[[VAL_4]] : f32, !llvm.ptr
// CHECK-NEXT:      %[[VAL_5:.*]] = llvm.getelementptr inbounds %[[VAL_4]][0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(f32, f32)>
// CHECK-NEXT:      llvm.store %[[VAL_3]], %[[VAL_5]] : f32, !llvm.ptr
// CHECK-NEXT:      %[[VAL_6:.*]] = llvm.load %[[VAL_4]] : !llvm.ptr -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_7:.*]] = llvm.getelementptr inbounds %[[VAL_0]][0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      llvm.store %[[VAL_6]], %[[VAL_7]] : !llvm.struct<(f32, f32)>, !llvm.ptr
// CHECK-NEXT:      return %[[VAL_0]] : !llvm.ptr
// CHECK-NEXT:    }

complex<float> init_real(){
  complex<float> res;
  res = 1.5f;
  return res;
}

// CHECK-LABEL:   func.func @_Z11access_realSt7complexIfE(
// CHECK-SAME:                                            %[[VAL_0:.*]]: !llvm.struct<(struct<(f32, f32)>)>) -> f32 
// CHECK-NEXT:      %[[VAL_1:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_2:.*]] = llvm.alloca %[[VAL_1]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_0]], %[[VAL_2]] : !llvm.struct<(struct<(f32, f32)>)>, !llvm.ptr
// CHECK-NEXT:      %[[VAL_3:.*]] = call @_ZNKSt7complexIfE4realB5cxx11Ev(%[[VAL_2]]) : (!llvm.ptr) -> f32
// CHECK-NEXT:      return %[[VAL_3]] : f32
// CHECK-NEXT:    }

// CHECK-LABEL:   func.func @_ZNKSt7complexIfE4realB5cxx11Ev(
// CHECK-SAME:                                               %[[VAL_0:.*]]: !llvm.ptr) -> f32 
// CHECK-NEXT:      %[[VAL_1:.*]] = llvm.getelementptr inbounds %[[VAL_0]][0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      %[[VAL_2:.*]] = llvm.load %[[VAL_1]] : !llvm.ptr -> f32
// CHECK-NEXT:      return %[[VAL_2]] : f32
// CHECK-NEXT:    }

float access_real(complex<float> c){
  return c.real();
}

// CHECK-LABEL:   func.func @_Z11access_imagSt7complexIfE(
// CHECK-SAME:                                            %[[VAL_0:.*]]: !llvm.struct<(struct<(f32, f32)>)>) -> f32 
// CHECK-NEXT:      %[[VAL_1:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_2:.*]] = llvm.alloca %[[VAL_1]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_0]], %[[VAL_2]] : !llvm.struct<(struct<(f32, f32)>)>, !llvm.ptr
// CHECK-NEXT:      %[[VAL_3:.*]] = call @_ZNKSt7complexIfE4imagB5cxx11Ev(%[[VAL_2]]) : (!llvm.ptr) -> f32
// CHECK-NEXT:      return %[[VAL_3]] : f32
// CHECK-NEXT:    }

// CHECK-LABEL:   func.func @_ZNKSt7complexIfE4imagB5cxx11Ev(
// CHECK-SAME:                                               %[[VAL_0:.*]]: !llvm.ptr) -> f32 
// CHECK-NEXT:      %[[VAL_1:.*]] = llvm.getelementptr inbounds %[[VAL_0]][0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      %[[VAL_2:.*]] = llvm.getelementptr inbounds %[[VAL_1]][0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_3:.*]] = llvm.load %[[VAL_2]] : !llvm.ptr -> f32
// CHECK-NEXT:      return %[[VAL_3]] : f32
// CHECK-NEXT:    }

float access_imag(complex<float> c){
  return c.imag();
}

// CHECK-LABEL:   func.func @_Z16multiply_complexSt7complexIfES0_(
// CHECK-SAME:                                                    %[[VAL_0:.*]]: !llvm.struct<(struct<(f32, f32)>)>,
// CHECK-SAME:                                                    %[[VAL_1:.*]]: !llvm.struct<(struct<(f32, f32)>)>) -> !llvm.struct<(struct<(f32, f32)>)> 
// CHECK-NEXT:      %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_0]], %[[VAL_4]] : !llvm.struct<(struct<(f32, f32)>)>, !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_1]], %[[VAL_3]] : !llvm.struct<(struct<(f32, f32)>)>, !llvm.ptr
// CHECK-NEXT:      %[[VAL_5:.*]] = call @_ZStmlIfESt7complexIT_ERKS2_S4_(%[[VAL_4]], %[[VAL_3]]) : (!llvm.ptr, !llvm.ptr) -> !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      return %[[VAL_5]] : !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:    }

// CHECK-LABEL:   func.func @_ZStmlIfESt7complexIT_ERKS2_S4_(
// CHECK-SAME:                                               %[[VAL_0:.*]]: !llvm.ptr,
// CHECK-SAME:                                               %[[VAL_1:.*]]: !llvm.ptr) -> !llvm.struct<(struct<(f32, f32)>)> 
// CHECK-NEXT:      %[[SIZE:.*]] = arith.constant 8 : i64
// CHECK-NEXT:      %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      "llvm.intr.memcpy"(%[[VAL_4]], %[[VAL_0]], %[[SIZE]]) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
// CHECK-NEXT:      %[[VAL_5:.*]] = call @_ZNSt7complexIfEmLIfEERS0_RKS_IT_E(%[[VAL_4]], %[[VAL_1]]) : (!llvm.ptr, !llvm.ptr) -> !llvm.ptr
// CHECK-NEXT:      "llvm.intr.memcpy"(%[[VAL_3]], %[[VAL_4]], %[[SIZE]]) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
// CHECK-NEXT:      %[[VAL_6:.*]] = llvm.load %[[VAL_3]] : !llvm.ptr -> !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      return %[[VAL_6]] : !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:    }

complex<float> multiply_complex(complex<float> a, complex<float> b){
  return a * b;
}

// CHECK-LABEL:   func.func @_Z14multiply_floatSt7complexIfEf(
// CHECK-SAME:                                                %[[VAL_0:.*]]: !llvm.struct<(struct<(f32, f32)>)>,
// CHECK-SAME:                                                %[[VAL_1:.*]]: f32) -> !llvm.struct<(struct<(f32, f32)>)> 
// CHECK-NEXT:      %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = memref.alloca() : memref<1xf32>
// CHECK-NEXT:      %[[VAL_4:.*]] = memref.cast %[[VAL_3]] : memref<1xf32> to memref<?xf32>
// CHECK-NEXT:      %[[VAL_5:.*]] = llvm.mlir.undef : f32
// CHECK-NEXT:      %[[VAL_6:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_0]], %[[VAL_6]] : !llvm.struct<(struct<(f32, f32)>)>, !llvm.ptr
// CHECK-NEXT:      affine.store %[[VAL_1]], %[[VAL_3]][0] : memref<1xf32>
// CHECK-NEXT:      %[[VAL_7:.*]] = call @_ZStmlIfESt7complexIT_ERKS2_RKS1_(%[[VAL_6]], %[[VAL_4]]) : (!llvm.ptr, memref<?xf32>) -> !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      return %[[VAL_7]] : !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:    }

// CHECK-LABEL:   func.func @_ZStmlIfESt7complexIT_ERKS2_RKS1_(
// CHECK-SAME:                                                 %[[VAL_0:.*]]: !llvm.ptr,
// CHECK-SAME:                                                 %[[VAL_1:.*]]: memref<?xf32>) -> !llvm.struct<(struct<(f32, f32)>)> 
// CHECK-NEXT:      %[[SIZE:.*]] = arith.constant 8 : i64
// CHECK-NEXT:      %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      "llvm.intr.memcpy"(%[[VAL_4]], %[[VAL_0]], %[[SIZE]]) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
// CHECK-NEXT:      %[[VAL_5:.*]] = affine.load %[[VAL_1]][0] : memref<?xf32>
// CHECK-NEXT:      %[[VAL_6:.*]] = call @_ZNSt7complexIfEmLEf(%[[VAL_4]], %[[VAL_5]]) : (!llvm.ptr, f32) -> !llvm.ptr
// CHECK-NEXT:      "llvm.intr.memcpy"(%[[VAL_3]], %[[VAL_4]], %[[SIZE]]) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
// CHECK-NEXT:      %[[VAL_7:.*]] = llvm.load %[[VAL_3]] : !llvm.ptr -> !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      return %[[VAL_7]] : !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:    }

complex<float> multiply_float(complex<float> a, float b){
  return a * b;
}

// CHECK-LABEL:   func.func @_Z11add_complexSt7complexIfES0_(
// CHECK-SAME:                                               %[[VAL_0:.*]]: !llvm.struct<(struct<(f32, f32)>)>,
// CHECK-SAME:                                               %[[VAL_1:.*]]: !llvm.struct<(struct<(f32, f32)>)>) -> !llvm.struct<(struct<(f32, f32)>)> 
// CHECK-NEXT:      %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_0]], %[[VAL_4]] : !llvm.struct<(struct<(f32, f32)>)>, !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_1]], %[[VAL_3]] : !llvm.struct<(struct<(f32, f32)>)>, !llvm.ptr
// CHECK-NEXT:      %[[VAL_5:.*]] = call @_ZStplIfESt7complexIT_ERKS2_S4_(%[[VAL_4]], %[[VAL_3]]) : (!llvm.ptr, !llvm.ptr) -> !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      return %[[VAL_5]] : !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:    }

// CHECK-LABEL:   func.func @_ZStplIfESt7complexIT_ERKS2_S4_(
// CHECK-SAME:                                               %[[VAL_0:.*]]: !llvm.ptr,
// CHECK-SAME:                                               %[[VAL_1:.*]]: !llvm.ptr) -> !llvm.struct<(struct<(f32, f32)>)> 
// CHECK-NEXT:      %[[SIZE:.*]] = arith.constant 8 : i64
// CHECK-NEXT:      %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      "llvm.intr.memcpy"(%[[VAL_4]], %[[VAL_0]], %[[SIZE]]) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
// CHECK-NEXT:      %[[VAL_5:.*]] = call @_ZNSt7complexIfEpLIfEERS0_RKS_IT_E(%[[VAL_4]], %[[VAL_1]]) : (!llvm.ptr, !llvm.ptr) -> !llvm.ptr
// CHECK-NEXT:      "llvm.intr.memcpy"(%[[VAL_3]], %[[VAL_4]], %[[SIZE]]) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
// CHECK-NEXT:      %[[VAL_6:.*]] = llvm.load %[[VAL_3]] : !llvm.ptr -> !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      return %[[VAL_6]] : !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:    }

complex<float> add_complex(complex<float> a, complex<float> b){
  return a + b;
}

// CHECK-LABEL:   func.func @_Z9add_floatSt7complexIfEf(
// CHECK-SAME:                                          %[[VAL_0:.*]]: !llvm.struct<(struct<(f32, f32)>)>,
// CHECK-SAME:                                          %[[VAL_1:.*]]: f32) -> !llvm.struct<(struct<(f32, f32)>)> 
// CHECK-NEXT:      %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = memref.alloca() : memref<1xf32>
// CHECK-NEXT:      %[[VAL_4:.*]] = memref.cast %[[VAL_3]] : memref<1xf32> to memref<?xf32>
// CHECK-NEXT:      %[[VAL_5:.*]] = llvm.mlir.undef : f32
// CHECK-NEXT:      %[[VAL_6:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_0]], %[[VAL_6]] : !llvm.struct<(struct<(f32, f32)>)>, !llvm.ptr
// CHECK-NEXT:      affine.store %[[VAL_1]], %[[VAL_3]][0] : memref<1xf32>
// CHECK-NEXT:      %[[VAL_7:.*]] = call @_ZStplIfESt7complexIT_ERKS2_RKS1_(%[[VAL_6]], %[[VAL_4]]) : (!llvm.ptr, memref<?xf32>) -> !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      return %[[VAL_7]] : !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:    }

// CHECK-LABEL:   func.func @_ZStplIfESt7complexIT_ERKS2_RKS1_(
// CHECK-SAME:                                                 %[[VAL_0:.*]]: !llvm.ptr,
// CHECK-SAME:                                                 %[[VAL_1:.*]]: memref<?xf32>) -> !llvm.struct<(struct<(f32, f32)>)> 
// CHECK-NEXT:      %[[SIZE:.*]] = arith.constant 8 : i64
// CHECK-NEXT:      %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(struct<(f32, f32)>)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      "llvm.intr.memcpy"(%[[VAL_4]], %[[VAL_0]], %[[SIZE]]) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
// CHECK-NEXT:      %[[VAL_5:.*]] = affine.load %[[VAL_1]][0] : memref<?xf32>
// CHECK-NEXT:      %[[VAL_6:.*]] = call @_ZNSt7complexIfEpLEf(%[[VAL_4]], %[[VAL_5]]) : (!llvm.ptr, f32) -> !llvm.ptr
// CHECK-NEXT:      "llvm.intr.memcpy"(%[[VAL_3]], %[[VAL_4]], %[[SIZE]]) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
// CHECK-NEXT:      %[[VAL_7:.*]] = llvm.load %[[VAL_3]] : !llvm.ptr -> !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      return %[[VAL_7]] : !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:    }


complex<float> add_float(complex<float> a, float b){
  return a + b;
}

// CHECK-LABEL:   func.func @_ZNSt7complexIfEmLIfEERS0_RKS_IT_E(
// CHECK-SAME:                                                  %[[VAL_0:.*]]: !llvm.ptr,
// CHECK-SAME:                                                  %[[VAL_1:.*]]: !llvm.ptr) -> !llvm.ptr 
// CHECK-NEXT:      %[[VAL_2:.*]] = llvm.mlir.constant(1 : i64) : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = call @_ZNKSt7complexIfE5__repEv(%[[VAL_1]]) : (!llvm.ptr) -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.getelementptr inbounds %[[VAL_0]][0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      %[[VAL_5:.*]] = llvm.load %[[VAL_4]] : !llvm.ptr -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_6:.*]] = llvm.extractvalue %[[VAL_5]][0] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_7:.*]] = llvm.extractvalue %[[VAL_5]][1] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_8:.*]] = llvm.extractvalue %[[VAL_3]][0] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_9:.*]] = llvm.extractvalue %[[VAL_3]][1] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_10:.*]] = llvm.fmul %[[VAL_6]], %[[VAL_8]]  : f32
// CHECK-NEXT:      %[[VAL_11:.*]] = llvm.fmul %[[VAL_7]], %[[VAL_9]]  : f32
// CHECK-NEXT:      %[[VAL_12:.*]] = llvm.fsub %[[VAL_10]], %[[VAL_11]]  : f32
// CHECK-NEXT:      %[[VAL_13:.*]] = llvm.fmul %[[VAL_6]], %[[VAL_9]]  : f32
// CHECK-NEXT:      %[[VAL_14:.*]] = llvm.fmul %[[VAL_7]], %[[VAL_8]]  : f32
// CHECK-NEXT:      %[[VAL_15:.*]] = llvm.fadd %[[VAL_13]], %[[VAL_14]]  : f32
// CHECK-NEXT:      %[[VAL_16:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(f32, f32)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_12]], %[[VAL_16]] : f32, !llvm.ptr
// CHECK-NEXT:      %[[VAL_17:.*]] = llvm.getelementptr inbounds %[[VAL_16]][0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(f32, f32)>
// CHECK-NEXT:      llvm.store %[[VAL_15]], %[[VAL_17]] : f32, !llvm.ptr
// CHECK-NEXT:      %[[VAL_18:.*]] = llvm.load %[[VAL_16]] : !llvm.ptr -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      llvm.store %[[VAL_18]], %[[VAL_4]] : !llvm.struct<(f32, f32)>, !llvm.ptr
// CHECK-NEXT:      return %[[VAL_0]] : !llvm.ptr
// CHECK-NEXT:    }

// CHECK-LABEL:   func.func @_ZNSt7complexIfEmLEf(
// CHECK-SAME:                                    %[[VAL_0:.*]]: !llvm.ptr,
// CHECK-SAME:                                    %[[VAL_1:.*]]: f32) -> !llvm.ptr 
// CHECK-NEXT:      %[[VAL_2:.*]] = llvm.mlir.constant(1 : i64) : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = llvm.mlir.constant(0.000000e+00 : f32) : f32
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.getelementptr inbounds %[[VAL_0]][0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      %[[VAL_5:.*]] = llvm.load %[[VAL_4]] : !llvm.ptr -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_6:.*]] = llvm.extractvalue %[[VAL_5]][0] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_7:.*]] = llvm.extractvalue %[[VAL_5]][1] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_8:.*]] = llvm.fmul %[[VAL_6]], %[[VAL_1]]  : f32
// CHECK-NEXT:      %[[VAL_9:.*]] = llvm.fmul %[[VAL_7]], %[[VAL_3]]  : f32
// CHECK-NEXT:      %[[VAL_10:.*]] = llvm.fsub %[[VAL_8]], %[[VAL_9]]  : f32
// CHECK-NEXT:      %[[VAL_11:.*]] = llvm.fmul %[[VAL_6]], %[[VAL_3]]  : f32
// CHECK-NEXT:      %[[VAL_12:.*]] = llvm.fmul %[[VAL_7]], %[[VAL_1]]  : f32
// CHECK-NEXT:      %[[VAL_13:.*]] = llvm.fadd %[[VAL_11]], %[[VAL_12]]  : f32
// CHECK-NEXT:      %[[VAL_14:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(f32, f32)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_10]], %[[VAL_14]] : f32, !llvm.ptr
// CHECK-NEXT:      %[[VAL_15:.*]] = llvm.getelementptr inbounds %[[VAL_14]][0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(f32, f32)>
// CHECK-NEXT:      llvm.store %[[VAL_13]], %[[VAL_15]] : f32, !llvm.ptr
// CHECK-NEXT:      %[[VAL_16:.*]] = llvm.load %[[VAL_14]] : !llvm.ptr -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      llvm.store %[[VAL_16]], %[[VAL_4]] : !llvm.struct<(f32, f32)>, !llvm.ptr
// CHECK-NEXT:      return %[[VAL_0]] : !llvm.ptr
// CHECK-NEXT:    }

// CHECK-LABEL:   func.func @_ZNSt7complexIfEpLIfEERS0_RKS_IT_E(
// CHECK-SAME:                                                  %[[VAL_0:.*]]: !llvm.ptr,
// CHECK-SAME:                                                  %[[VAL_1:.*]]: !llvm.ptr) -> !llvm.ptr 
// CHECK-NEXT:      %[[VAL_2:.*]] = llvm.mlir.constant(1 : i64) : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = call @_ZNKSt7complexIfE5__repEv(%[[VAL_1]]) : (!llvm.ptr) -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.getelementptr inbounds %[[VAL_0]][0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      %[[VAL_5:.*]] = llvm.load %[[VAL_4]] : !llvm.ptr -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_6:.*]] = llvm.extractvalue %[[VAL_5]][0] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_7:.*]] = llvm.extractvalue %[[VAL_5]][1] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_8:.*]] = llvm.extractvalue %[[VAL_3]][0] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_9:.*]] = llvm.extractvalue %[[VAL_3]][1] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_10:.*]] = llvm.fadd %[[VAL_6]], %[[VAL_8]]  : f32
// CHECK-NEXT:      %[[VAL_11:.*]] = llvm.fadd %[[VAL_7]], %[[VAL_9]]  : f32
// CHECK-NEXT:      %[[VAL_12:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(f32, f32)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_10]], %[[VAL_12]] : f32, !llvm.ptr
// CHECK-NEXT:      %[[VAL_13:.*]] = llvm.getelementptr inbounds %[[VAL_12]][0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(f32, f32)>
// CHECK-NEXT:      llvm.store %[[VAL_11]], %[[VAL_13]] : f32, !llvm.ptr
// CHECK-NEXT:      %[[VAL_14:.*]] = llvm.load %[[VAL_12]] : !llvm.ptr -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      llvm.store %[[VAL_14]], %[[VAL_4]] : !llvm.struct<(f32, f32)>, !llvm.ptr
// CHECK-NEXT:      return %[[VAL_0]] : !llvm.ptr
// CHECK-NEXT:    }

// CHECK-LABEL:   func.func @_ZNSt7complexIfEpLEf(
// CHECK-SAME:                                    %[[VAL_0:.*]]: !llvm.ptr,
// CHECK-SAME:                                    %[[VAL_1:.*]]: f32) -> !llvm.ptr 
// CHECK-NEXT:      %[[VAL_2:.*]] = llvm.mlir.constant(1 : i64) : i64
// CHECK-NEXT:      %[[VAL_3:.*]] = llvm.mlir.constant(0.000000e+00 : f32) : f32
// CHECK-NEXT:      %[[VAL_4:.*]] = llvm.getelementptr inbounds %[[VAL_0]][0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      %[[VAL_5:.*]] = llvm.load %[[VAL_4]] : !llvm.ptr -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_6:.*]] = llvm.extractvalue %[[VAL_5]][0] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_7:.*]] = llvm.extractvalue %[[VAL_5]][1] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:      %[[VAL_8:.*]] = llvm.fadd %[[VAL_6]], %[[VAL_1]]  : f32
// CHECK-NEXT:      %[[VAL_9:.*]] = llvm.fadd %[[VAL_7]], %[[VAL_3]]  : f32
// CHECK-NEXT:      %[[VAL_10:.*]] = llvm.alloca %[[VAL_2]] x !llvm.struct<(f32, f32)> : (i64) -> !llvm.ptr
// CHECK-NEXT:      llvm.store %[[VAL_8]], %[[VAL_10]] : f32, !llvm.ptr
// CHECK-NEXT:      %[[VAL_11:.*]] = llvm.getelementptr inbounds %[[VAL_10]][0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(f32, f32)>
// CHECK-NEXT:      llvm.store %[[VAL_9]], %[[VAL_11]] : f32, !llvm.ptr
// CHECK-NEXT:      %[[VAL_12:.*]] = llvm.load %[[VAL_10]] : !llvm.ptr -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      llvm.store %[[VAL_12]], %[[VAL_4]] : !llvm.struct<(f32, f32)>, !llvm.ptr
// CHECK-NEXT:      return %[[VAL_0]] : !llvm.ptr
// CHECK-NEXT:    }

// CHECK-LABEL:   func.func @_ZNKSt7complexIfE5__repEv(
// CHECK-SAME:                                         %[[VAL_0:.*]]: !llvm.ptr) -> !llvm.struct<(f32, f32)> 
// CHECK-NEXT:      %[[VAL_1:.*]] = llvm.getelementptr inbounds %[[VAL_0]][0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(struct<(f32, f32)>)>
// CHECK-NEXT:      %[[VAL_2:.*]] = llvm.load %[[VAL_1]] : !llvm.ptr -> !llvm.struct<(f32, f32)>
// CHECK-NEXT:      return %[[VAL_2]] : !llvm.struct<(f32, f32)>
// CHECK-NEXT:    }


